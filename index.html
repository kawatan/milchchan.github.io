<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <meta name="theme-color" content="#f6f6f6">
    <title>チャット</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP" rel="stylesheet">
    <link href="https://fonts.googleapis.com/earlyaccess/nicomoji.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Alata&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Sans&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/922939073a.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css" type="text/css"
        media="screen" />
    <style>
        [v-cloak] {
            display: none;
        }

        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            height: -webkit-fill-available;
            overflow-x: hidden;
            overflow-y: auto;
            scroll-behavior: smooth;
            background: #f5f5f5;
        }

        body::before {
            z-index: -1;
            display: block;
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100vh;
            /*background: url('/images/Background.png') 50% 50% repeat;*/
            content: "";
            /*animation: loop 10s linear infinite;*/
        }

        body {
            position: relative;
            margin: 0;
            padding: 0;
            width: 100%;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow: hidden;
        }

        p,
        span,
        input {
            font-family: 'Noto Sans JP', sans-serif;
        }

        label {
            display: inline;
            cursor: pointer;
        }

        .navbar {
            margin: 0;
            padding: 0;
            background-color: transparent;
        }

        .navbar-item {
            padding: 0 !important;
        }

        .columns {
            margin: 0 !important;
        }

        .columns>.column {
            padding: 0 !important;
        }

        .progress {
            position: fixed;
            margin: 0;
            padding: 0;
            border-radius: 0px;
            width: 0%;
            height: 2px;
            top: 0;
            left: 0;
            overflow: hidden;
            background: #ffc547 url('/images/Stripes.png') repeat;
            animation: progress 0.5s linear 0s infinite;
        }

        .background {
            position: fixed;
            z-index: -1;
            overflow: hidden;
            width: 100%;
            height: 100vh;
            background-color: transparent;
            background-position: 50% 50%;
            background-size: contain;
            background-repeat: no-repeat;
        }

        .background>div {
            position: fixed;
            overflow: hidden;
            background-color: transparent;
            background-position: 50% 50%;
            background-size: cover;
            background-repeat: no-repeat;
            width: 100%;
            height: 100%;
        }

        .background>img {
            position: fixed;
            object-fit: cover;
            width: 100%;
            height: 100%;
        }

        #three {
            position: fixed;
            z-index: 0;
            display: block;
            width: 100%;
            height: 100vh;
        }

        #particles-js {
            position: fixed;
            z-index: -1;
            width: 100%;
            height: 100vh;
            background-color: transparent;
        }

        .ticker-wrap {
            padding: 0;
            width: 100%;
            overflow: hidden;
            box-sizing: content-box;
            background-color: transparent;
        }

        .ticker-wrap .ticker {
            display: inline-block;
            white-space: nowrap;
            padding: 0;
            box-sizing: content-box;
            animation-iteration-count: infinite;
            animation-timing-function: linear;
            /*animation-name: ticker;*/
            animation-duration: 30s;
            animation-play-state: paused;
        }

        .ticker-wrap .ticker .item {
            display: inline-block;
            padding: 0px 16px;
        }

        .ticker-wrap .ticker .item>div {
            font-family: 'Noto Sans JP', sans-serif;
        }

        .blind {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            transform: translate3d(0, 0%, 0);
            overflow: hidden;
            background: #64dafe url('/images/Stripes.png') repeat;
            animation: progress 0.5s linear 0s infinite;
        }

        #app {
            position: relative;
            margin: 0;
            width: 100%;
            overflow: hidden;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:first-child {
            margin: 16px 0px 0px 0px;
            padding: 0px 0px 0px 16px !important;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:first-child button {
            border-radius: 290486px;
            padding: 16px;
            background: #ffffff;
            /*background: #f5f5f5;
            background: linear-gradient(145deg, #ffffff, #dddddd);
            box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
            height: initial;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:first-child button>span {
            margin: 0;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:last-child {
            margin: 16px 0px 0px 0px;
            padding: 0px 16px 0px 0px !important;
            text-align: right;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:last-child button {
            border-radius: 290486px;
            padding: 16px;
            background: #ffffff;
            /*background: #f5f5f5;
            background: linear-gradient(145deg, #ffffff, #dddddd);
            box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
            height: initial;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:last-child button>span {
            margin: 0;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:nth-child(2)>.control .level .level-item .field span.icon {
            margin: 0px 8px 0px 0px;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:nth-child(2)>.control {
            margin: 0;
            padding: 16px 16px 16px 16px;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:nth-child(2)>.control>.level:nth-last-of-type(2) {
            margin: 0;
            padding: 0px 0px 8px 0px;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:nth-child(2)>.control .title {
            font-family: 'Alata', sans-serif;
            font-size: 4rem !important;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:nth-child(2)>.control .subtitle {
            font-family: 'Nico Moji', sans-serif;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item {
            padding: 0px 16px 16px 16px;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field {
            margin: 0;
            width: 100%;
            background-color: #30c0f5;
            background-color: #f5f5f5;
            background-color: rgba(0, 0, 0, 1.0);
            /*background-image: url('/images/Stripes.png');
            background-repeat: repeat;*/
            border-radius: 500px 500px 500px 500px;
            padding: 8px 16px 8px 16px;
            /*box-shadow: 20px 20px 60px #d0d0d0,
                -20px -20px 60px #ffffff;*/
            box-sizing: border-box;
            /*backdrop-filter: blur(8px);*/
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .clip {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #heading>.columns>.column>.columns:last-child {
            justify-content: center;
        }

        #heading>.columns>.column>.columns:last-child>.column>.control .level:first-child .level-item {
            padding: 16px 16px 16px 16px;
        }

        #heading .navbar-item .tags>.control {
            margin: 0px 0px 0px 0px;
            padding: 8px 8px 8px 8px;
        }

        #heading .tags {
            margin: 0;
            padding: 0;
            align-items: flex-start;
            justify-content: center;
        }

        #heading .level>.level-item>.tags {
            margin: -8px;
            padding: 0;
        }

        .tags>.tag {
            /*font-family: "Gotham";*/
            margin: 0;
            padding: 0px 8px 0px 8px;
            /*background-image: url('/images/Stripes.png');
            background-repeat: repeat;*/
            padding: 8px 16px 8px 16px;
            border: 0px solid transparent;
            border-radius: 500px 500px 500px 500px;
            background: #ffffff;
            /*background: #f5f5f5;
            background: linear-gradient(145deg, #ffffff, #dddddd);
            box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
            height: initial;
        }

        .columns .is-vcentered {
            align-items: center;
        }

        #container {
            z-index: 0;
            position: relative;
            margin: 0;
            padding: 0px env(safe-area-inset-right, 0px) 0px env(safe-area-inset-left, 0px);
        }

        #container .column hr {
            margin: 8px 0px 8px 0px;
            padding: 0;
            height: 0;
        }

        #container .columns .column .media {
            padding: 16px 16px 16px 16px;
        }

        #container .columns .column .media .media-content .content {
            margin: 0;
            padding: 0;
        }

        #container .columns .column .media .media-content .level:nth-last-of-type(1) .level-item {
            margin: 16px 0px 16px 0px;
            padding: 0;
        }

        #container .columns .column .media .media-content .level:nth-last-of-type(1) .level-item button {
            border-radius: 290486px;
            padding: 16px;
            background: #ffffff;
            /*background: #f5f5f5;
            background: linear-gradient(145deg, #ffffff, #dddddd);
            box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
            height: initial;
        }

        #container .columns .column .media .media-content .level:nth-last-of-type(1) .level-item button span {
            margin: 0;
        }

        #input form .field {
            border-radius: 500px 500px 500px 500px;
            padding: 8px 16px 8px 16px;
            background: #ffffff;
            /*background: #f5f5f5;
            box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
        }

        #input .control .is-primary {
            background-color: #30c0f5;
        }

        .has-content-centered {
            margin-left: auto;
            margin-right: auto;
        }

        /*.media-content .level {
            margin: 0px 0px 4px 0px;
        }*/

        #container .media .media-left .image img {
            box-shadow: 4px 4px 12px #d0d0d0,
                -4px -4px 12px #ffffff;
        }

        #container .media .media-content {
            overflow: visible;
        }

        /*.media-content .content div:last-child {
            margin: 4px 0px 0px 0px;
        }*/

        .media-content p {
            word-wrap: break-word;
            white-space: normal;
        }

        .media-content .has-text-left .balloon {
            display: inline-block;
            padding: 16px 32px 16px 32px;
            border-radius: 0px 500px 500px 500px;
            /*background: url('/images/Stripes.png') repeat;*/
            background: #f5f5f5;
            box-shadow: 20px 20px 60px #d0d0d0,
                -20px -20px 60px #ffffff;
        }

        .media-content .has-text-right .balloon {
            display: inline-block;
            padding: 16px 32px 16px 32px;
            border-radius: 500px 500px 0px 500px;
            /*background: url('/images/Stripes.png') repeat;*/
            background: #f5f5f5;
            box-shadow: 20px 20px 60px #d0d0d0,
                -20px -20px 60px #ffffff;
        }

        .media-content>.level span {
            font-family: 'Noto Sans JP', sans-serif;
        }

        .media-content .balloon span {
            font-family: 'Noto Sans JP', sans-serif;
        }

        .media-content .has-text-left div:nth-last-of-type(1)>p {
            font-family: 'Alata', 'Josefin Sans', sans-serif;
        }

        .media-content .has-text-right div:nth-last-of-type(1)>p {
            font-family: 'Alata', 'Josefin Sans', sans-serif;
            /*font-family: 'Fredoka One', cursive;*/
        }

        #heading {
            margin: 0;
            padding: env(safe-area-inset-top, 0px) env(safe-area-inset-right, 0px) 0px env(safe-area-inset-left, 0px);
        }

        #heading .navbar-item .control nav.level:nth-last-child(1) {
            display: block;
        }

        #popup {
            margin: 0;
            padding: 0;
        }

        #popup .columns {
            background: linear-gradient(0deg, rgba(0, 0, 0, 0.25), rgba(0, 0, 0, 0));
            backdrop-filter: blur(8px);
        }

        #popup .columns>.column>.control:last-child {
            margin: 0;
            padding: 0px env(safe-area-inset-right, 0px) env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
        }

        #popup .columns>.column>.control:last-child .level:nth-of-type(1) {
            margin: 0;
            padding: 16px 16px 32px 16px;
        }

        #popup .columns>.column>.control:last-child .level:nth-last-of-type(1) {
            display: block;
            margin: 0;
            padding: 0px 16px 16px 16px;
        }

        #popup .columns>.column>.control:first-child .level:first-child .media {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 500px 500px 500px 500px;
            padding: 8px 16px 8px 16px;
            background: #ffa6bb url('/images/Stripes.png') repeat;
            /*box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
        }

        #popup .columns>.column>.control:last-child .level:nth-of-type(2) .media span {
            display: inline-block;
            font-family: 'Noto Sans JP', 'Josefin Sans', sans-serif;
            line-height: 1.5rem;
            text-shadow: #d0d0d0 0px 0px 60px;
        }

        #input .navbar-item .control:first-child .level {
            display: block;
            margin: 0;
            padding: 16px 0px 0px 0px;
        }

        #input .navbar-item .control:first-child .level .notification {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            margin: 0;
            padding: 0;
        }

        #input .navbar-item .control:first-child .level .is-info {
            color: #ffffff;
        }

        #input .navbar-item .control:first-child .level .notification .media {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 500px 500px 500px 500px;
            padding: 16px 32px 16px 32px;
            background: url('/images/Stripes.png') repeat;
        }

        #input .notification .media .media-left {
            margin: 0px 8px 0px 0px;
        }

        #input .navbar-item>div>.control:last-child {
            margin: 0;
            padding: 0px env(safe-area-inset-right, 0px) env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
        }

        #input .columns>.column .control:nth-last-of-type(2) {
            margin: 0;
            padding: 0px 16px 0px 16px;
        }

        #input .columns>.column .control:nth-last-of-type(2) .level:nth-last-of-type(2) .notification {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            margin: 0;
            padding: 0;
        }

        #input .columns>.column .control:nth-last-of-type(2) .level:nth-last-of-type(2) .notification .media {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 500px 500px 500px 500px;
            padding: 16px 32px 16px 32px;
            background: #5bcbe1 url('/images/Stripes.png') repeat;
        }

        #input .columns>.column .control:nth-last-of-type(2) .level:nth-last-of-type(2) .notification .media .media-left {
            margin: 0px 8px 0px 0px;
        }

        #container .columns .column .columns .column .field label.checkbox,
        #input .columns>.column .control:nth-last-of-type(1) .level:nth-last-of-type(2) .level-left {
            margin: 16px 0px 0px 0px;
            padding: 16px 32px 16px 32px;
            border-radius: 500px 500px 500px 500px;
            background: #ffffff;
            /*background: rgba(0, 0, 0, 0.75);
            background: #f5f5f5;
            background: linear-gradient(145deg, #ffffff, #dddddd);
            box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
        }

        #container .columns .column .media .media-content {
            margin: -16px 0px 0px 0px;
            padding: 0;
        }

        #container .columns .column .media .media-content .columns {
            margin: 0;
            padding: 0;
            width: 100%;
        }

        #container .columns .column .media .media-content .columns .column .field {
            margin: 0;
            padding: 0px -8px 0px -8px;
            display: flex;
            align-items: center;
            justify-content: start;
        }


        label.checkbox input[type=checkbox],
        label.checkbox input[type=radio] {
            display: none;
        }

        label.checkbox .custom {
            position: relative;
            margin: 0px 8px 0px 0px;
            font-size: 1.0rem;
        }

        label.checkbox input[type=checkbox]+.custom:before,
        label.checkbox input[type=radio]+.custom:before {
            font-weight: 900;
            font-family: "Font Awesome 5 Free";
            content: '\f00c';
            color: rgba(255, 255, 255, 0.5);
        }

        label.checkbox input[type=checkbox]:checked+.custom:before,
        label.checkbox input[type=radio]:checked+.custom:before {
            color: #30c0f5;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(2) {
            margin: 0;
            padding: 0px 16px 0px 16px;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) {
            display: block;
            margin: 0;
            padding: 16px 16px 16px 16px;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) form .field .control:nth-of-type(1) button {
            padding: 8px 16px 8px 16px;
            border: 0px solid transparent;
            border-radius: 290486px;
            background-color: transparent;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) form .field .control:nth-of-type(2) input {
            border: 0px solid transparent;
            padding-top: 8px;
            padding-bottom: 8px;
            background-color: transparent;
            box-shadow: none;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) form .field .control:nth-of-type(3) {
            display: flex;
            align-items: center;
            padding: 0px 8px 0px 8px;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) form .field .control:nth-of-type(3) span {
            font-family: 'Alata', 'Josefin Sans', sans-serif;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) form .field .control:nth-of-type(4) button {
            border: 0px solid transparent;
            border-radius: 290486px;
            background-color: transparent;
            color: #30c0f5;
        }

        .navbar-item img {
            max-height: none;
        }

        .updating {
            animation: updating 1s linear infinite;
        }

        .fade-enter-active,
        .fade-leave-active {
            transition: opacity 0.5s;
        }

        .fade-enter-from,
        .fade-leave-to {
            opacity: 0;
        }

        .reveal-enter-active,
        .reveal-leave-active {
            transition: all .5s ease;
        }

        .reveal-enter-from,
        .reveal-leave-to {
            opacity: 0;
            transform: translate3d(0, -50%, 0);
        }

        .reveal-enter-to,
        .reveal-leave-from {
            opacity: 1;
            transform: translate3d(0, 0%, 0);
        }

        .collapse-enter-active,
        .collapse-leave-active {
            transition: all .5s ease;
        }

        .collapse-enter-from,
        .collapse-leave-to {
            opacity: 0;
        }

        .collapse-enter-to,
        .collapse-leave-from {
            opacity: 1;
        }

        .blind-enter-active,
        .blind-leave-active {
            transition: all .5s ease;
        }

        .blind-enter-from {
            transform: translate3d(0, 100%, 0);
        }

        .blind-enter-to {
            transform: translate3d(0, 0%, 0);
        }

        .blind-leave-from {
            transform: translate3d(0, 0%, 0);
        }

        .blind-leave-to {
            transform: translate3d(0, -100%, 0);
        }

        .message-list-enter-active,
        .message-list-leave-active {
            transition: all 0.5s ease;
        }

        .message-list-move {
            transition: transform 0.5s ease;
        }

        .message-list-enter-from {
            opacity: 0;
            transform: translate3d(0%, 50%, 0);
        }

        .message-list-enter-to,
        .message-list-leave-from {
            opacity: 1;
            transform: translate3d(0%, 0%, 0);
        }

        .message-list-leave-to {
            opacity: 0;
            transform: translate3d(0%, -50%, 0);
        }

        .notification-list-enter-active,
        .notification-list-leave-active {
            transition: all 0.5s ease;
        }

        .notification-list-move {
            transition: transform 0.5s ease;
        }

        .notification-list-enter-from {
            opacity: 0;
            transform: translate3d(0%, 50%, 0);
        }

        .notification-list-enter-to,
        .notification-list-leave-from {
            opacity: 1;
            transform: translate3d(0%, 0%, 0);
        }

        .notification-list-leave-to {
            opacity: 0;
            transform: translate3d(0%, 0%, 0);
        }

        .type-list-enter-active,
        .type-list-leave-active {
            transition: all 0s ease;
        }

        .type-list-move {
            transition: transform 0s ease;
        }

        .type-list-enter-from,
        .type-list-leave-to {
            opacity: 0;
            transform: translate3d(0%, 25%, 0);
        }

        .type-list-enter-to,
        .type-list-leave-from {
            opacity: 1;
            transform: translate3d(0%, 0%, 0);
        }

        .popup-enter-active,
        .popup-leave-active {
            transition: all .5s ease;
        }

        .popup-enter-from {
            opacity: 0;
            transform: translate3d(0, 100%, 0);
        }

        .popup-enter-to {
            opacity: 1;
            transform: translate3d(0, 0%, 0);
        }

        .popup-leave-from {
            opacity: 1;
            transform: translate3d(0, 0%, 0);
        }

        .popup-leave-to {
            opacity: 0;
            transform: translate3d(0, 100%, 0);
        }

        .ticker-item-list-enter-active,
        .ticker-item-list-leave-active {
            transition: all 0.5s ease;
        }

        .ticker-item-list-move {
            transition: transform 0.5s ease;
        }

        .ticker-item-list-enter-from,
        .ticker-item-list-leave-to {
            opacity: 0;
        }

        .ticker-item-list-enter-to,
        .ticker-item-list-leave-from {
            opacity: 1;
        }

        @keyframes ticker {
            0% {
                transform: translate3d(0, 0, 0);
                visibility: visible;
            }

            100% {
                transform: translate3d(-50%, 0, 0);
            }
        }

        @keyframes loop {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 128px -128px;
            }
        }

        @keyframes progress {
            0% {
                background-position: 0px 0px;
            }

            100% {
                background-position: -20px 0px;
            }
        }

        @keyframes updating {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(-360deg);
            }
        }

        @media screen and (-webkit-min-device-pixel-ratio:2),
        (min-resolution: 2dppx) {
            body::before {
                background: url('/images/Background@2x.png') 50% 50% repeat 128px 128px;
            }

            .progress {
                background: #ffc547 url('/images/Stripes@2x.png') repeat 20px 20px;
            }

            .cover {
                background: #30c0f5 url('/images/Stripes@2x.png') repeat 20px 20px;
            }

            .navbar:nth-of-type(2) .navbar-item .control:first-child .level:first-child .media {
                background: #ffa6bb url('/images/Stripes@2x.png') repeat 20px 20px;
            }

            #input .columns>.column .control:nth-last-of-type(2) .level:nth-last-of-type(2) .notification .media {
                background: #5bcbe1 url('/images/Stripes@2x.png') repeat 20px 20px;
            }

            /*.tags>.tag {
                background-image: url('/images/Stripes@2x.png');
                background-size: 20px 20px;
            }

            .media-content .has-text-left .balloon {
                background: url('/images/Stripes@2x.png') repeat 20px 20px;
            }

            .media-content .has-text-right .balloon {
                background: url('/images/Stripes@2x.png') repeat 20px 20px;
            }*/
        }

        @media screen and (-webkit-min-device-pixel-ratio:3),
        (min-resolution: 3dppx) {
            body::before {
                background: url('/images/Background@3x.png') 50% 50% repeat 128px 128px;
            }

            .progress {
                background: #ffc547 url('/images/Stripes@3x.png') repeat 20px 20px;
            }

            .cover {
                background: #30c0f5 url('/images/Stripes@3x.png') repeat 20px 20px;
            }

            .navbar:nth-of-type(2) .navbar-item .control:first-child .level:first-child .media {
                background: #ffa6bb url('/images/Stripes@3x.png') repeat 20px 20px;
            }

            #input .columns>.column .control:nth-last-of-type(2) .level:nth-last-of-type(2) .notification .media {
                background-image: #5bcbe1 url('/images/Stripes@3x.png') repeat 20px 20px;
            }

            /*.tags>.tag {
                background-image: url('/images/Stripes@3x.png');
                background-size: 20px 20px;
            }

            .media-content .has-text-left .balloon {
                background: url('/images/Stripes@3x.png') repeat 20px 20px;
            }

            .media-content .has-text-right .balloon {
                background: url('/images/Stripes@3x.png') repeat 20px 20px;
            }*/
        }

        @font-face {
            font-family: "Gotham";
            src: url('/fonts/GothamRnd-Book.woff') format('woff');
            font-weight: normal;
        }

        @font-face {
            font-family: "Gotham";
            src: url('/fonts/GothamRnd-Bold.woff') format('woff');
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div id="particles-js"></div>
    <div id="app">
        <div class="background is-hidden">
            <div v-bind:style="{ backgroundImage: 'url(' + image.url + ')', marginLeft: image.index * 100 + '%' }"
                v-for="image in backgroundImages" v-bind:key="image" v-cloak></div>
            <img v-bind:src="image.url" @load="load(image.url)" @error="error(image.url)" v-for="image in preloadImages"
                v-bind:key="image.url" alt="Background" v-cloak>
        </div>
        <transition name="blind" v-on:after-enter="blinded">
            <div class="blind" v-if="isBlinded" v-cloak></div>
        </transition>
        <div id="three" ref="three"></div>
        <transition name="fade">
            <div class="progress" v-if="progress !== 0.0" v-bind:style="{width: String(100.0 * progress) + '%'}"
                v-cloak>
            </div>
        </transition>
        <nav id="heading" class="navbar is-fixed-top" role="navigation">
            <div class="navbar-item is-expanded columns is-desktop">
                <div class="column is-full has-content-centered" v-cloak>
                    <div class="columns is-mobile" ref="indicator">
                        <div class="column is-full">
                            <div class="columns is-mobile">
                                <div class="column is-3 is-mobile">
                                    <button class="button is-white" type="button" @click="isRevealed = !isRevealed">
                                        <span class="icon is-small">
                                            <i class="fas fa-bars"></i>
                                        </span>
                                    </button>
                                </div>
                                <div class="column is-6 is-mobile">
                                    <div class="control has-text-centered">
                                        <nav class="level is-hidden">
                                            <div class="level-item has-text-centered image">
                                                <a href="/"><img src="/images/Logo.png"
                                                        srcset="/images/Logo.png 1x, /images/Logo@2x.png 2x, /images/Logo@3x.png 3x"
                                                        alt="milchchan.com"></a>
                                            </div>
                                        </nav>
                                        <nav class="level">
                                            <div class="level-item has-text-centered">
                                                <div class="field is-grouped is-vcentered">
                                                    <span class="icon is-small has-text-black">
                                                        <i class="fas fa-star"></i>
                                                    </span>
                                                    <span
                                                        class="title is-size-1 is-uppercase has-text-black">{{ animatedStars }}</span>
                                                </div>
                                            </div>
                                        </nav>
                                        <nav class="level">
                                            <div class="level-item has-text-centered">
                                                <div class="field">
                                                    <h6
                                                        class="subtitle is-size-6 is-uppercase has-text-weight-bold has-text-black">
                                                        つかったことば
                                                    </h6>
                                                </div>
                                            </div>
                                        </nav>
                                    </div>
                                </div>
                                <div class="column is-3 is-mobile">
                                    <transition name="fade" mode="out-in">
                                        <button class="button is-white" type="button" v-bind:disabled="user === null"
                                            @click="like" v-if="isSuggested" key="cancel">
                                            <span class="icon is-small">
                                                <i class="fas fa-times"></i>
                                            </span>
                                        </button>
                                        <button class="button is-white" type="button" v-bind:disabled="user === null"
                                            @click="talk" v-else key="suggest">
                                            <span class="icon is-small">
                                                <i class="fas fa-comment"></i>
                                            </span>
                                        </button>
                                    </transition>
                                </div>
                            </div>
                            <div class="columns">
                                <div class="column is-half is-mobile has-content-centered">
                                    <div class="control has-text-centered">
                                        <nav class="level">
                                            <div class="level-item has-text-centered">
                                                <div class="field" ref="ticker">
                                                    <div class="clip">
                                                        <div class="ticker-wrap">
                                                            <transition-group name="ticker-item-list" class="ticker"
                                                                tag="div"
                                                                v-bind:style="{ animationPlayState: 'running' }">
                                                                <div class="item" v-for="message in messages"
                                                                    v-bind:key="message.id">
                                                                    <div class="is-size-7 has-text-weight-bold has-text-white"
                                                                        v-cloak>{{ message.text }}</div>
                                                                </div>
                                                                <div class="item" v-for="message in messages"
                                                                    v-bind:key="message.id">
                                                                    <div class="is-size-7 has-text-weight-bold has-text-white"
                                                                        v-cloak>{{ message.text }}</div>
                                                                </div>
                                                            </transition-group>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </nav>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="columns">
                        <div class="column is-half is-mobile">
                            <div class="control has-text-centered">
                                <transition name="reveal">
                                    <!--<nav class="level">
                                        <div class="level-item has-text-centered">
                                            <div class="field is-grouped is-vcentered">
                                                <span class="icon is-small">
                                                    <i class="fas fa-star"></i>
                                                </span>
                                                <span class="title is-size-4"
                                                    v-bind:class="{'is-invisible': words === -1}">{{ likes }}</span>
                                            </div>
                                        </div>
                                    </nav>
                                    <nav class="level">
                                        <div class="level-item has-text-centered">
                                            <div class="field">
                                                <h6 class="subtitle is-size-6 is-uppercase has-text-weight-bold">いいね
                                                </h6>
                                            </div>
                                        </div>
                                    </nav>-->
                                    <nav class="level" v-if="isRevealed" v-cloak>
                                        <transition name="fade" mode="out-in">
                                            <div class="level-item" v-if="isUpdating" key="updating">
                                                <span class="has-text-black">
                                                    <i class="fas fa-spinner updating"></i>
                                                </span>
                                            </div>
                                            <div class="level-item" v-else key="updated">
                                                <!--<div class="tags are-normal field is-grouped is-grouped-multiline is-hidden">
                                                <div class="control">
                                                    <div class="tags has-addons">
                                                        <span class="tag is-white"><a class="has-text-black"
                                                                href="https://www.microsoft.com/store/apps/9WZDNCRDT09Q">Apricot</a></span>
                                                        <span class="tag is-black">Windows</span>
                                                    </div>
                                                </div>
                                                <div class="control">
                                                    <div class="tags has-addons">
                                                        <span class="tag is-white"><a class="has-text-black"
                                                                href="https://clock.milchchan.com/">Clock</a></span>
                                                        <span class="tag is-black">Web</span>
                                                    </div>
                                                </div>
                                                <div class="control">
                                                    <div class="tags has-addons">
                                                        <span class="tag is-white"><a class="has-text-black"
                                                                href="https://apps.apple.com/jp/app/id1130755997">Wonderland</a></span>
                                                        <span class="tag is-black">iOS</span>
                                                    </div>
                                                </div>
                                            </div>-->
                                                <div class="tags are-medium field is-grouped is-grouped-multiline">
                                                    <div class="control" v-for="tag in tags" v-bind:key="tag.index">
                                                        <div class="tags has-addons">
                                                            <button class="button tag is-rounded is-size-7 has-text-weight-bold"
                                                                type="button"
                                                                v-bind:style="{ color: 'rgba(0, 0, 0, ' + (0.25 + 0.75 * tag.score) + ')' }"
                                                                @click="learn(tag.name); isRevealed = false;">{{ tag.name }}</button>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </transition>
                                    </nav>
                                    <!--<nav class="level">
                                        <div class="level-item">
                                            <span class="has-text-black">
                                                <button class="button is-white is-rounded"
                                                    v-bind:class="{'is-selected': isOverlayed, 'is-info': isOverlayed}"
                                                    @click="isOverlayed = !isOverlayed"><span class="icon is-small">
                                                        <i class="fas fa-comments"></i>
                                                    </span></button>
                                            </span>
                                        </div>
                                    </nav>-->
                                </transition>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </nav>
        <div id="container" ref="container">
            <transition name="fade">
                <div class="columns is-desktop" v-show="isPrompted">
                    <div class="column is-half has-content-centered">
                        <article class="media">
                            <div class="media-content">
                                <div class="content">
                                    <div class="columns is-mobile is-gapless" v-for="row in arrange(attributes, 2)"
                                        v-cloak>
                                        <div class="column is-half" v-for="column in row" v-bind:key="column.name"
                                            v-cloak>
                                            <div class="field">
                                                <label class="checkbox">
                                                    <input type="checkbox" @change="check" v-model="column.value">
                                                    <span class="custom"></span>
                                                    <span
                                                        class="title is-size-6 has-text-weight-bold has-text-black">{{ column.name }}</span>
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <nav class="level">
                                    <div class="level-item">
                                        <button class="button is-white" type="button" @click="isPrompted = false"
                                            v-cloak>
                                            <span class="icon is-small">
                                                <i class="fas fa-times"></i>
                                            </span>
                                        </button>
                                    </div>
                                </nav>
                            </div>
                        </article>
                    </div>
                </div>
            </transition>
        </div>
        <!--
        <transition name="collapse">
            <transition-group id="container" name="message-list" tag="div" v-show="isOverlayed && !isSuggested">
                <div class="columns is-desktop is-invisible" v-for="message in messages" v-bind:key="message.id">
                    <div class="column is-half has-content-centered">
                        <hr class="is-invisible">
                        <article class="media" v-if="user.uid === message.user.id" v-cloak>
                            <div class="media-content">
                                <div class="content has-text-right">
                                    <div class="balloon" v-bind:style="{ color: message.user.accent }">
                                        <p class="has-text-weight-bold">
                                            {{ message.text }}
                                        </p>
                                    </div>
                                    <div>
                                        <p class="is-size-7 has-text-weight-normal has-text-grey">
                                            {{ formatDate(message.timestamp) }}
                                        </p>
                                    </div>
                                </div>
                            </div>
                            <figure class="media-right" v-if="message.user.image">
                                <p class="image is-64x64">
                                    <img class="is-rounded" v-bind:src="message.user.image"
                                        v-bind:alt="message.user.name ? message.user.name : message.id">
                                </p>
                            </figure>
                        </article>
                        <article class="media" v-else v-cloak>
                            <figure class="media-left" v-if="message.user.image">
                                <p class="image is-64x64">
                                    <img class="is-rounded" v-bind:src="message.user.image"
                                        v-bind:alt="message.user.name ? message.user.name : message.id">
                                </p>
                            </figure>
                            <div class="media-content">
                                <div class="content has-text-left">
                                    <div class="balloon" v-bind:style="{ color: message.user.accent }">
                                        <p class="has-text-weight-bold">
                                            <span v-bind:class="{'is-hidden': message.text}">
                                                <i class="fas fa-spinner updating"></i>
                                            </span>
                                            {{ message.text }}
                                        </p>
                                    </div>
                                    <div>
                                        <p class="is-size-7 has-text-weight-normal has-text-grey">
                                            {{ formatDate(message.timestamp) }}</p>
                                    </div>
                                </div>
                            </div>
                        </article>
                    </div>
                </div>
            </transition-group>
        </transition>-->
        <transition name="popup" v-on:before-enter="animationStart" v-on:after-enter="animationEnd"
            v-on:enter-cancelled="animationEnd" v-on:before-leave="animationStart" v-on:after-leave="animationEnd"
            v-on:leave-cancelled="animationEnd">
            <nav id="popup" class="navbar is-fixed-bottom" v-show="isPopup" v-cloak>
                <div class=" navbar-item is-expanded columns is-desktop">
                    <div class="column is-half has-content-centered is-mobile">
                        <div class="control">
                            <nav class="level">
                                <article class="media">
                                    <figure class="media-left">
                                        <span class="image is-32x32">
                                            <img class="is-rounded" src="/images/Milch.png" alt="ミルヒちゃん">
                                        </span>
                                    </figure>
                                    <div class="media-content">
                                        <div class="content has-text-left">
                                            <span class="is-size-6 has-text-weight-bold has-text-white">
                                                ミルヒちゃん
                                            </span>
                                        </div>
                                    </div>
                                </article>
                            </nav>
                            <nav class="level">
                                <article class="media">
                                    <div class="media-content"
                                        v-bind:style="{ height: animatedPopupTextHeight + 'px' }">
                                        <div class="content has-text-left" ref="popupText">
                                            <span class="title is-4 has-text-weight-bold has-text-white"
                                                v-for="character in text" v-bind:key="character.key"
                                                v-cloak>{{ character.value }}</span>
                                        </div>
                                    </div>
                                </article>
                            </nav>
                        </div>
                    </div>
                </div>
            </nav>
        </transition>
        <transition name="collapse">
            <nav id="input" class="navbar is-fixed-bottom" role="navigation" v-show="isOverlayed && !isSuggested">
                <div class=" navbar-item is-expanded columns is-desktop">
                    <div class="column is-half has-content-centered is-mobile">
                        <transition-group name="notification-list" class="control" tag="div">
                            <nav class="level" v-for="notification in notifications" v-bind:key="notification.id">
                                <div class="notification is-info is-light" v-cloak>
                                    <article class="media" v-bind:style="{ backgroundColor: notification.accent }">
                                        <figure class="media-left" v-if="notification.image" v-cloak>
                                            <span class="image is-32x32">
                                                <img class="is-rounded" v-bind:src="notification.image" alt="Avatar">
                                            </span>
                                        </figure>
                                        <div class="media-content">
                                            <div class="content has-text-left">
                                                <span class="has-text-weight-bold has-text-white" v-cloak>
                                                    {{ notification.text }}
                                                </span>
                                            </div>
                                        </div>
                                    </article>
                                </div>
                            </nav>
                        </transition-group>
                        <div class="control">
                            <transition name="fade">
                                <nav class="level" v-show="isExpanded">
                                    <div class="level-left">
                                        <div class="level-item">
                                            <div class="field">
                                                <label class="checkbox" v-cloak>
                                                    <input type="radio" name="mode" checked="checked"
                                                        @change="isLearning = false; isExpanded = false;">
                                                    <span class="custom"></span>
                                                    <span
                                                        class="title is-size-6 has-text-weight-bold has-text-black">出来事を投稿</span>
                                                </label>
                                            </div>
                                        </div>
                                        <div class="level-item">
                                            <div class="field">
                                                <label class="checkbox" v-cloak>
                                                    <input type="radio" name="mode"
                                                        @change="isLearning = true; isExpanded = false;">
                                                    <span class="custom"></span>
                                                    <span
                                                        class="title is-size-6 has-text-weight-bold has-text-black">言葉を教える</span>
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                </nav>
                            </transition>
                            <nav class="level" ref="input">
                                <form onsubmit="return false;">
                                    <div class="field has-addons">
                                        <div class="control">
                                            <transition name="fade" mode="out-in">
                                                <button class="button is-rounded" type="button"
                                                    v-bind:disabled="user === null" @click="isExpanded = false"
                                                    v-if="isExpanded" key="unexpand" v-cloak>
                                                    <span class="icon is-small is-black">
                                                        <i class="fas fa-angle-down"></i>
                                                    </span>
                                                </button>
                                                <button class="button is-white" type="button"
                                                    v-bind:disabled="user === null" @click="isExpanded = true" v-else
                                                    key="expand" v-cloak>
                                                    <span class="icon is-small">
                                                        <i class="fas fa-angle-up"></i>
                                                    </span>
                                                </button>
                                            </transition>
                                        </div>
                                        <div class="control is-expanded">
                                            <input class="input is-rounded" type="text"
                                                v-bind:class="{'is-danger': inputHasError}" v-model="input"
                                                @input="change" v-cloak>
                                        </div>
                                        <div class="control">
                                            <span class="is-size-7 has-text-weight-bold has-text-grey" v-cloak>
                                                {{ maxInputLength - animatedCurrentInputLength }}
                                            </span>
                                        </div>
                                        <div class="control">
                                            <button class="button is-rounded is-primary" type="submit"
                                                v-bind:class="{'is-loading': isLoading, 'is-static': isPrompted}"
                                                v-bind:disabled="user === null" @click="send"><span
                                                    class="icon is-small" v-cloak>
                                                    <i class="fas fa-paper-plane"></i>
                                                </span>
                                            </button>
                                        </div>
                                    </div>
                                </form>
                            </nav>
                        </div>
                    </div>
                </div>
            </nav>
        </transition>
        <audio id="alert" preload="auto">
            <source src="/sounds/plastic_hi.mp3" type="audio/mpeg" />
            <source src="/sounds/plastic_hi.m4a" type="audio/mp4" />
            <source src="/sounds/plastic_hi.wav" type="audio/wav" />
        </audio>
        <audio id="twinkle" preload="auto">
            <source src="/sounds/plastic_up_hi.mp3" type="audio/mpeg" />
            <source src="/sounds/plastic_up_hi.m4a" type="audio/mp4" />
            <source src="/sounds/plastic_up_hi.wav" type="audio/wav" />
        </audio>
    </div>
    <!-- The core Firebase JS SDK is always required and must be listed first -->
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-database.js"></script>
    <!-- TODO: Add SDKs for Firebase products that you want to use
     https://firebase.google.com/docs/web/setup#available-libraries -->
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-analytics.js"></script>
    <script src="https://unpkg.com/three@0.121.1/build/three.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats-js@1.0.1/build/stats.min.js"></script>
    <script src="https://unpkg.com/vue@next"></script>
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
    <script src="/js/moment-with-locales.js"></script>
    <script src="/js/three-vrm.js"></script>
    <script src="/js/particles.js"></script>
    <script src="/js/tiny-segmenter.js"></script>
    <script type="module">
        import { GLTFLoader } from 'https://unpkg.com/three@0.121.1/examples/jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';

        // Your web app's Firebase configuration
        var firebaseConfig = {
            apiKey: "AIzaSyDTVxDJj7rqG9L-Clvba2Tao9B0hkcxjcE",
            authDomain: "milchchan.firebaseapp.com",
            databaseURL: "https://milchchan.firebaseio.com",
            projectId: "milchchan",
            storageBucket: "milchchan.appspot.com",
            messagingSenderId: "355698971889",
            appId: "1:355698971889:web:e3653c5c31bd7289cd4550",
            measurementId: "G-3998FJYNWX"
        };
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        firebase.analytics();

        const debug = getParameterByName("debug") || false;
        const channel = decodeURIComponent(window.location.hash.substring(1));
        const databaseRoot = 'bot';
        const databaseChannel = channel.length > 0 ? databaseRoot + '/channels/' + channel : databaseRoot;
        const databaseMessages = databaseChannel + '/statuses';
        let database = firebase.database();
        const milch = { name: 'ミルヒちゃん', accent: '#ffa6bb', image: '/images/Milch.png' };
        const merku = { name: 'メルクちゃん', accent: '#5bcbe1', image: '/images/Merku.png' };

        //databaseRoot.remove();

        /*databaseRoot.remove().orderByChild('timestamp')
            .startAt(1).limitToFirst(2)
            .once('value', function (snapshot) { console.log(snapshot.val()) })*/

        function random(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);

            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function getParameterByName(name) {
            name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");

            var regex = new RegExp("[\\?&]" + name + "=([^&#]*)");
            var results = regex.exec(window.location.href);

            if (results == null) {
                return null;
            }

            return decodeURIComponent(results[1].replace(/\+/g, " "));
        }

        document.title = channel.length === 0 ? 'ミルヒちゃんねる' : '#' + channel;

        //var channel = getParameterByName("channel") || getParameterByName("ch") || "";

        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });

        renderer.setSize(window.innerWidth, window.outerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0xffffff, 0);

        if (channel.length > 0) {
            renderer.domElement.classList.add("is-hidden");
        }

        const CAMERA_FOV = 60.0;
        const CAMERA_Z = -1.0;
        const camera = new THREE.PerspectiveCamera(CAMERA_FOV, window.innerWidth / window.outerHeight, 0.1, 1000);

        camera.position.set(0.0, 1.25, CAMERA_Z);

        const controls = new OrbitControls(camera, renderer.domElement);

        controls.enableKeys = false;
        controls.screenSpacePanning = true;
        controls.target.set(0.0, 0.95, 0.025);
        controls.update();

        const scene = new THREE.Scene();
        const light = new THREE.DirectionalLight(0xffffff);

        light.intensity = 1;
        light.position.set(0.0, 10.0, -10.0).normalize();

        scene.add(light);
        //scene.add(new THREE.GridHelper(10, 10));
        //scene.add(new THREE.AxesHelper(5));

        const lookAtTarget = new THREE.Object3D();

        camera.add(lookAtTarget);

        const stats = new Stats();

        stats.domElement.style.position = "fixed";
        stats.domElement.style.top = "0px";

        if (!debug) {
            stats.domElement.classList.add("is-hidden");
        }

        //document.body.appendChild(stats.domElement);
        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let animationIndex = 0;
        const animationSkipFrames = 2;
        let idleTime = 0.0;
        const blinkThreshold = 5.0;
        let waitTime = 0.0;
        const waitThreshold = 1.0;
        let activateTime = 0.0;
        const activateThreshold = 10.0;
        let lookAnimation = null;
        let timeoutID = undefined;

        var app = Vue.createApp({
            data() {
                return {
                    isReady: false,
                    isLoading: false,
                    isRevealed: false,
                    isUpdating: false,
                    isBlinded: false,
                    isOverlayed: true,
                    isSuggested: false,
                    isPopup: false,
                    isExpanded: false,
                    isLearning: false,
                    isPrompted: false,
                    isAnimating: false,
                    suggestionQueue: [],
                    sequenceQueue: [],
                    progress: 0,
                    user: null,
                    input: '',
                    currentInputLength: 0,
                    animatedCurrentInputLength: 0,
                    maxInputLength: 100,
                    inputHasError: false,
                    messages: [],
                    maxMessages: 10,
                    tags: [],
                    maxTags: 10,
                    scrollTimeoutID: undefined,
                    isScrolling: false,
                    words: 0,
                    animatedWords: 0,
                    likes: -1,
                    stars: -1,
                    animatedStars: 0,
                    hints: [],
                    notifications: [],
                    presetImages: null,
                    backgroundImages: [],
                    preloadImages: [],
                    vrm: null,
                    animations: null,
                    animationsQueue: [],
                    currentAnimations: [],
                    blendShapeAnimations: [],
                    blendShapeAnimationQueue: [],
                    highlight: null,
                    cover: null,
                    isPreloading: false,
                    isComputing: false,
                    text: [],
                    popupTextHeight: 0,
                    animatedPopupTextHeight: 0,
                    message: null,
                    states: {},
                    character: null,
                    attributes: [{ name: "名前", value: false },
                    { name: "所属", value: false },
                    { name: "時間", value: false },
                    { name: "場所", value: false },
                    { name: "する事", value: false },
                    { name: "生き物", value: false },
                    { name: "食べ物", value: false },
                    { name: "飲み物", value: false },
                    { name: "聞くもの", value: false },
                    { name: "見るもの", value: false },
                    { name: "読むもの", value: false },
                    { name: "使う物", value: false },
                    { name: "乗り物", value: false },
                    { name: "部位", value: false },
                    { name: "病気", value: false }]
                }
            },
            watch: {
                messages: {
                    handler: () => {
                        app.$nextTick(() => {
                            let width = 0;

                            for (const element of document.body.querySelectorAll("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker .item")) {
                                width += element.getBoundingClientRect().width;
                            }

                            document.body.querySelector("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker").style.width = width + 'px';

                            //width += document.body.querySelector("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .clip").getBoundingClientRect().width;

                            document.body.querySelector("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker").animate([
                                {
                                    transform: "translate3d(0, 0, 0)"
                                },
                                {
                                    transform: "translate3d(-" + width / 2 + "px, 0, 0)"
                                }
                            ], {
                                duration: 30000,
                                iterations: Infinity
                            });

                            //app.scrollToEnd();
                        });
                    },
                    deep: true
                },
                backgroundImages: {
                    handler: () => {
                        app.$nextTick(() => {
                            const elements = document.body.querySelectorAll("#app>.background>div");
                            const offset = elements.length - 1;
                            const frameRate = 15;

                            for (const element of elements) {
                                element.animate([
                                    {
                                        transform: "translate3d(0, 0, 0)"
                                    },
                                    {
                                        transform: "translate3d(-" + offset * 100 + "%, 0, 0)"
                                    }
                                ], {
                                    fill: 'forwards',
                                    easing: 'steps(' + offset + ')',
                                    duration: 1000 / frameRate * elements.length,
                                    iterations: Infinity
                                });
                            }
                        });
                    },
                    deep: true
                },
                text: {
                    handler: () => {
                        app.$nextTick(() => {
                            app.popupTextHeight = app.$refs.popupText.getBoundingClientRect().height;
                        });
                    },
                    deep: true
                },
                popupTextHeight(newValue) {
                    const obj = { height: this.animatedPopupTextHeight };

                    anime({
                        targets: obj,
                        height: newValue,
                        round: 1,
                        duration: 500,
                        easing: 'linear',
                        update: () => {
                            this.animatedPopupTextHeight = obj.height
                        }
                    });
                },
                stars(newValue) {
                    const obj = { count: this.animatedStars };

                    anime({
                        targets: obj,
                        count: newValue,
                        round: 1,
                        duration: 500,
                        easing: 'linear',
                        update: () => {
                            this.animatedStars = obj.count
                        }
                    });
                },
                currentInputLength(newValue) {
                    const obj = { count: this.animatedCurrentInputLength };

                    anime({
                        targets: obj,
                        count: newValue,
                        round: 1,
                        duration: 500,
                        easing: 'linear',
                        update: () => {
                            this.animatedCurrentInputLength = obj.count
                        }
                    });
                },
                cover(newValue) {
                    if (newValue) {
                        this.isPreloading = true;
                    } else {
                        this.isPreloading = false;
                    }
                }
            },
            methods: {
                send: async function (event) {
                    if (this.input.length > 0 && this.input.length <= this.maxInputLength) {
                        if (this.isLearning) {
                            this.learn(this.input);
                        } else {
                            function format(format) {
                                var args = arguments;

                                return format.replace(/\{(\d)\}/g, function (m, c) { return args[parseInt(c) + 1] });
                            }

                            function shuffle(array) {
                                function _random(min, max) {
                                    min = Math.ceil(min);
                                    max = Math.floor(max);

                                    return Math.floor(Math.random() * (max - min)) + min;
                                }

                                let a = [].concat(array);
                                let n = array.length;

                                while (n > 1) {
                                    const k = _random(0, n);

                                    n--;

                                    const temp = a[n];

                                    a[n] = a[k];
                                    a[k] = temp;
                                }

                                return a;
                            }

                            let segmenter = new TinySegmenter();
                            let tokens = segmenter.segment(this.input).sort((x, y) => y.length - x.length);

                            database.ref(databaseMessages).push({ text: this.input, timestamp: Math.floor(new Date() / 1000), user: { id: app.user.uid, name: null, accent: null, image: null } });

                            this.input = '';
                            this.currentInputLength = 0;

                            document.body.querySelector("#alert").play();

                            if (tokens.length > 5) {
                                tokens.splice(5);
                            }

                            for (const token of shuffle(tokens)) {
                                let snapshot = await database.ref(databaseRoot + "/dictionary/words/" + token).once('value');

                                if (!snapshot.exists()) {
                                    this.learn(token);

                                    break;
                                }
                            }
                        }

                        return;

                        const url = "https://api.milchchan.com/talk?text=" + text + "&threshold=1.0";
                        //let segmenter = new TinySegmenter();
                        let regex = new RegExp('[.#$\\[\\]]');
                        //let tokens = [];

                        /*for (let token of segmenter.segment(text)) {
                            if (!regex.test(token)) {
                                tokens.push(token);
                            }
                        }*/

                        this.input = '';
                        this.currentInputLength = 0;

                        document.body.querySelector("#alert").play();

                        let completed = 0;
                        let learnedWords = [];

                        database.ref(databaseMessages).push({ text: text, timestamp: Math.floor(new Date() / 1000), user: { id: app.user.uid, name: null, accent: null, image: null } });

                        /*for (let token of tokens) {
                            database.ref(databaseRoot + "/dictionary/words/" + token).transaction(function (word) {
                                if (word === null) {
                                    return ref.key;
                                }

                                return;
                            }, function (error, committed, snapshot) {
                                if (committed) {
                                    learnedWords.push(token);

                                    database.ref(databaseRoot + "/dictionary/count").transaction(function (count) {
                                        return (count || 0) + 1;
                                    });
                                } else if (error) {
                                    console.error(error);
                                }

                                completed++;

                                if (completed == tokens.length && learnedWords.length > 0) {
                                    for (let i = 0; i < learnedWords.length; i++) {
                                        window.setTimeout(function () {
                                            app.notify({ text: format(channel.length == 0 ? '「{0}」をおぼえたよぉ' : '「{0}」をおぼえたよ', learnedWords[i]), accent: merku.accent, image: channel.length == 0 ? merku.image : null });
                                        }, (i + 1) * 500);
                                    }

                                    window.pJSDom[0].pJS.fn.modes.pushParticles(learnedWords.length);
                                }
                            });
                        }*/

                        window.setTimeout(async () => {
                            let ref = database.ref(databaseMessages).push();

                            app.messages.push({ id: ref.key, text: null, timestamp: new Date(), user: { id: null, name: milch.name, accent: milch.accent, image: milch.image } });

                            try {
                                app.isLoading = true;

                                const response = await fetch(encodeURI(url), {
                                    mode: "cors",
                                    method: "GET",
                                    headers: {
                                        "Content-Type": "application/x-www-form-urlencoded"
                                    }
                                });

                                if (response.ok) {
                                    const json = await response.json();

                                    if (json.text.length > 0) {
                                        ref.set({ text: json.text, timestamp: Math.floor(new Date() / 1000), thread: ref.key, user: { id: null, name: milch.name, accent: milch.accent, image: milch.image } });
                                    }
                                }
                                else {
                                    throw new Error(response.statusText);
                                }

                                app.isLoading = false;
                            }
                            catch (e) {
                                app.isLoading = false;
                                app.notify({ text: channel.length == 0 ? 'もう一度試してほしいよぉ' : 'もう一度試してみてね', accent: merku.accent, image: channel.length == 0 ? merku.image : null });

                                console.error(e.message);
                            }


                        }, random(500, 1000));
                    }
                },
                change: function (event) {
                    this.currentInputLength = this.input.length;

                    if (this.currentInputLength <= this.maxInputLength) {
                        this.inputHasError = false;
                    } else {
                        this.inputHasError = true;
                    }
                },
                like: function () {
                    if (this.isSuggested) {
                        if (this.suggestionQueue.length > 0) {
                            this.suggestionQueue[0].messages[0].type.reverse = true;
                            this.isBlinded = true;
                        } else {
                            this.isBlinded = false;
                        }

                        this.isSuggested = false;
                    } else {
                        this.suggestionQueue.splice(0);
                        this.isBlinded = true;
                        this.isSuggested = true;
                        document.body.querySelector("#twinkle").play();
                    }



                    return;
                    /*if (this.isLearning) {
                        this.messages.push({ id: this.messages.length, text: 'また今度教えてね', tint: merku.tint, avatar: merku.avatar, author: merku.name, timestamp: new Date() });
                        this.isLearning = false;
                    } else {
                        this.messages.push({ id: this.messages.length, text: '最初にミルヒちゃんに送るメッセージを教えて欲しいよぉ', tint: merku.tint, avatar: merku.avatar, author: merku.name, timestamp: new Date() });
                        this.isLearning = true;
                    }
                    */

                    database.ref(databaseChannel + "/likes").transaction(function (count) {
                        return (count || 0) + 1;
                    });

                    if (this.vrm && 'jump' in this.animations) {
                        this.animationsQueue.push(this.animations['jump']);
                    }

                    window.pJSDom[0].pJS.fn.modes.pushParticles(1);

                    //this.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }]);

                    /*database.ref(databaseChannel + "likes").once('value', snapshot => {
                        const count = snapshot.val();
            
                        if (count === null) {
                            database.ref(databaseChannel + "likes").update({ 'likes': 1 })
                        }
                        else {
                            database.ref(databaseChannel).update({ 'likes': count + 1 })
                        }
                    });*/

                    document.body.querySelector("#twinkle").play();
                },
                check: function (event) {
                    function format(format) {
                        var args = arguments;

                        return format.replace(/\{(\d)\}/g, function (m, c) { return args[parseInt(c) + 1] });
                    }

                    let self = this;
                    let attributes = {};
                    let checked = 0;
                    let isNew = false;
                    let ref = database.ref(databaseRoot + "/words/" + this.input);

                    for (const attribute of this.attributes) {
                        attributes[attribute.name] = attribute.value;

                        if (attribute.value) {
                            checked++;
                        }
                    }

                    if (event.target.checked && checked == 1) {
                        isNew = true;
                    }

                    attributes["timestamp"] = Math.floor(new Date() / 1000);

                    ref.transaction(function (current) {
                        return attributes;
                    }, function (error, committed, snapshot) {
                        if (committed) {
                            if (isNew) {
                                self.notify({ text: format(channel.length == 0 ? '「{0}」をおぼえたよぉ' : '「{0}」をおぼえたよ', snapshot.key), accent: merku.accent, image: channel.length == 0 ? merku.image : null });
                            }
                            //console.log(snapshot);
                            //console.log(isNew);

                            //if (isNew) {
                            /*database.ref(databaseRoot + "/dictionary/count").transaction(function (count) {
                                return (count || 0) + 1;
                            });*/
                            //}
                        } else if (error) {
                            console.error(error);
                        }
                    });

                    return;

                    if (index > 0) {

                    } else {
                        database.ref(databaseRoot + "/dictionary/words/" + this.input).transaction(function (current) {
                            return null;
                        }, function (error, committed, snapshot) {
                            if (committed) {
                                /*database.ref(databaseRoot + "/vocabularies").transaction(function (count) {
                                    if (count) {
                                        count -= 1;

                                        if (count > 0) {
                                            return count;
                                        } else {
                                            return null;
                                        }
                                    }

                                    return;
                                });*/
                            } else if (error) {
                                console.error(error);
                            }
                        });
                    }
                },
                learn: async function (term) {
                    function format(format) {
                        var args = arguments;

                        return format.replace(/\{(\d)\}/g, function (m, c) { return args[parseInt(c) + 1] });
                    }

                    for (const attribute of this.attributes) {
                        attribute.value = false;
                    }

                    const snapshot = await database.ref(databaseRoot + "/words/" + term).once('value');
                    let sequences = [];
                    let sequence = [];

                    if (snapshot.exists()) {
                        const word = snapshot.val();

                        for (const attribute of this.attributes) {
                            if (attribute.name in word) {
                                attribute.value = word[attribute.name];
                            }
                        }
                    }

                    for (const sequence of this.character.sequences) {
                        if (sequence.name == "Learn") {
                            sequences.push(sequence);
                        }
                    }

                    for (const obj of this.prepare(sequences)) {
                        if (obj.type == "Message") {
                            sequence.push({ type: obj.type, speed: obj.speed, duration: obj.duration, text: format(obj.text, term) });
                        } else {
                            sequence.push(obj);
                        }
                    }

                    if (sequence.length > 0) {
                        this.sequenceQueue.push(sequence);
                    }

                    this.isPrompted = true;
                },
                talk: async function () {
                    function generateUuid() {
                        // https://github.com/GoogleChrome/chrome-platform-analytics/blob/master/src/internal/identifier.js
                        // const FORMAT: string = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
                        let chars = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".split("");

                        for (let i = 0, len = chars.length; i < len; i++) {
                            switch (chars[i]) {
                                case "x":
                                    chars[i] = Math.floor(Math.random() * 16).toString(16);
                                    break;
                                case "y":
                                    chars[i] = (Math.floor(Math.random() * 4) + 8).toString(16);
                                    break;
                            }
                        }

                        return chars.join("");
                    }

                    let sequences = [];
                    let sequence = [];
                    let delta = 0;

                    for (const sequence of this.character.sequences) {
                        if (sequence.name == "Activate") {
                            sequences.push(sequence);
                        }
                    }

                    for (const obj of this.prepare(sequences)) {
                        if (obj.type == "Message") {
                            let text;
                            let cache;

                            [text, cache] = await this.generate(obj.text);

                            sequence.push({ type: obj.type, speed: obj.speed, duration: obj.duration, text: text });

                            for (const key in cache) {
                                if (typeof cache[key] !== "undefined") {
                                    delta++;
                                }
                            }
                        } else {
                            sequence.push(obj);
                        }
                    }

                    /*const presets = [{ animation: 'idle2', name: THREE.VRMSchema.BlendShapePresetName.Fun },
                    { animation: 'jump', name: THREE.VRMSchema.BlendShapePresetName.Joy },
                    { animation: 'win', name: THREE.VRMSchema.BlendShapePresetName.Joy },
                    { animation: 'lose', name: THREE.VRMSchema.BlendShapePresetName.Sorrow }];
                    const item = presets[random(0, 3)];*/

                    if (sequence.length > 0) {
                        this.sequenceQueue.push(sequence);
                    }

                    if (delta > 0) {
                        database.ref(databaseRoot + "/stars").transaction(function (count) {
                            return (count || 0) + delta;
                        });
                    }
                    //{ messages: [{ time: 0, duration: 5, type: { elapsed: -1, speed: 50, reverse: false, buffer: '', count: 0 }, text: generatedText }], animation: item.animation, morphs: { animations: [{ name: item.name, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }], defaults: [{ name: THREE.VRMSchema.BlendShapePresetName.Joy, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Sorrow, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Fun, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Blink, weight: 0.0 }] } });

                    /*this.messages.push({ id: generateUuid(), text: generatedText, timestamp: new Date(), user: { id: null, name: milch.name, accent: milch.accent, image: milch.image } });

                    if (this.messages.length > this.maxMessages) {
                        this.messages.shift();
                    }*/
                },
                generate: async function (message) {
                    function choice(x, probabilities) {
                        const r = Math.random();
                        let sum = 0.0;
                        let index = 0;

                        for (let probability of probabilities) {
                            if (sum <= r && r < sum + probability) {
                                break;
                            }

                            sum += probability;
                            index++;
                        }

                        return x[index];
                    }

                    function softmax(x) {
                        let y = [];
                        let max = Number.MIN_VALUE;
                        let sum = 0.0;

                        for (let i = 0; i < x.length; i++) {
                            if (x[i] > max) {
                                max = x[i];
                            }
                        }

                        for (let i = 0; i < x.length; i++) {
                            sum += Math.exp(x[i] - max);
                        }

                        for (let i = 0; i < x.length; i++) {
                            y.push(Math.exp(x[i] - max) / sum);
                        }

                        return y;
                    }

                    let segmenter = new TinySegmenter();
                    let regex = new RegExp('[.#$\\[\\]]');
                    let cachDictionary = {};
                    let text = '';
                    let epsilon = Math.pow(10, -6);

                    for (const token of segmenter.segment(message)) {
                        if (token in cachDictionary) {
                            if (typeof cachDictionary[token] === "undefined") {
                                text += token;
                            } else {
                                text += cachDictionary[token]
                            }
                        } else if (regex.test(token)) {
                            text += token;
                        } else {
                            let terms = [];
                            let scores = [];
                            const snapshot1 = await database.ref(databaseRoot + "/words/" + token).once('value');

                            if (snapshot1.exists()) {
                                const word = snapshot1.val();

                                for (let attribute in word) {
                                    if (word[attribute]) {
                                        const snapshot2 = await database.ref(databaseRoot + "/words/").orderByChild(attribute).equalTo(true).once('value');

                                        if (snapshot2.exists()) {
                                            const words = snapshot2.val();

                                            for (let key in words) {
                                                if (!terms.includes(key)) {
                                                    let isNew = true;

                                                    terms.push(key);

                                                    for (const tag of this.tags) {
                                                        if (key == tag.name) {
                                                            scores.push(tag.score);
                                                            isNew = false;

                                                            break;
                                                        }
                                                    }

                                                    if (isNew) {
                                                        scores.push(epsilon);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            if (terms.length > 0) {
                                const term = choice(terms, softmax(scores));

                                text += term;

                                if (token == term) {
                                    cachDictionary[token] = undefined;
                                } else {
                                    cachDictionary[token] = term;
                                }
                            } else {
                                text += token;
                            }
                        }
                    }

                    return [text, cachDictionary];
                },
                notify: function (data) {
                    let id = -1;

                    for (const notification of this.notifications) {
                        if (notification.id > id) {
                            id = notification.id;
                        }
                    }

                    id++;
                    data['id'] = id;

                    this.notifications.push(data);

                    window.setTimeout(async function () {
                        for (let i = 0; i < app.notifications.length; i++) {
                            if (app.notifications[i].id == id) {
                                app.notifications.splice(i, 1);

                                break;
                            }
                        }
                    }, 3000);
                },
                blinded: async function () {
                    function _random(min, max) {
                        min = Math.ceil(min);
                        max = Math.floor(max);

                        return Math.floor(Math.random() * (max - min)) + min;
                    }

                    this.preloadImages.splice(0);
                    this.backgroundImages.splice(0);

                    for (const image of this.presetImages[_random(0, this.presetImages.length)]) {
                        this.preloadImages.push({
                            url: image
                        });
                    }

                    setTimeout(() => {
                        this.isBlinded = true;
                    }, 30000);
                },
                load: function (url) {
                    let isCompleted = true;

                    for (let image of this.preloadImages) {
                        if (image.url == url) {
                            image["isLoaded"] = true;
                        } else if (!("isLoaded" in image)) {
                            isCompleted = false;
                        }
                    }

                    if (isCompleted) {
                        let index = 0;

                        for (const image of this.preloadImages) {
                            if (image.isLoaded) {
                                this.backgroundImages.push({
                                    index: index,
                                    url: image.url
                                });

                                index++;
                            }
                        }

                        this.preloadImages.splice(0);
                        this.isBlinded = false;
                    }
                },
                error: function (url) {
                    let isCompleted = true;

                    for (let image of this.preloadImages) {
                        if (image.url == url) {
                            image["isLoaded"] = true;
                        } else if (!("isLoaded" in image)) {
                            isCompleted = false;
                        }
                    }

                    if (isCompleted) {
                        for (const image of this.preloadImages) {
                            if (image.isLoaded) {
                                this.backgroundImages.push(image.url);
                            }
                        }

                        this.preloadImages.splice(0);
                        this.isBlinded = false;
                    }
                },
                update: async function (data, max) {
                    this.isUpdating = true;

                    try {
                        const results = await new Promise(resolve => {
                            let segmenter = new TinySegmenter();
                            let documents = [];
                            let filteredDocuments = [];
                            let termFrequencies = [];
                            let inverseDocumentFrequency = {};
                            const baseTime = new Date().getTime() - 12 * 60 * 60 * 1000;
                            const limit = 10;
                            let scoreDictionary = {};
                            let scores = [];
                            let maxScore = 0.0;

                            for (const key in data) {
                                const tokens = segmenter.segment(data[key].text);

                                if (tokens.length > 0) {
                                    let termSet = [];

                                    documents.push({ tokens: tokens, timestamp: data[key].timestamp });

                                    for (const token of tokens) {
                                        if (!termSet.includes(token)) {
                                            if (token in inverseDocumentFrequency) {
                                                inverseDocumentFrequency[token] += 1.0;
                                            } else {
                                                inverseDocumentFrequency[token] = 1.0;
                                            }

                                            termSet.push(token);
                                        }
                                    }
                                }
                            }

                            for (const key in inverseDocumentFrequency) {
                                inverseDocumentFrequency[key] = Math.log(documents.length / inverseDocumentFrequency[key]);
                            }

                            for (const document of documents) {
                                if (document.timestamp * 1000 > baseTime) {
                                    filteredDocuments.push(document);
                                }
                            }

                            if (filteredDocuments.length < limit) {
                                const min = Math.max(documents.length - limit, 0);

                                filteredDocuments.splice(0);

                                for (let i = documents.length - 1; i >= min; i--) {
                                    filteredDocuments.unshift(documents[i]);
                                }
                            }

                            for (const document of filteredDocuments) {
                                let tf = {};

                                for (const token of document.tokens) {
                                    if (token in tf) {
                                        tf[token] += 1.0;
                                    } else {
                                        tf[token] = 1.0;
                                    }
                                }

                                for (const key in tf) {
                                    tf[key] /= document.tokens.length;

                                    if (!(key in scoreDictionary)) {
                                        scoreDictionary[key] = 0.0;
                                    }
                                }

                                termFrequencies.push(tf);
                            }

                            for (const key in scoreDictionary) {
                                for (const termFrequency of termFrequencies) {
                                    if (key in termFrequency) {
                                        const tfidf = termFrequency[key] * inverseDocumentFrequency[key];

                                        if (tfidf > scoreDictionary[key]) {
                                            scoreDictionary[key] = tfidf;
                                        }
                                    }
                                }
                            }

                            for (const key in scoreDictionary) {
                                if (key.length > 1 && key != '...') {
                                    scores.push({ term: key, value: scoreDictionary[key] });
                                }
                            }

                            scores.sort((x, y) => y.value - x.value);

                            if (scores.length > max) {
                                scores.splice(max);
                            }

                            for (const score of scores) {
                                if (score.value > maxScore) {
                                    maxScore = score.value;
                                }
                            }

                            for (const score of scores) {
                                score.value /= maxScore;
                            }

                            scores.sort((x, y) => {
                                if (x.term > y.term) {
                                    return 1;
                                } else if (x.term < y.term) {
                                    return -1;
                                }

                                return 0;
                            });

                            resolve(scores);
                        });

                        this.tags.splice(0);

                        for (let i = 0; i < results.length; i++) {
                            this.tags.push({ index: i, name: results[i].term, score: results[i].value })
                        }
                    } catch (e) {
                        console.error(e);
                    }

                    this.isUpdating = false;
                },
                scrollToEnd: function () {
                    if (typeof this.scrollTimeoutID === 'number') {
                        clearTimeout(this.scrollTimeoutID);
                    }

                    this.scrollTimeoutID = setTimeout(function () {
                        window.scrollTo(0, document.body.scrollHeight);
                    }, 500);
                },
                formatDate: function (event) {
                    moment.locale(window.navigator.language);

                    return moment(event).format('LT');
                },
                animationStart: function (el) {
                    this.isAnimating = true;
                },
                animationEnd: function (el) {
                    if (!this.isPopup) {
                        this.message = null;
                    }

                    this.isAnimating = false;
                },
                arrange: function (collection, limit) {
                    let rows = [];
                    let columns = [];

                    for (const item of collection) {
                        if (columns.length < limit) {
                            columns.push(item);
                        } else {
                            rows.push(columns);
                            columns = [item];
                        }
                    }

                    rows.push(columns);

                    return rows;
                },
                prepare: function (sequences) {
                    let choosedSequences = [];
                    let flattenedSequence = [];

                    for (const s of sequences) {
                        if ('state' in s && s.name in this.states) {
                            let regex = new RegExp(s.state);

                            if (!regex.test(this.states[s.name])) {
                                continue;
                            }
                        }

                        choosedSequences.push(s);
                    }

                    if (choosedSequences.length > 0) {
                        let queue = [];

                        for (const s of choosedSequences[random(0, choosedSequences.length - 1)].sequence) {
                            queue.push(s);
                        }

                        while (queue.length > 0) {
                            const obj = queue.shift();

                            if (obj.type == "Sequence") {
                                if (!('sequence' in obj)) {
                                    let tracedSequences = [];
                                    let callableSequences = [];

                                    for (const s of this.character.sequences) {
                                        let sequenceStack = this.getSequenceStack(s, obj);

                                        if (sequenceStack.length > 0) {
                                            let stack = [];

                                            do {
                                                let poppedSequence = sequenceStack.pop();

                                                if (sequenceStack.length > 0) {
                                                    let tempStack = [];

                                                    for (const o of sequenceStack[sequenceStack.length - 1].sequence) {
                                                        if (o.type == "Sequence") {
                                                            if ('sequence' in o) {
                                                                let isNew = true;

                                                                for (const tempSequence of stack) {
                                                                    if (tempSequence === o) {
                                                                        isNew = false;

                                                                        break;
                                                                    }
                                                                }

                                                                if (isNew) {
                                                                    tempStack.push(o);
                                                                }
                                                            }

                                                            if (o === poppedSequence) {
                                                                break;
                                                            }
                                                        }
                                                    }

                                                    while (tempStack.length > 0) {
                                                        stack.push(tempStack.pop());
                                                    }
                                                }

                                                if ('sequence' in poppedSequence) {
                                                    let isNew = true;

                                                    for (const tempSequence of stack) {
                                                        if (tempSequence === poppedSequence) {
                                                            isNew = false;

                                                            break;
                                                        }
                                                    }

                                                    if (isNew) {
                                                        stack.Push(poppedSequence);
                                                    }
                                                }
                                            } while (sequenceStack.length > 0);

                                            while (stack.length > 0) {
                                                sequenceList.push(stack.pop());
                                            }
                                        }
                                        else {
                                            tracedSequences.push(s);
                                        }
                                    }

                                    if ('state' in obj) {
                                        this.states[obj.name] = obj.state;

                                        for (const s of tracedSequences) {
                                            if (s.name == obj.name) {
                                                let regex = new RegExp(s.state);

                                                if (!regex.test(obj.state)) {
                                                    continue;
                                                }

                                                callableSequences.push(s);
                                            }
                                        }
                                    } else {
                                        for (const s of tracedSequences) {
                                            if (s.name == obj.name) {
                                                if (s.name in this.states) {
                                                    let regex = new RegExp(s.state);

                                                    if (!regex.test(this.states[s.name])) {
                                                        continue;
                                                    }
                                                }

                                                callableSequences.push(s);
                                            }
                                        }
                                    }

                                    if (callableSequences.length > 0) {
                                        let index = 0;

                                        for (const o of callableSequences[random(0, callableSequences.length - 1)].sequence) {
                                            queue.splice(index, 0, o);
                                            index++;
                                        }
                                    }
                                }
                            } else {
                                flattenedSequence.push(obj);
                            }
                        }
                    }

                    return flattenedSequence;
                },
                getSequenceStack: function (sourceSequence, targetSequence) {
                    let sequenceStack = [];

                    sequenceStack.push(sourceSequence);

                    if (sequenceStack[sequenceStack.length - 1] !== targetSequence) {
                        for (const o in sourceSequence.sequence) {
                            if (o.type == "Sequence") {
                                let stack = this.getSequenceStack(o, targetSequence);

                                if (stack.length > 0 && stack[stack.length - 1] === targetSequence) {
                                    let tempStack = [];

                                    do {
                                        tempStack.push(stack.pop());
                                    } while (stack.length > 0);

                                    do {
                                        sequenceStack.push(tempStack.pop());
                                    } while (tempStack.length > 0);

                                    return sequenceStack;
                                }
                            }
                        }

                        sequenceStack.pop();
                    }

                    return sequenceStack;
                },
                render: function () {
                    requestAnimationFrame(this.render);

                    const deltaTime = clock.getDelta();
                    const app = this;

                    if (app.vrm) {
                        let isActive = false;
                        let isAnimating = false;
                        let isDeforming = false;
                        let messageData = null;
                        let updatedBlendShapeNames = [];

                        if (app.currentAnimations.length > 0 && animationIndex < app.currentAnimations.length) {
                            messageData = app.currentAnimations[animationIndex];
                            animationIndex += animationSkipFrames;
                            isActive = true;
                            isAnimating = true;
                        }

                        if (app.blendShapeAnimations.length == 0 && app.blendShapeAnimationQueue.length > 0) {
                            for (let blendShapeAnimation of app.blendShapeAnimationQueue.shift()) {
                                app.blendShapeAnimations.unshift(blendShapeAnimation);
                            }

                            isActive = true;
                            isDeforming = true;
                        }

                        for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                            let blendShapeAnimation = app.blendShapeAnimations[i];

                            if (!updatedBlendShapeNames.includes(blendShapeAnimation.name)) {
                                if (blendShapeAnimation.time <= blendShapeAnimation.duration) {
                                    blendShapeAnimation.time += deltaTime;

                                    if (blendShapeAnimation.time >= blendShapeAnimation.duration) {
                                        app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.end / 2 * Math.PI)));
                                        app.blendShapeAnimations.splice(i, 1);
                                    } else {
                                        app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin((blendShapeAnimation.time / blendShapeAnimation.duration * (blendShapeAnimation.end - blendShapeAnimation.start) + blendShapeAnimation.start) / 2 * Math.PI)));
                                    }

                                    isActive = true;
                                }

                                updatedBlendShapeNames.push(blendShapeAnimation.name);
                            }
                        }

                        if (app.sequenceQueue.length > 0) {
                            const sequence = app.sequenceQueue[0];

                            if (sequence[0].type == "Animation") {
                                if (!isAnimating && sequence[0].name in app.animations) {
                                    /*const skipFrames = 60 / 12;
                                    let animations = app.animations[suggestion.animation];
                                    let maxFrames = Math.min(animations.length, 60);
                                    let offset = Math.floor(Math.max(0, random(0, animations.length - maxFrames - 1)) / 2);
                                    let length = Math.round(90 / 24);
        
                                    for (let i = 0; i < maxFrames; i += skipFrames) {
                                        for (let j = 0; j < length; j++) {
                                            app.currentAnimations.push(animations[offset + i]);
                                        }
                                    }
        
                                    for (let i = app.currentAnimations.length - 1; i >= 0; i--) {
                                        app.currentAnimations.push(animations[offset + i]);
                                    }*/

                                    for (let animation of app.animations[sequence[0].name]) {
                                        app.currentAnimations.push(animation);
                                    }

                                    if (sequence.length > 1) {
                                        sequence.shift();
                                    } else {
                                        app.sequenceQueue.shift();
                                    }
                                } else if (!isDeforming) {
                                    let nameSet = [];

                                    app.blendShapeAnimations.unshift({ name: sequence[0].name, time: 0.0, duration: sequence[0].duration, start: sequence[0].start, end: sequence[0].end });
                                    sequence.shift();

                                    while (sequence.length > 0) {
                                        if (sequence[0].type != "Animation" || sequence[0].name in app.animations) {
                                            break;
                                        }

                                        app.blendShapeAnimations.unshift({ name: sequence[0].name, time: 0.0, duration: sequence[0].duration, start: sequence[0].start, end: sequence[0].end });
                                        sequence.shift();
                                    }

                                    for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                                        let blendShapeAnimation = app.blendShapeAnimations[i];

                                        if (!nameSet.includes(blendShapeAnimation.name)) {
                                            app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.start / 2 * Math.PI)));
                                            nameSet.push(blendShapeAnimation.name);
                                        }
                                    }

                                    if (sequence.length == 0) {
                                        app.sequenceQueue.shift();
                                    }
                                }
                            } else if (sequence[0].type == "Message" && app.message === null && !isAnimating && !isDeforming) {
                                app.message = { time: 0, duration: sequence[0].duration, type: { elapsed: -1, speed: sequence[0].speed, reverse: false, buffer: '', count: 0 }, text: sequence[0].text };

                                if (sequence.length > 1) {
                                    sequence.shift();
                                } else {
                                    app.sequenceQueue.shift();
                                }
                            }
                        } else if (app.suggestionQueue.length > 0) {
                            const suggestion = app.suggestionQueue[0];
                            const message = suggestion.messages[0];
                            let loopRequired = true;

                            if (message.type.reverse) {
                                if (message.type.count > 0) {
                                    message.type.elapsed += deltaTime;

                                    if (message.type.elapsed >= message.type.speed / 1000.0) {
                                        let index = message.type.count - 1;

                                        if (index < message.text.length) {
                                            let width = Math.floor(message.text.length / 2);

                                            if (message.type.buffer.length <= width) {
                                                message.type.count -= 1;
                                            }

                                            if (message.type.buffer.length > 0) {
                                                message.type.buffer = message.type.buffer.substring(message.type.buffer.length - 2, message.type.buffer.length - 1);
                                            }
                                        }

                                        message.type.elapsed = 0;
                                    }
                                } else if (app.isSuggested) {
                                    /*suggestion.time = 0;
                                    suggestion.type.elapsed = -1;
                                    suggestion.type.reverse = false;
                                    suggestion.type.buffer = '';
                                    suggestion.type.count = 0;
        
                                    if ('morphs' in suggestion) {
                                        for (let blendShapeAnimation of suggestion.morphs.animations) {
                                            blendShapeAnimation.time = 0;
                                        }
                                    }*/

                                    if (suggestion.messages.length > 1) {
                                        suggestion.messages.shift();
                                    } else {
                                        app.suggestionQueue.shift();

                                        if (app.suggestionQueue.length > 0 && 'highlight' in app.suggestionQueue[0]) {
                                            if ('text' in app.suggestionQueue[0].highlight) {
                                                app.highlight = app.suggestionQueue[0].highlight.text;
                                            } else {
                                                app.highlight = null;
                                            }

                                            if ('image' in app.suggestionQueue[0].highlight) {
                                                app.cover = app.suggestionQueue[0].highlight.image;
                                            } else {
                                                app.cover = app;
                                            }
                                        }

                                        app.isBlinded = true;
                                    }
                                } else if (app.isBlinded && !isActive) {
                                    if ('morphs' in suggestion) {
                                        for (let blendShape of suggestion.morphs.defaults) {
                                            app.vrm.blendShapeProxy.setValue(blendShape.name, Math.abs(Math.sin(blendShape.weight / 2 * Math.PI)));
                                        }
                                    }

                                    app.suggestionQueue.splice(0);
                                    app.isBlinded = false;
                                    loopRequired = false;
                                }
                            } else if (message.type.buffer.length < message.text.length) {
                                if (message.type.elapsed >= 0) {
                                    message.type.elapsed += deltaTime;
                                } else if (!isActive) {
                                    if (!app.isPreloading) {
                                        waitTime += deltaTime;
                                    }

                                    if (app.highlight === null && app.cover === null || waitTime >= waitThreshold) {
                                        message.type.elapsed = deltaTime;
                                        app.isBlinded = false;
                                        app.currentAnimations.splice(0);

                                        if ('animation' in suggestion && suggestion.animation in app.animations) {
                                            const skipFrames = 60 / 12;
                                            let animations = app.animations[suggestion.animation];
                                            let maxFrames = Math.min(animations.length, 60);
                                            let offset = Math.floor(Math.max(0, random(0, animations.length - maxFrames - 1)) / 2);
                                            let length = Math.round(90 / 24);

                                            for (let i = 0; i < maxFrames; i += skipFrames) {
                                                for (let j = 0; j < length; j++) {
                                                    app.currentAnimations.push(animations[offset + i]);
                                                }
                                            }

                                            for (let i = app.currentAnimations.length - 1; i >= 0; i--) {
                                                app.currentAnimations.push(animations[offset + i]);
                                            }
                                        }

                                        if ('morphs' in suggestion) {
                                            let nameSet = [];

                                            for (let blendShape of suggestion.morphs.defaults) {
                                                app.vrm.blendShapeProxy.setValue(blendShape.name, Math.abs(Math.sin(blendShape.weight / 2 * Math.PI)));
                                            }

                                            for (let blendShapeAnimation of suggestion.morphs.animations) {
                                                app.blendShapeAnimations.unshift(blendShapeAnimation);
                                            }

                                            for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                                                let blendShapeAnimation = app.blendShapeAnimations[i];

                                                if (!nameSet.includes(blendShapeAnimation.name)) {
                                                    app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.start / 2 * Math.PI)));
                                                    nameSet.push(blendShapeAnimation.name);
                                                }
                                            }
                                        }

                                        waitTime = 0.0;
                                    } else {
                                        loopRequired = false;
                                    }
                                }

                                if (message.type.elapsed >= message.type.speed / 1000.0) {
                                    let index = message.type.buffer.length;
                                    let width = Math.floor(message.text.length / 2);
                                    let length = message.text.length;

                                    if (message.type.count >= width) {
                                        message.type.buffer += message.text.charAt(index);
                                    }

                                    if (message.type.count < length) {
                                        message.type.count += 1;
                                    }

                                    message.type.elapsed = 0;
                                }
                            } else {
                                message.time += deltaTime;

                                if (message.time >= message.duration) {
                                    message.type.reverse = true;
                                }
                            }

                            if (message.text.length === message.type.buffer.length) {
                                const characters = message.text.split('');

                                app.text.splice(0);

                                for (let i = 0; i < characters.length; i++) {
                                    app.text.push({ key: i, value: characters[i] });
                                }
                            } else {
                                let charArray = new Array();
                                let randomBuffer = '';

                                for (let i = 0; i < message.text.length; i++) {
                                    if (charArray.indexOf(message.text.charAt(i)) == -1 && message.text.charAt(i).match(/\s/) == null) {
                                        charArray.push(message.text.charAt(i));
                                    }
                                }

                                for (let i = 0; i < message.type.count; i++) {
                                    if (charArray.length > 0) {
                                        randomBuffer += charArray[~~random(0, charArray.length - 1)];
                                    }
                                }

                                if (randomBuffer.length > message.type.buffer.length) {
                                    const characters = (message.type.buffer + randomBuffer.substring(message.type.buffer.length, randomBuffer.length)).split('');

                                    app.text.splice(0);

                                    for (let i = 0; i < characters.length; i++) {
                                        app.text.push({ key: i, value: characters[i] });
                                    }
                                } else if (app.text.length !== message.type.buffer.length) {
                                    const characters = message.type.buffer.split('');

                                    app.text.splice(0);

                                    for (let i = 0; i < characters.length; i++) {
                                        app.text.push({ key: i, value: characters[i] });
                                    }
                                }
                            }

                            if (loopRequired && messageData === null) {
                                animationIndex = 0;
                                messageData = app.currentAnimations[animationIndex];
                                animationIndex += animationSkipFrames;
                            }
                        } else {
                            if (app.isSuggested && app.suggestionQueue.length == 0 && !app.isComputing) {
                                const tempMessages1 = [].concat(app.messages);
                                const tempTags = [].concat(app.tags);

                                app.isComputing = true;

                                new Promise(resolve => {
                                    let segmenter = new TinySegmenter();
                                    const presets = [{ animation: 'idle2', name: THREE.VRMSchema.BlendShapePresetName.Fun },
                                    { animation: 'jump', name: THREE.VRMSchema.BlendShapePresetName.Joy },
                                    { animation: 'win', name: THREE.VRMSchema.BlendShapePresetName.Joy },
                                    { animation: 'lose', name: THREE.VRMSchema.BlendShapePresetName.Sorrow }];
                                    let suggestions = [];
                                    let tempMessages2 = [];
                                    let ids1 = [];
                                    let ids2 = [];

                                    for (let tag of tempTags.sort((x, y) => y.score - x.score)) {
                                        for (let message of tempMessages1.reverse()) {
                                            if (!ids1.includes(message.id) && segmenter.segment(message.text).includes(tag.name)) {
                                                let thread = null;

                                                if ('thread' in message) {
                                                    for (let m of tempMessages1) {
                                                        if (message.thread == m.id) {
                                                            thread = m;

                                                            break;
                                                        }
                                                    }
                                                }

                                                if (thread === null) {
                                                    tempMessages2.push(message);
                                                } else {
                                                    const item = presets[random(0, 3)];

                                                    suggestions.push({ highlight: { text: '今日の' + document.title, image: '/images/Cover.png' }, messages: [{ time: 0, duration: 5, type: { elapsed: -1, speed: 50, reverse: false, buffer: '', count: 0 }, text: thread.text }, { time: 0, duration: 5, type: { elapsed: 0, speed: 50, reverse: false, buffer: '', count: 0 }, text: message.text }], animation: item.animation, morphs: { animations: [{ name: item.name, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }], defaults: [{ name: THREE.VRMSchema.BlendShapePresetName.Joy, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Sorrow, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Fun, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Blink, weight: 0.0 }] } });

                                                    if (!ids2.includes(thread.id)) {
                                                        ids2.push(thread.id);
                                                    }
                                                }

                                                ids1.push(message.id);
                                            }
                                        }
                                    }

                                    for (const message of tempMessages2) {
                                        if (!ids2.includes(message.id)) {
                                            const item = presets[random(0, 3)];

                                            suggestions.push({ highlight: { text: '今日の' + document.title, image: '/images/Cover.png' }, messages: [{ time: 0, duration: 5, type: { elapsed: -1, speed: 50, reverse: false, buffer: '', count: 0 }, text: message.text }], animation: item.animation, morphs: { animations: [{ name: item.name, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }], defaults: [{ name: THREE.VRMSchema.BlendShapePresetName.Joy, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Sorrow, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Fun, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Blink, weight: 0.0 }] } });
                                        }
                                    }

                                    resolve(suggestions);
                                }).then((result) => {
                                    if (app.isSuggested && result.length > 0) {
                                        for (const suggestion of result) {
                                            app.suggestionQueue.push(suggestion);
                                        }

                                        if ('highlight' in app.suggestionQueue[0]) {
                                            if ('text' in app.suggestionQueue[0].highlight) {
                                                app.highlight = app.suggestionQueue[0].highlight.text;
                                            } else {
                                                app.highlight = null;
                                            }

                                            if ('image' in app.suggestionQueue[0].highlight) {
                                                app.cover = app.suggestionQueue[0].highlight.image;
                                            } else {
                                                app.cover = null;
                                            }
                                        }
                                    }

                                    app.isComputing = false;
                                });
                            }

                            if (messageData === null) {
                                app.currentAnimations.splice(0);

                                if (app.animationsQueue.length > 0) {
                                    for (let animation of app.animationsQueue.shift()) {
                                        app.currentAnimations.push(animation);
                                    }

                                    idleTime = 0.0;
                                    activateTime = 0.0;
                                } else {
                                    const idles = ['idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle2'];
                                    const idle = idles[random(0, 14)];

                                    if (idle in app.animations) {
                                        for (let animation of app.animations[idle]) {
                                            app.currentAnimations.push(animation);
                                        }
                                    }

                                    if (app.blendShapeAnimationQueue.length > 0) {
                                        idleTime = 0.0;
                                        activateTime = 0.0;
                                    } else {
                                        idleTime += deltaTime;
                                        activateTime += deltaTime;

                                        if (activateTime >= activateThreshold) {
                                            //app.talk();

                                            idleTime = 0.0;
                                            activateTime = 0.0;
                                        } else if (idleTime >= blinkThreshold) {
                                            const durations = [0.5, 1.0];
                                            const ends = [2.0, 4.0];
                                            const index = random(0, 1);
                                            const duration = durations[index];
                                            const end = ends[index];
                                            let nameSet = [];

                                            for (let blendShapeAnimation of [{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: duration, start: 0.0, end: end }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: duration, start: 0.0, end: end }]) {
                                                app.blendShapeAnimations.unshift(blendShapeAnimation);
                                            }

                                            for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                                                let blendShapeAnimation = app.blendShapeAnimations[i];

                                                if (!nameSet.includes(blendShapeAnimation.name)) {
                                                    app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.start / 2 * Math.PI)));
                                                    nameSet.push(blendShapeAnimation.name);
                                                }
                                            }

                                            idleTime = 0.0;
                                        }
                                    }
                                }

                                animationIndex = 0;
                                messageData = app.currentAnimations[animationIndex];
                                animationIndex += animationSkipFrames;
                            } else if (app.blendShapeAnimationQueue.length > 0) {
                                idleTime = 0.0;
                                activateTime = 0.0;
                            } else {
                                idleTime += deltaTime;
                                activateTime += deltaTime;

                                if (activateTime >= activateThreshold) {
                                    if (app.sequenceQueue.length == 0) {
                                        //app.talk();
                                    }

                                    idleTime = 0.0;
                                    activateTime = 0.0;
                                } else if (idleTime >= blinkThreshold) {
                                    const durations = [0.5, 1.0];
                                    const ends = [2.0, 4.0];
                                    const index = random(0, 1);
                                    const duration = durations[index];
                                    const end = ends[index];
                                    let nameSet = [];

                                    for (let blendShapeAnimation of [{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: duration, start: 0.0, end: end }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: duration, start: 0.0, end: end }]) {
                                        app.blendShapeAnimations.unshift(blendShapeAnimation);
                                    }

                                    for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                                        let blendShapeAnimation = app.blendShapeAnimations[i];

                                        if (!nameSet.includes(blendShapeAnimation.name)) {
                                            app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.start / 2 * Math.PI)));
                                            nameSet.push(blendShapeAnimation.name);
                                        }
                                    }

                                    idleTime = 0.0;
                                }
                            }
                        }

                        if (app.message !== null) {
                            if (app.message.type.reverse) {
                                if (app.message.type.count > 0) {
                                    app.message.type.elapsed += deltaTime;

                                    if (app.message.type.elapsed >= app.message.type.speed / 1000.0) {
                                        let index = app.message.type.count - 1;

                                        if (index < app.message.text.length) {
                                            let width = Math.floor(app.message.text.length / 2);

                                            if (app.message.type.buffer.length <= width) {
                                                app.message.type.count -= 1;
                                            }

                                            if (app.message.type.buffer.length > 0) {
                                                app.message.type.buffer = app.message.type.buffer.substring(app.message.type.buffer.length - 2, app.message.type.buffer.length - 1);
                                            }
                                        }

                                        app.message.type.elapsed = 0;
                                    }
                                } else {
                                    /*if (suggestion.messages.length > 1) {
                                        suggestion.messages.shift();
                                    } else {
                                        if ('morphs' in suggestion) {
                                            for (let blendShape of suggestion.morphs.defaults) {
                                                app.vrm.blendShapeProxy.setValue(blendShape.name, Math.abs(Math.sin(blendShape.weight / 2 * Math.PI)));
                                            }
                                        }
        
        
                                    }*/

                                    app.isPopup = false;
                                }
                            } else if (app.message.type.buffer.length < app.message.text.length) {
                                if (app.message.type.elapsed >= 0) {
                                    app.message.type.elapsed += deltaTime;
                                } else if (!app.isAnimating) {
                                    if (app.isPopup) {
                                        app.message.type.elapsed = deltaTime;
                                        //app.isBlinded = false;
                                        //app.currentAnimations.splice(0);

                                        /*if ('animation' in suggestion && suggestion.animation in app.animations) {
                                            const skipFrames = 60 / 12;
                                            let animations = app.animations[suggestion.animation];
                                            let maxFrames = Math.min(animations.length, 60);
                                            let offset = Math.floor(Math.max(0, random(0, animations.length - maxFrames - 1)) / 2);
                                            let length = Math.round(90 / 24);
        
                                            for (let i = 0; i < maxFrames; i += skipFrames) {
                                                for (let j = 0; j < length; j++) {
                                                    app.currentAnimations.push(animations[offset + i]);
                                                }
                                            }
        
                                            for (let i = app.currentAnimations.length - 1; i >= 0; i--) {
                                                app.currentAnimations.push(animations[offset + i]);
                                            }
                                        }
        
                                        if ('morphs' in suggestion) {
                                            let nameSet = [];
        
                                            for (let blendShape of suggestion.morphs.defaults) {
                                                app.vrm.blendShapeProxy.setValue(blendShape.name, Math.abs(Math.sin(blendShape.weight / 2 * Math.PI)));
                                            }
        
                                            for (let blendShapeAnimation of suggestion.morphs.animations) {
                                                app.blendShapeAnimations.unshift(blendShapeAnimation);
                                            }
        
                                            for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                                                let blendShapeAnimation = app.blendShapeAnimations[i];
        
                                                if (!nameSet.includes(blendShapeAnimation.name)) {
                                                    app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.start / 2 * Math.PI)));
                                                    nameSet.push(blendShapeAnimation.name);
                                                }
                                            }
                                        }*/
                                    } else {
                                        app.isPopup = true;
                                    }
                                }

                                if (app.message.type.elapsed >= app.message.type.speed / 1000.0) {
                                    let index = app.message.type.buffer.length;
                                    let width = Math.floor(app.message.text.length / 2);
                                    let length = app.message.text.length;

                                    if (app.message.type.count >= width) {
                                        app.message.type.buffer += app.message.text.charAt(index);
                                    }

                                    if (app.message.type.count < length) {
                                        app.message.type.count += 1;
                                    }

                                    app.message.type.elapsed = 0;
                                }
                            } else {
                                app.message.time += deltaTime;

                                if (app.message.time >= app.message.duration) {
                                    app.message.type.reverse = true;
                                }
                            }

                            if (app.message.text.length === app.message.type.buffer.length) {
                                const characters = app.message.text.split('');

                                app.text.splice(0);

                                for (let i = 0; i < characters.length; i++) {
                                    app.text.push({ key: i, value: characters[i] });
                                }
                            } else {
                                let charArray = new Array();
                                let randomBuffer = '';

                                for (let i = 0; i < app.message.text.length; i++) {
                                    if (charArray.indexOf(app.message.text.charAt(i)) == -1 && app.message.text.charAt(i).match(/\s/) == null) {
                                        charArray.push(app.message.text.charAt(i));
                                    }
                                }

                                for (let i = 0; i < app.message.type.count; i++) {
                                    if (charArray.length > 0) {
                                        randomBuffer += charArray[~~random(0, charArray.length - 1)];
                                    }
                                }

                                if (randomBuffer.length > app.message.type.buffer.length) {
                                    const characters = (app.message.type.buffer + randomBuffer.substring(app.message.type.buffer.length, randomBuffer.length)).split('');

                                    app.text.splice(0);

                                    for (let i = 0; i < characters.length; i++) {
                                        app.text.push({ key: i, value: characters[i] });
                                    }
                                } else if (app.text.length !== app.message.type.buffer.length) {
                                    const characters = app.message.type.buffer.split('');

                                    app.text.splice(0);

                                    for (let i = 0; i < characters.length; i++) {
                                        app.text.push({ key: i, value: characters[i] });
                                    }
                                }
                            }
                        }

                        if (lookAnimation !== null) {
                            lookAnimation.time += deltaTime;

                            if (lookAnimation.time >= lookAnimation.duration) {
                                lookAtTarget.position.x = lookAnimation.target.x;
                                lookAtTarget.position.y = lookAnimation.target.y;
                                lookAnimation = null;
                            } else {
                                const rate = lookAnimation.time / lookAnimation.duration;

                                lookAtTarget.position.x = lookAnimation.source.x + (lookAnimation.target.x - lookAnimation.source.x) * rate;
                                lookAtTarget.position.y = lookAnimation.source.y + (lookAnimation.target.y - lookAnimation.source.y) * rate;
                            }
                        }

                        if (messageData) {
                            for (let animation of messageData.animations) {
                                switch (animation.bone) {
                                    case 'chest':
                                    case 'head':
                                    case 'hips':
                                    case 'jaw':
                                    case 'leftEye':
                                    case 'leftFoot':
                                    case 'leftHand':
                                    case 'leftIndexDistal':
                                    case 'leftIndexIntermediate':
                                    case 'leftIndexProximal':
                                    case 'leftLittleDistal':
                                    case 'leftLittleIntermediate':
                                    case 'leftLittleProximal':
                                    case 'leftLowerArm':
                                    case 'leftLowerLeg':
                                    case 'leftMiddleDistal':
                                    case 'leftMiddleIntermediate':
                                    case 'leftMiddleProximal':
                                    case 'leftRingDistal':
                                    case 'leftRingIntermediate':
                                    case 'leftRingProximal':
                                    case 'leftShoulder':
                                    case 'leftThumbDistal':
                                    case 'leftThumbIntermediate':
                                    case 'leftThumbProximal':
                                    case 'leftToes':
                                    case 'leftUpperArm':
                                    case 'leftUpperLeg':
                                    case 'neck':
                                    case 'rightEye':
                                    case 'rightFoot':
                                    case 'rightHand':
                                    case 'rightIndexDistal':
                                    case 'rightIndexIntermediate':
                                    case 'rightIndexProximal':
                                    case 'rightLittleDistal':
                                    case 'rightLittleIntermediate':
                                    case 'rightLittleProximal':
                                    case 'rightLowerArm':
                                    case 'rightLowerLeg':
                                    case 'rightMiddleDistal':
                                    case 'rightMiddleIntermediate':
                                    case 'rightMiddleProximal':
                                    case 'rightRingDistal':
                                    case 'rightRingIntermediate':
                                    case 'rightRingProximal':
                                    case 'rightShoulder':
                                    case 'rightThumbDistal':
                                    case 'rightThumbIntermediate':
                                    case 'rightThumbProximal':
                                    case 'rightToes':
                                    case 'rightUpperArm':
                                    case 'rightUpperLeg':
                                    case 'spine':
                                    case 'upperChest':
                                        break;
                                    case 'eye.L':
                                        animation.bone = 'leftEye';
                                        break;
                                    case 'foot.L':
                                        animation.bone = 'leftFoot';
                                        break;
                                    case 'hand.L':
                                        animation.bone = 'leftHand';
                                        break;
                                    case 'f_index.03.L':
                                        animation.bone = 'leftIndexDistal';
                                        break;
                                    case 'f_index.02.L':
                                        animation.bone = 'leftIndexIntermediate';
                                        break;
                                    case 'f_index.01.L':
                                        animation.bone = 'leftIndexProximal';
                                        break;
                                    case 'f_pinky.03.L':
                                        animation.bone = 'leftLittleDistal';
                                        break;
                                    case 'f_pinky.02.L':
                                        animation.bone = 'leftLittleIntermediate';
                                        break;
                                    case 'f_pinky.01.L':
                                        animation.bone = 'leftLittleProximal';
                                        break;
                                    case 'lower_arm.L':
                                        animation.bone = 'leftLowerArm';
                                        break;
                                    case 'shin.L':
                                        animation.bone = 'leftLowerLeg';
                                        break;
                                    case 'f_middle.03.L':
                                        animation.bone = 'leftMiddleDistal';
                                        break;
                                    case 'f_middle.02.L':
                                        animation.bone = 'leftMiddleIntermediate';
                                        break;
                                    case 'f_middle.01.L':
                                        animation.bone = 'leftMiddleProximal';
                                        break;
                                    case 'f_ring.03.L':
                                        animation.bone = 'leftRingDistal';
                                        break;
                                    case 'f_ring.02.L':
                                        animation.bone = 'leftRingIntermediate';
                                        break;
                                    case 'f_ring.01.L':
                                        animation.bone = 'leftRingProximal';
                                        break;
                                    case 'shoulder.L':
                                        animation.bone = 'leftShoulder';
                                        break;
                                    case 'thumb_distal.L':
                                        animation.bone = 'leftThumbDistal';
                                        break;
                                    case 'thumb_intermediate.L':
                                        animation.bone = 'leftThumbIntermediate';
                                        break;
                                    case 'thumb_proximal.L':
                                        animation.bone = 'leftThumbProximal';
                                        break;
                                    case 'toe.L':
                                        animation.bone = 'leftToes';
                                        break;
                                    case 'upper_arm.L':
                                        animation.bone = 'leftUpperArm';
                                        break;
                                    case 'thigh.L':
                                        animation.bone = 'leftUpperLeg';
                                        break;
                                    case 'eye.R':
                                        animation.bone = 'rightEye';
                                        break;
                                    case 'foot.R':
                                        animation.bone = 'rightFoot';
                                        break;
                                    case 'hand.R':
                                        animation.bone = 'rightHand';
                                        break;
                                    case 'f_index.03.R':
                                        animation.bone = 'rightIndexDistal';
                                        break;
                                    case 'f_index.02.R':
                                        animation.bone = 'rightIndexIntermediate';
                                        break;
                                    case 'f_index.01.R':
                                        animation.bone = 'rightIndexProximal';
                                        break;
                                    case 'f_pinky.03.R':
                                        animation.bone = 'rightLittleDistal';
                                        break;
                                    case 'f_pinky.02.R':
                                        animation.bone = 'rightLittleIntermediate';
                                        break;
                                    case 'f_pinky.01.R':
                                        animation.bone = 'rightLittleProximal';
                                        break;
                                    case 'lower_arm.R':
                                        animation.bone = 'rightLowerArm';
                                        break;
                                    case 'shin.R':
                                        animation.bone = 'rightLowerLeg';
                                        break;
                                    case 'f_middle.03.R':
                                        animation.bone = 'rightMiddleDistal';
                                        break;
                                    case 'f_middle.02.R':
                                        animation.bone = 'rightMiddleIntermediate';
                                        break;
                                    case 'f_middle.01.R':
                                        animation.bone = 'rightMiddleProximal';
                                        break;
                                    case 'f_ring.03.R':
                                        animation.bone = 'rightRingDistal';
                                        break;
                                    case 'f_ring.02.R':
                                        animation.bone = 'rightRingIntermediate';
                                        break;
                                    case 'f_ring.01.R':
                                        animation.bone = 'rightRingProximal';
                                        break;
                                    case 'shoulder.R':
                                        animation.bone = 'rightShoulder';
                                        break;
                                    case 'thumb_distal.R':
                                        animation.bone = 'rightThumbDistal';
                                        break;
                                    case 'thumb_intermediate.R':
                                        animation.bone = 'rightThumbIntermediate';
                                        break;
                                    case 'thumb_proximal.R':
                                        animation.bone = 'rightThumbProximal';
                                        break;
                                    case 'toe.R':
                                        animation.bone = 'rightToes';
                                        break;
                                    case 'upper_arm.R':
                                        animation.bone = 'rightUpperArm';
                                        break;
                                    case 'thigh.R':
                                        animation.bone = 'rightUpperLeg';
                                        break;
                                    case 'upper_chest':
                                        animation.bone = 'upperChest';
                                        break;
                                    default:
                                        animation.bone = null;
                                }

                                if (animation.bone && animation.rotation.length == 4) {
                                    try {
                                        app.vrm.humanoid.getBoneNode(animation.bone).position.set(animation.position[0], animation.position[1], -animation.position[2]);
                                        app.vrm.humanoid.getBoneNode(animation.bone).quaternion.set(-animation.rotation[0], -animation.rotation[1], animation.rotation[2], animation.rotation[3]);
                                    } catch (e) {
                                        console.log(animation.bone);
                                    }
                                }
                            }
                        }

                        app.vrm.update(deltaTime);

                        /*if (currentMixer) {
                            currentMixer.update(deltaTime);
                        }*/

                        renderer.render(scene, camera);
                    }

                    stats.update();
                }
            },
            updated: function () {
                let container = this.$refs.container;
                let popup = document.body.querySelector(".navbar:nth-of-type(2) .navbar-item .control:last-child .level:nth-last-of-type(1)");

                container.style.paddingTop = this.$refs.indicator.getBoundingClientRect().height + 'px'
                container.style.paddingBottom = this.$refs.input.getBoundingClientRect().height + 'px'

                this.$refs.ticker.style.width = document.body.querySelector("#input .columns>.column .control:nth-last-of-type(1) .level:nth-last-of-type(1) form").getBoundingClientRect().width + 'px';

                //document.body.querySelector("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker").style.width = "100%";
                /*this.$refs.ticker.style.width = document.body.querySelector("#input .columns>.column .control:nth-last-of-type(1) .level:nth-last-of-type(1) form").getBoundingClientRect().width + 'px';
                this.$nextTick(() => {
                    let width = 0;

                    for (const item of document.body.querySelectorAll("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker .item")) {
                        width += item.getBoundingClientRect().width;
                    }

                    document.body.querySelector("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker").style.width = width + 'px';
                });*/

                if (popup !== null) {
                    popup.style.paddingBottom = container.style.paddingBottom;
                }
            },
            mounted: async function () {
                const self = this;
                let container = this.$refs.container;
                let popup = document.body.querySelector(".navbar:nth-of-type(2) .navbar-item .control:last-child .level:nth-last-of-type(1)");
                const loader = new GLTFLoader();

                this.$refs.three.appendChild(renderer.domElement);
                this.$refs.three.appendChild(stats.domElement);

                this.render();

                container.style.paddingTop = this.$refs.indicator.getBoundingClientRect().height + 'px'
                container.style.paddingBottom = this.$refs.input.getBoundingClientRect().height + 'px'

                this.$refs.ticker.style.width = document.body.querySelector("#input .columns>.column .control:nth-last-of-type(1) .level:nth-last-of-type(1) form").getBoundingClientRect().width + 'px';

                //document.body.querySelector("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker").style.width = this.$refs.ticker.style.width;

                //document.body.querySelector("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker").style.width = "100%";
                /*this.$refs.ticker.style.width = document.body.querySelector("#input .columns>.column .control:nth-last-of-type(1) .level:nth-last-of-type(1) form").getBoundingClientRect().width + 'px';

                for (const item of document.body.querySelectorAll("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker .item")) {
                    width += item.getBoundingClientRect().width;
                }

                ticker.style.width = width + 'px';*/

                if (popup !== null) {
                    popup.style.paddingBottom = container.style.paddingBottom;
                }

                try {
                    const response1 = await fetch('/js/images.json', {
                        mode: "cors",
                        method: "GET",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded"
                        }
                    });

                    if (response1.ok) {
                        this.presetImages = await response1.json();

                        if (this.presetImages !== null && this.presetImages.length > 0) {
                            this.isBlinded = true;
                        }
                    }
                    else {
                        throw new Error(response1.statusText);
                    }
                } catch (e) {
                    console.error(e);
                }

                try {
                    const response2 = await fetch('/js/milch.json', {
                        mode: "cors",
                        method: "GET",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded"
                        }
                    });

                    if (response2.ok) {
                        self.character = await response2.json();
                    }
                    else {
                        throw new Error(response2.statusText);
                    }

                    loader.crossOrigin = "anonymous";
                    loader.load(
                        self.character.model,
                        (gltf) => {
                            THREE.VRM.from(gltf).then(async (vrm) => {
                                const urls = {
                                    idle1: '/models/animations/animation-idle1.json',
                                    idle2: '/models/animations/animation-idle2.json',
                                    //idle3: '/models/animations/animation-idle3.json',
                                    //idle4: '/models/animations/animation-idle4.json',
                                    jump: '/models/animations/animation-jump.json',
                                    lose: '/models/animations/animation-lose.json',
                                    //run: '/models/animations/animation-run.json',
                                    //walk: '/models/animations/animation-walk.json',
                                    win: '/models/animations/animation-win.json'
                                };
                                let animationDictionary = {};

                                try {
                                    if (channel.length == 0) {
                                        for (let key in urls) {
                                            const response3 = await fetch(encodeURI(urls[key]), {
                                                mode: "cors",
                                                method: "GET",
                                                headers: {
                                                    "Content-Type": "application/x-www-form-urlencoded"
                                                }
                                            });

                                            if (response3.ok) {
                                                const json = await response3.json();

                                                animationDictionary[key] = json.data;
                                            }
                                            else {
                                                throw new Error(response3.statusText);
                                            }
                                        }

                                        self.animationsQueue.push(animationDictionary['jump']);
                                    }

                                    self.animations = animationDictionary;
                                    self.vrm = vrm;

                                    scene.add(vrm.scene);

                                    //vrm.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName.Hips).rotation.y = Math.PI;

                                    //currentMixer = prepareAnimation(vrm);

                                    vrm.lookAt.target = lookAtTarget;

                                    self.progress = 0.0;
                                } catch (e) {
                                    console.error(e);
                                }
                            });
                        },
                        (progress) => self.progress = progress.loaded / progress.total,
                        (error) => console.error(error)
                    );
                } catch (e) {
                    console.error(e);
                }

                firebase.auth().signInAnonymously().catch(function (error) {
                    console.error(error.code, error.message);
                });
                firebase.auth().onAuthStateChanged(function (user) {
                    if (user) {
                        // User is signed in.
                        self.user = user;

                        database.ref(databaseChannel + "/stars").on('value', snapshot => {
                            const count = snapshot.val();

                            if (count === null) {
                                self.stars = 0;
                            } else {
                                if (self.stars >= 0) {
                                    const particles = count - self.stars;

                                    if (particles > 0) {
                                        window.pJSDom[0].pJS.fn.modes.pushParticles(particles);
                                    }
                                }

                                self.stars = count;
                            }
                        });
                        database.ref(databaseMessages).limitToLast(100).on('value', snapshot => {
                            const messageDictionary = snapshot.val();

                            if (messageDictionary) {
                                let keys = Object.keys(messageDictionary);
                                let received = null;

                                if (keys.length > app.maxMessages) {
                                    keys.splice(0, keys.length - app.maxMessages);
                                }

                                for (let key of keys) {
                                    const message = messageDictionary[key];
                                    const timestamp = message.timestamp * 1000;
                                    let index = -1;

                                    //console.log(date.toISOString());
                                    //console.log(date.toLocaleTimeString());

                                    for (let i = 0; i < app.messages.length; i++) {
                                        if (key === app.messages[i].id) {
                                            index = i;

                                            break;
                                        }
                                    }

                                    if (!message.user.accent) {
                                        message.user.accent = '#30c0f5';
                                    }

                                    if (channel.length > 0 && !message.user.id) {
                                        message.user.name = null;
                                        message.user.image = null;
                                    }

                                    if (index >= 0) {
                                        //let j = -1;
                                        const data = { id: key, text: message.text, thread: message.thread, timestamp: new Date(timestamp), user: message.user };
                                        /*
                                        for (let i = 0; i < app.messages.length; i++) {
                                            if (timestamp < Math.floor(app.messages[i].timestamp)) {
                                                j = i;
                                            }
                                        }

                                        if (j >= 0) {
                                            const temp = app.messages[j];

                                            app.messages[j] = data;
                                            app.messages[index] = temp;
                                        } else {
                                            app.messages[index] = data;
                                        }*/

                                        app.messages[index] = data;
                                    }
                                    else {
                                        for (let i = 0; i < app.messages.length; i++) {
                                            if (timestamp < Math.floor(app.messages[i].timestamp)) {
                                                index = i;
                                            }
                                        }

                                        app.messages.splice(index >= 0 ? index : app.messages.length, 0, { id: key, text: message.text, thread: message.thread, timestamp: new Date(timestamp), user: message.user });

                                        if (app.messages.length > app.maxMessages) {
                                            app.messages.shift();
                                        }

                                        if (app.user.uid !== message.user.id) {
                                            received = message.user;
                                        }
                                    }
                                }

                                for (let i = app.messages.length - 1; i >= 0; i--) {
                                    if (!(app.messages[i].id in messageDictionary)) {
                                        app.messages.splice(i, 1);
                                    }
                                }

                                if (received) {
                                    if (!received.id && app.vrm) {
                                        app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.A, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.A, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.A, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }]);
                                    }

                                    document.body.querySelector("#alert").play();
                                }

                                app.update(messageDictionary, app.maxTags);
                            }
                        });
                    } else {
                        // User is signed out.
                        database.ref(databaseChannel + "/stars").off('value');
                        database.ref(databaseMessages).off('value');

                        self.user = null;
                    }
                });
            },
            unmounted: function () {
                if (this.vrm !== null) {
                    scene.remove(this.vrm.scene);
                    this.vrm = null;
                }
            }
        }).mount('#app');

        window.addEventListener('resize', (event) => {
            let container = app.$refs.container;
            let popup = document.body.querySelector(".navbar:nth-of-type(2) .navbar-item .control:last-child .level:nth-last-of-type(1)");

            container.style.paddingTop = app.$refs.indicator.getBoundingClientRect().height + 'px'
            container.style.paddingBottom = app.$refs.input.getBoundingClientRect().height + 'px'

            app.$refs.ticker.style.width = document.body.querySelector("#input .columns>.column .control:nth-last-of-type(1) .level:nth-last-of-type(1) form").getBoundingClientRect().width + 'px';

            if (popup !== null) {
                popup.style.paddingBottom = container.style.paddingBottom;
            }

            const width = window.innerWidth;
            const height = window.outerHeight;

            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
        window.addEventListener('click', (event) => {
            raycaster.setFromCamera(mouse, camera);

            for (let intersect of raycaster.intersectObjects(scene.children, true)) {
                if (intersect.object.name === 'face') {
                    app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }]);

                    break;
                } else if (intersect.object.name.indexOf('breast') >= 0) {
                    if (random(0, 1) === 0) {
                        app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.0, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 3.0, start: 0.5, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.5, end: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.0, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 3.0, start: 0.5, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.5, end: 0.0 }]);
                    } else {
                        app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.Angry, time: 0.0, duration: 0.5, start: 0.0, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.Angry, time: 0.0, duration: 3.0, start: 0.5, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.Angry, time: 0.0, duration: 0.5, start: 0.5, end: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.O, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.O, time: 0.0, duration: 3.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.O, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }]);
                    }

                    break;
                }
            }
        });
        window.addEventListener('dblclick', (event) => {
            raycaster.setFromCamera(mouse, camera);

            if (raycaster.intersectObjects(scene.children, true).length > 0 && channel.length == 0) {
                app.talk();
            }
        });
        window.addEventListener('mousemove', (event) => {
            /*if (currentVrm) {
        
                const range = CAMERA_Z * Math.tan(CAMERA_FOV / 360.0 * Math.PI);
                const px = (2.0 * event.clientX - window.innerWidth) / window.outerHeight * range;
                const py = -(2.0 * event.clientY - window.outerHeight) / window.outerHeight * range;
        
                currentVrm.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName.Hips).position.set(px, py, 0.0);
            }*/
            mouse.x = (event.clientX / window.innerWidth) * 2.0 - 1.0;
            mouse.y = -(event.clientY / window.outerHeight) * 2.0 + 1.0;

            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener('touchstart', (event) => {
            mouse.x = (event.changedTouches[0].clientX / window.innerWidth) * 2.0 - 1.0;
            mouse.y = -(event.changedTouches[0].clientY / window.outerHeight) * 2.0 + 1.0;

            raycaster.setFromCamera(mouse, camera);

            for (let intersect of raycaster.intersectObjects(scene.children, true)) {
                if (intersect.object.name === 'face') {
                    app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }]);

                    break;
                }
            }

            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.changedTouches[0].clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.changedTouches[0].clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener('touchmove', (event) => {
            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.changedTouches[0].clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.changedTouches[0].clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener('touchend', (event) => {
            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.changedTouches[0].clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.changedTouches[0].clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener("dragover", (event) => {
            event.preventDefault();
            event.dataTransfer.dropEffect = "copy";
        }, false);
        window.addEventListener("drop", (event) => {
            event.stopPropagation();
            event.preventDefault();

            for (let file of event.dataTransfer.files) {
                let reader = new FileReader();

                reader.addEventListener("load", (e) => {
                    const loader = new GLTFLoader();

                    loader.crossOrigin = "anonymous";
                    loader.load(
                        e.target.result,
                        (gltf) => {
                            THREE.VRM.from(gltf).then((vrm) => {
                                if (app.vrm !== null) {
                                    scene.remove(app.vrm.scene);
                                }

                                app.vrm = vrm;

                                scene.add(vrm.scene);

                                //vrm.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName.Hips).rotation.y = Math.PI;

                                //currentMixer = prepareAnimation(vrm);

                                vrm.lookAt.target = lookAtTarget;

                                app.progress = 0.0;
                            });
                        },
                        (progress) => app.progress = progress.loaded / progress.total,
                        (error) => console.error(error)
                    );
                });
                reader.readAsDataURL(file);

                break;
            }

        }, false);

        particlesJS.load('particles-js', '/js/particlesjs-config.json', function () {
            app.isReady = true;
        });
    </script>
</body>

</html>