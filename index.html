<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <meta name="theme-color" content="#f6f6f6">
    <title>ミルヒちゃんねる</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP" rel="stylesheet">
    <link href="https://fonts.googleapis.com/earlyaccess/nicomoji.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Alata&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Sans&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/922939073a.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css" type="text/css"
        media="screen" />
    <style>
        [v-cloak] {
            display: none;
        }

        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            height: -webkit-fill-available;
            overflow-x: hidden;
            overflow-y: auto;
            scroll-behavior: smooth;
            /*background: #f5f5f5;*/
            /*background: #9095bd;*/
            background: #ffef8c;
        }

        body::before {
            z-index: -1;
            display: block;
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100vh;
            background: url('/images/Background.png') repeat;
            content: "";
            animation: fade 0.5s ease-out, loop 10s linear infinite;
        }

        body {
            position: relative;
            margin: 0;
            padding: 0;
            width: 100%;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow: hidden;
        }

        h1,
        h2,
        p,
        span,
        input {
            font-family: "Hiragino Kaku Gothic ProN", "Hiragino Sans", "Noto Sans JP", sans-serif;
        }

        input::placeholder {
            color: rgba(0, 0, 0, 0.5);
        }

        label {
            display: inline;
            cursor: pointer;
        }

        a,
        a:focus {
            outline: none;
        }

        label.checkbox input[type=checkbox],
        label.checkbox input[type=radio] {
            display: none;
        }

        label.checkbox .custom {
            position: relative;
            margin: 0px 8px 0px 0px;
            font-size: 1.0rem;
        }

        label.checkbox input[type=checkbox]+.custom:before,
        label.checkbox input[type=radio]+.custom:before {
            font-weight: 900;
            font-family: "Font Awesome 5 Free";
            content: '\f00c';
            color: rgba(255, 255, 255, 0.5);
        }

        label.checkbox input[type=checkbox]:checked+.custom:before,
        label.checkbox input[type=radio]:checked+.custom:before {
            color: #64dafe;
        }

        .navbar {
            margin: 0;
            padding: 0;
            background-color: transparent;
        }

        .navbar-item {
            padding: 0 !important;
        }

        .columns {
            margin: 0 !important;
        }

        .columns>.column {
            padding: 0 !important;
        }

        .tags>.tag {
            margin: -4px;
            padding: 0px 8px 0px 8px;
            padding: 12px 24px 12px 24px;
            border: 0px solid transparent;
            border: 4px solid rgba(255, 255, 255, 0.5);
            border-radius: 500px 500px 500px 500px;
            background: #ffffff;
            background-clip: padding-box;
            height: initial;
        }

        .is-primary {
            /*color: #fef6a5 !important;*/
            color: #64dafe !important;
        }

        .logo {
            position: fixed;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        .logo svg {
            margin: 0;
            padding: 0;
            height: 10vmin;
        }

        .logo svg g path {
            fill: #000000;
            fill-opacity: 0;
            stroke: #000000 !important;
            stroke-width: 0.5 !important;
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: draw 1s linear forwards;
        }

        .progress {
            position: fixed;
            margin: 0;
            padding: 0;
            border-radius: 0px;
            width: 0%;
            height: 2px;
            top: 0;
            left: 0;
            overflow: hidden;
            background: #ffc547 url('/images/Stripes.png') repeat;
            animation: progress 0.5s linear 0s infinite;
        }

        .ticker-wrap {
            padding: 0;
            width: 100%;
            overflow: hidden;
            box-sizing: content-box;
            background-color: transparent;
        }

        .ticker-wrap .ticker {
            display: inline-block;
            white-space: nowrap;
            padding: 0;
            box-sizing: content-box;
            animation-iteration-count: infinite;
            animation-timing-function: linear;
            /*animation-name: ticker;*/
            animation-duration: 30s;
            animation-play-state: paused;
        }

        .ticker-wrap .ticker .item {
            display: inline-block;
            vertical-align: middle;
        }

        .ticker-wrap .ticker .item .media {
            align-items: center;
        }

        .ticker-wrap .ticker .item .media .media-left {
            margin: 0px 8px 0px 0px;
        }

        .background {
            position: fixed;
            z-index: -1;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: transparent;
            background-position: 50% 50%;
            background-size: contain;
            background-repeat: no-repeat;
        }

        .background>div {
            position: fixed;
            overflow: hidden;
            background-color: transparent;
            background-position: 50% 50%;
            background-size: cover;
            background-repeat: no-repeat;
            width: 100%;
            height: 100%;
        }

        .background>img {
            position: fixed;
            object-fit: cover;
            width: 100%;
            height: 100%;
        }

        .background .ticker-wrap {
            position: fixed;
            bottom: 0;
            height: 100vh;
        }

        .background .ticker-wrap .ticker {
            position: fixed;
            bottom: 0;
            height: 100vh;
            line-height: 100vh;
        }

        .background .ticker-wrap .ticker .item {
            padding: 0px 10vmin;
            color: rgba(255, 255, 255, 0.5);
            font-size: 100vh;
        }

        #three {
            position: fixed;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        #three>canvas {
            overflow: hidden;
            outline: none;
        }

        #particles-js {
            position: fixed;
            z-index: -1;
            width: 100%;
            height: 100vh;
            background-color: transparent;
            overflow: hidden;
        }

        .has-content-centered {
            margin-left: auto;
            margin-right: auto;
        }

        .columns .is-vcentered {
            align-items: center;
        }

        .blind {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            transform: translate3d(0, 0%, 0);
            overflow: hidden;
            background: #64dafe;
            /*background: #64dafe url('/images/Background.png') 50% 50% repeat;
            animation: progress 0.5s linear 0s infinite;*/
        }

        #app {
            position: relative;
            margin: 0;
            width: 100%;
            overflow: hidden;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:first-child {
            margin: 16px 0px 0px 0px;
            padding: 0px 0px 0px 16px !important;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:first-child button {
            margin: -4px;
            border: 4px solid rgba(255, 255, 255, 0.5);
            border-radius: 290486px;
            padding: 16px;
            background: #ffffff;
            background-clip: padding-box;
            /*background: #f5f5f5;
            background: linear-gradient(145deg, #ffffff, #dddddd);
            box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
            height: initial;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:first-child button>span {
            margin: 0;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:last-child {
            margin: 16px 0px 0px 0px;
            padding: 0px 16px 0px 0px !important;
            text-align: right;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:last-child button {
            margin: -4px;
            border: 4px solid rgba(255, 255, 255, 0.5);
            border-radius: 290486px;
            padding: 16px;
            background: #ffffff;
            background-clip: padding-box;
            /*background: #f5f5f5;
            background: linear-gradient(145deg, #ffffff, #dddddd);
            box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
            height: initial;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:last-child button>span {
            margin: 0;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:nth-child(2)>.control .level .level-item .field span.icon {
            margin: 0px 8px 0px 0px;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:nth-child(2)>.control {
            margin: 0;
            padding: 16px 16px 16px 16px;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:nth-child(2)>.control>.level:nth-last-of-type(1) {
            margin: 0;
            padding: 0px 0px 8px 0px;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:nth-child(2)>.control .title {
            font-family: 'Alata', sans-serif;
            font-size: 5rem !important;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:first-child>.column:nth-child(2)>.control .subtitle {
            font-family: 'Nico Moji', sans-serif;
        }

        /*#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item {
            padding: 0px 16px 16px 16px;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field {
            margin: 0;
            width: 100%;
            background-color: #30c0f5;
            background-color: #f5f5f5;
            background-color: rgba(255, 255, 255, 1.0);
            border-radius: 500px 500px 500px 500px;
            padding: 8px 16px 8px 16px;
            box-sizing: border-box;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .clip {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .clip .ticker-wrap .ticker .item {
            padding: 0px 16px;
        }*/

        #heading>.columns>.column>.columns:last-child {
            justify-content: center;
        }

        #heading>.columns>.column>.columns:last-child>.column>.control>.level:first-child>.level-item:nth-child(1) {
            padding: 0px 16px 16px 16px;
        }

        #heading>.columns>.column>.columns:last-child>.column>.control>.level:first-child>.level-item {
            margin: 0;
            padding: 0px 16px 16px 16px;
        }

        #heading>.columns>.column>.columns:last-child>.column>.control>.level:first-child>.level-item>.level {
            margin: 0px -16px 0px -16px;
        }

        #heading>.columns>.column>.columns:last-child>.column>.control>.level:first-child>.level-item>.level>.level-item {
            margin: 0px 16px 0px 16px;
        }

        #heading>.columns>.column>.columns:last-child>.column>.control>.level:first-child h1 {
            margin: 0px 0px 8px 0px;
            font-family: "Gotham", "Noto Sans JP", sans-serif;
        }

        #heading>.columns>.column>.columns:last-child>.column>.control>.level:first-child h2 {
            margin: 0;
            font-family: "Gotham", "Noto Sans JP", sans-serif;
        }

        #heading>.columns>.column>.columns:last-child>.column>.control>.level:first-child p {
            font-family: "Gotham", "Noto Sans JP", sans-serif;
            line-height: 2.0rem;
        }

        #heading>.columns>.column>.columns:last-child>.column>.control>.level:first-child hr {
            margin: 24px auto 8px auto;
            border-width: 0;
            padding: 0;
            width: 32px;
            height: 4px;
            background-color: #000000;
            text-align: center !important;
        }

        #heading>.columns>.column>.columns:last-child>.column>.control>.level:first-child .icon {
            margin: -4px;
            border: 4px solid rgba(255, 255, 255, 0.5);
            border-radius: 290486px;
            padding: 24px;
            background: #ffffff;
            background-clip: padding-box;
        }

        #heading .navbar-item .tags>.control {
            margin: 0px 0px 0px 0px;
            padding: 8px 8px 8px 8px;
        }

        #heading .tags {
            margin: 0;
            padding: 0;
            align-items: flex-start;
            justify-content: center;
        }

        #heading .level>.level-item>.tags {
            margin: -8px;
            padding: 0;
        }

        #container {
            z-index: 0;
            position: relative;
            margin: 0;
            padding: 0px env(safe-area-inset-right, 0px) 0px env(safe-area-inset-left, 0px);
        }

        #container .column hr {
            margin: 8px 0px 8px 0px;
            padding: 0;
            height: 0;
        }

        #container .columns .column .media {
            margin: 0;
            padding: 16px 16px 16px 16px;
        }

        #container .columns .column .media:first-child {
            padding: 16px 16px 0px 16px;
        }

        #container .columns .column .media .media-content .content {
            margin: 0;
            padding: 0;
        }

        #container .columns .column .media .media-content p {
            word-wrap: break-word;
            white-space: normal;
        }

        #container .columns .column .media .media-content .has-text-left .balloon {
            display: inline-block;
            padding: 16px 32px 16px 32px;
            border-radius: 500px 500px 500px 0px;
            background: url('/images/Stripes.png') repeat;
            /*background: #f5f5f5;
            box-shadow: 20px 20px 60px #d0d0d0,
                -20px -20px 60px #ffffff;*/
        }

        #container .columns .column .media .media-content .columns .column .field label.checkbox {
            margin: 12px -4px -4px -4px;
            padding: 16px 32px 16px 32px;
            border: 4px solid rgba(255, 255, 255, 0.5);
            border-radius: 500px 500px 500px 500px;
            background: #ffffff;
            background-clip: padding-box;
        }

        #container .columns .column .media .media-content .level:nth-last-of-type(1) .level-item {
            margin: 16px 0px 16px 0px;
            padding: 0;
        }

        #container .columns .column .media .media-content .level:nth-last-of-type(1) .level-item button {
            margin: -4px;
            border: 4px solid rgba(255, 255, 255, 0.5);
            border-radius: 290486px;
            padding: 16px;
            background: #ffffff;
            background-clip: padding-box;
            /*background: #f5f5f5;
            background: linear-gradient(145deg, #ffffff, #dddddd);
            box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
            height: initial;
        }

        #container .columns .column .media .media-content .level:nth-last-of-type(1) .level-item button span {
            margin: 0;
        }

        #input form .field {
            margin: -4px;
            border: 4px solid rgba(255, 255, 255, 0.5);
            border-radius: 500px 500px 500px 500px;
            padding: 8px 16px 8px 16px;
            background: #ffffff;
            background-clip: padding-box;
            /*background: #f5f5f5;
            box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
        }

        /*.media-content .level {
            margin: 0px 0px 4px 0px;
        }*/

        /*.media-content .content div:last-child {
            margin: 4px 0px 0px 0px;
        }*/

        /*.media-content .has-text-right .balloon {
            display: inline-block;
            padding: 16px 32px 16px 32px;
            border-radius: 500px 500px 0px 500px;
            background: url('/images/Stripes.png') repeat;
            background: #f5f5f5;
            box-shadow: 20px 20px 60px #d0d0d0,
                -20px -20px 60px #ffffff;
        }

        .media-content>.level span {
            font-family: 'Noto Sans JP', sans-serif;
        }

        .media-content .balloon span {
            font-family: 'Noto Sans JP', sans-serif;
        }

        .media-content .has-text-left div:nth-last-of-type(1)>p {
            font-family: 'Alata', 'Josefin Sans', sans-serif;
        }

        .media-content .has-text-right div:nth-last-of-type(1)>p {
            font-family: 'Alata', 'Josefin Sans', sans-serif;
            font-family: 'Fredoka One', cursive;
        }*/

        #heading {
            margin: 0;
            padding: env(safe-area-inset-top, 0px) env(safe-area-inset-right, 0px) 0px env(safe-area-inset-left, 0px);
        }

        #heading .navbar-item .control nav.level:nth-last-child(1) {
            display: block;
        }

        #popup {
            margin: 0;
            padding: 0;
            background: linear-gradient(0deg, rgba(0, 0, 0, 0.25), rgba(0, 0, 0, 0));
            backdrop-filter: blur(8px);
        }

        #popup .columns>.column>.control:last-child {
            margin: 0;
            padding: 0px env(safe-area-inset-right, 0px) env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
        }

        #popup .columns>.column>.control:last-child .level:nth-last-of-type(1) {
            display: block;
            margin: 0;
            padding: 0px 16px 16px 16px;
        }

        #popup .columns>.column>.control:last-child .level:nth-last-of-type(2) {
            margin: 0;
            padding: 16px 16px 32px 16px;
        }

        #popup .columns>.column>.control:first-child .level:nth-last-of-type(2) .media {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 500px 500px 500px 500px;
            padding: 8px 16px 8px 16px;
            background: url('/images/Stripes.png') repeat;
            /*box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
        }

        #popup .columns>.column>.control:first-child .level:nth-last-of-type(2) .media .media-left {
            margin: 0px 8px 0px 0px;
            padding: 0;
        }

        #popup .columns>.column>.control:last-child .level:nth-last-of-type(1) .media {
            margin: 0;
            padding: 0px 16px 0px 16px;
        }

        #popup .columns>.column>.control:last-child .level:nth-last-of-type(1) .media .media-content {
            overflow: hidden;
        }

        #popup .columns>.column>.control:last-child .level:nth-last-of-type(1) .media span {
            display: inline-block;
            line-height: 1.5rem;
        }

        #popup .columns>.column>.control:last-child .level:nth-last-of-type(1) .media span.break {
            display: block;
            margin: 0;
        }

        #input .columns>.column .control:nth-last-of-type(1) .level:nth-last-of-type(2) .level-left {
            margin: 12px -4px -4px -4px;
            padding: 16px 32px 16px 32px;
            border: 4px solid rgba(255, 255, 255, 0.5);
            border-radius: 500px 500px 500px 500px;
            background: #ffffff;
            background-clip: padding-box;
            /*background: rgba(0, 0, 0, 0.75);
            background: #f5f5f5;
            background: linear-gradient(145deg, #ffffff, #dddddd);
            box-shadow: 10px 10px 30px #d0d0d0,
                -10px -10px 30px #ffffff;*/
        }

        #container .columns .column .media {
            border: 0px solid transparent;
        }

        #container .columns .column .media:nth-last-of-type(1) .media-content {
            margin: -16px 0px 0px 0px;
            padding: 0;
        }

        #container .columns .column .media .media-content .columns {
            margin: 0;
            padding: 0;
            width: 100%;
        }

        #container .columns .column .media .media-content .columns .column .field {
            margin: 0;
            padding: 0px -8px 0px -8px;
            display: flex;
            align-items: center;
            justify-content: start;
        }

        #input .navbar-item .control:first-child .level {
            display: block;
            margin: 0;
            padding: 16px 0px 0px 0px;
        }

        #input .navbar-item .control:first-child .level .notification {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            margin: 0;
            padding: 0;
        }

        #input .navbar-item .control:first-child .level .is-info {
            color: #ffffff;
        }

        #input .navbar-item .control:first-child .level .notification .media {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 500px 500px 500px 500px;
            padding: 16px 32px 16px 32px;
            background: url('/images/Stripes.png') repeat;
        }

        #input .notification .media .media-left {
            margin: 0px 8px 0px 0px;
        }

        #input .navbar-item>div>.control:last-child {
            margin: 0;
            padding: 0px env(safe-area-inset-right, 0px) env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
        }

        #input .columns>.column .control:nth-last-of-type(2) {
            margin: 0;
            padding: 0px 16px 0px 16px;
        }

        #input .columns>.column .control:nth-last-of-type(2) .level:nth-last-of-type(2) .notification {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            margin: 0;
            padding: 0;
        }

        #input .columns>.column .control:nth-last-of-type(2) .level:nth-last-of-type(2) .notification .media {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 500px 500px 500px 500px;
            padding: 16px 32px 16px 32px;
            background: #5bcbe1 url('/images/Stripes.png') repeat;
        }

        #input .columns>.column .control:nth-last-of-type(2) .level:nth-last-of-type(2) .notification .media .media-left {
            margin: 0px 8px 0px 0px;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(2) {
            margin: 0;
            padding: 0px 16px 0px 16px;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) {
            display: block;
            margin: 0;
            padding: 16px 16px 16px 16px;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) form .field .control:nth-of-type(1) button {
            padding: 8px 16px 8px 16px;
            border: 0px solid transparent;
            border-radius: 290486px;
            background-color: transparent;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) form .field .control:nth-of-type(2) input {
            border: 0px solid transparent;
            padding-top: 8px;
            padding-bottom: 8px;
            background-color: transparent;
            box-shadow: none;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) form .field .control:nth-of-type(3) {
            display: flex;
            align-items: center;
            padding: 0px 8px 0px 8px;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) form .field .control:nth-of-type(3) span {
            font-family: 'Alata', 'Josefin Sans', sans-serif;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) form .field .control:nth-of-type(4) button {
            border: 0px solid transparent;
            border-radius: 290486px;
            background-color: transparent;
            /*color: #30c0f5;*/
        }

        .navbar-item img {
            max-height: none;
        }

        .updating {
            animation: updating 1s linear infinite;
        }

        .fade-enter-active,
        .fade-leave-active {
            transition: opacity 0.5s;
        }

        .fade-enter-from,
        .fade-leave-to {
            opacity: 0;
        }

        .reveal-enter-active,
        .reveal-leave-active {
            transition: all .5s ease;
        }

        .reveal-enter-from,
        .reveal-leave-to {
            opacity: 0;
            transform: translate3d(0, -50%, 0);
        }

        .reveal-enter-to,
        .reveal-leave-from {
            opacity: 1;
            transform: translate3d(0, 0%, 0);
        }

        .collapse-enter-active,
        .collapse-leave-active {
            transition: all .5s ease;
        }

        .collapse-enter-from,
        .collapse-leave-to {
            opacity: 0;
        }

        .collapse-enter-to,
        .collapse-leave-from {
            opacity: 1;
        }

        .blind-enter-active,
        .blind-leave-active {
            transition: all .5s ease;
        }

        .blind-enter-from {
            transform: translate3d(0, 100%, 0);
        }

        .blind-enter-to {
            transform: translate3d(0, 0%, 0);
        }

        .blind-leave-from {
            transform: translate3d(0, 0%, 0);
        }

        .blind-leave-to {
            transform: translate3d(0, -100%, 0);
        }

        .message-list-enter-active,
        .message-list-leave-active {
            transition: all 0.5s ease;
        }

        .message-list-move {
            transition: transform 0.5s ease;
        }

        .message-list-enter-from {
            opacity: 0;
            transform: translate3d(0%, 50%, 0);
        }

        .message-list-enter-to,
        .message-list-leave-from {
            opacity: 1;
            transform: translate3d(0%, 0%, 0);
        }

        .message-list-leave-to {
            opacity: 0;
            transform: translate3d(0%, -50%, 0);
        }

        .notification-list-enter-active,
        .notification-list-leave-active {
            transition: all 0.5s ease;
        }

        .notification-list-move {
            transition: transform 0.5s ease;
        }

        .notification-list-enter-from {
            opacity: 0;
            transform: translate3d(0%, 50%, 0);
        }

        .notification-list-enter-to,
        .notification-list-leave-from {
            opacity: 1;
            transform: translate3d(0%, 0%, 0);
        }

        .notification-list-leave-to {
            opacity: 0;
            transform: translate3d(0%, 0%, 0);
        }

        .type-list-enter-active,
        .type-list-leave-active {
            transition: all 0s ease;
        }

        .type-list-move {
            transition: transform 0s ease;
        }

        .type-list-enter-from,
        .type-list-leave-to {
            opacity: 0;
            transform: translate3d(0%, 25%, 0);
        }

        .type-list-enter-to,
        .type-list-leave-from {
            opacity: 1;
            transform: translate3d(0%, 0%, 0);
        }

        .popup-enter-active,
        .popup-leave-active {
            transition: all .5s ease;
        }

        .popup-enter-from {
            opacity: 0;
            transform: translate3d(0, 100%, 0);
        }

        .popup-enter-to {
            opacity: 1;
            transform: translate3d(0, 0%, 0);
        }

        .popup-leave-from {
            opacity: 1;
            transform: translate3d(0, 0%, 0);
        }

        .popup-leave-to {
            opacity: 0;
            transform: translate3d(0, 100%, 0);
        }

        .ticker-item-list-enter-active,
        .ticker-item-list-leave-active {
            transition: all 0.5s ease;
        }

        /*.ticker-item-list-move {
            transition: transform 0.5s ease;
        }*/

        .ticker-item-list-enter-from,
        .ticker-item-list-leave-to {
            opacity: 0;
        }

        .ticker-item-list-enter-to,
        .ticker-item-list-leave-from {
            opacity: 1;
        }

        @keyframes draw {
            to {
                stroke-dashoffset: 0;
            }
        }

        @keyframes fade {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes loop {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: -100px 0px;
            }
        }

        @keyframes progress {
            0% {
                background-position: 0px 0px;
            }

            100% {
                background-position: -20px 0px;
            }
        }

        @keyframes ticker {
            0% {
                transform: translate3d(0, 0, 0);
                visibility: visible;
            }

            100% {
                transform: translate3d(-50%, 0, 0);
            }
        }

        @keyframes updating {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(-360deg);
            }
        }

        @media screen and (-webkit-min-device-pixel-ratio:2),
        (min-resolution: 2dppx) {
            @keyframes loop {
                0% {
                    background-position: 0 0;
                }

                100% {
                    background-position: -200px 0px;
                }
            }

            @keyframes progress {
                0% {
                    background-position: 0px 0px;
                }

                100% {
                    background-position: -40px 0px;
                }
            }

            body::before {
                background: url('/images/Background@2x.png') repeat;
            }

            .progress {
                background: #ffc547 url('/images/Stripes@2x.png') repeat;
            }

            /*.blind {
                background: #64dafe url('/images/Stripes@2x.png') 50% 50% repeat 20px 20px;
            }*/

            #container .columns .column .media .media-content .has-text-left .balloon {
                background: url('/images/Stripes@2x.png') repeat;
            }

            .navbar:nth-of-type(2) .navbar-item .control:first-child .level:first-child .media {
                background: url('/images/Stripes@2x.png') repeat;
            }

            #input .columns>.column .control:nth-last-of-type(2) .level:nth-last-of-type(2) .notification .media {
                background: #5bcbe1 url('/images/Stripes@2x.png') repeat;
            }

            /*.tags>.tag {
                background-image: url('/images/Stripes@2x.png');
                background-size: 20px 20px;
            }

            .media-content .has-text-right .balloon {
                background: url('/images/Stripes@2x.png') repeat 20px 20px;
            }*/
        }

        @media screen and (-webkit-min-device-pixel-ratio:3),
        (min-resolution: 3dppx) {
            @keyframes loop {
                0% {
                    background-position: 0 0;
                }

                100% {
                    background-position: -300px 0px;
                }
            }

            @keyframes progress {
                0% {
                    background-position: 0px 0px;
                }

                100% {
                    background-position: -60px 0px;
                }
            }

            body::before {
                background: url('/images/Background@3x.png') repeat;
            }

            .progress {
                background: #ffc547 url('/images/Stripes@3x.png') repeat;
            }

            /*.blind {
                background: #64dafe url('/images/Stripes@3x.png') 50% 50% repeat 20px 20px;
            }*/

            #container .columns .column .media .media-content .has-text-left .balloon {
                background: url('/images/Stripes@3x.png') repeat;
            }

            .navbar:nth-of-type(2) .navbar-item .control:first-child .level:first-child .media {
                background: url('/images/Stripes@3x.png') repeat;
            }

            #input .columns>.column .control:nth-last-of-type(2) .level:nth-last-of-type(2) .notification .media {
                background-image: #5bcbe1 url('/images/Stripes@3x.png') repeat;
            }

            /*.tags>.tag {
                background-image: url('/images/Stripes@3x.png');
                background-size: 20px 20px;
            }

            .media-content .has-text-left .balloon {
                background: url('/images/Stripes@3x.png') repeat 20px 20px;
            }

            .media-content .has-text-right .balloon {
                background: url('/images/Stripes@3x.png') repeat 20px 20px;
            }*/
        }

        @font-face {
            font-family: "Gotham";
            src: url('/fonts/Gotham-Book.woff') format('woff');
            font-weight: normal;
        }

        @font-face {
            font-family: "Gotham";
            src: url('/fonts/Gotham-Bold.woff') format('woff');
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div id="particles-js"></div>
    <div id="app">
        <div class="background">
            <div v-bind:style="{ backgroundImage: 'url(' + image.url + ')', marginLeft: image.index * 100 + '%' }"
                v-for="image in backgroundImages" v-bind:key="image" v-cloak></div>
            <img v-bind:src="image.url" @load="load(image.url)" @error="error(image.url)" v-for="image in preloadImages"
                v-bind:key="image.url" alt="Background" v-cloak>
        </div>
        <div class="background">
            <div class="ticker-wrap">
                <transition-group name="ticker-item-list" class="ticker" tag="div"
                    v-bind:style="{ animationPlayState: 'running' }">
                    <div class="item" v-for="word in take(words, 10)" v-bind:key="word">
                        <span class="has-text-weight-bold" v-cloak>{{ word }}</span>
                    </div>
                    <div class="item" v-for="word in words" v-bind:key="word + '-alt'">
                        <span class="has-text-weight-bold" v-cloak>{{ word }}</span>
                    </div>
                </transition-group>
            </div>
        </div>
        <transition name="blind" v-on:after-enter="blinded">
            <div class="blind" v-if="isBlinded" v-cloak></div>
        </transition>
        <div id="three" ref="three"></div>
        <transition name="fade">
            <div class="logo" v-if="progress !== 0.0">
                <svg viewBox="0 0 1089 130" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;" v-cloak>
                    <g transform="matrix(2.66573,0,0,2.66573,1039.2,17.4789)">
                        <path d="M0,38.429C-3.95,34.613 -7.767,30.997 -11.517,27.047C-11.717,26.646 -12.319,27.248 -12.119,27.716L-8.303,33.609C-9.307,38.229 -13.658,41.71 -18.681,41.71C-24.572,41.71 -29.393,37.023 -29.393,30.997L-29.393,4.617C-29.393,-1.208 -24.572,-6.094 -18.681,-6.094C-15.466,-6.094 -12.521,-4.354 -10.512,-2.345L0.401,8.367C0.603,8.769 1.205,8.367 1.004,7.966L-2.946,2.207C-1.941,-2.345 2.41,-6.094 7.365,-6.094C13.324,-6.094 18.145,-1.208 18.145,4.617L18.145,30.997C18.145,41.308 6.025,44.523 0,38.429" style="fill-rule:nonzero;stroke:black;stroke-width:0.5px;"/>
                    </g>
                    <g transform="matrix(2.66573,0,0,2.66573,765.205,29.9663)">
                        <path d="M0,26.313L0,24.037C0,23.233 -0.669,22.564 -1.473,22.564C-2.276,22.564 -2.946,23.233 -2.946,24.037L-2.946,26.313C-2.946,32.338 -7.633,36.959 -13.591,36.959C-19.417,36.959 -24.237,32.338 -24.237,26.313L-24.237,-0.067C-24.237,-6.025 -19.417,-10.646 -13.591,-10.646C-7.633,-10.646 -2.946,-6.025 -2.946,-0.067L-2.946,2.344C-2.946,3.081 -2.276,3.75 -1.473,3.75C-0.669,3.75 0,3.081 0,2.344L0,-0.067C0,-5.892 4.821,-10.646 10.78,-10.646C16.604,-10.646 21.425,-5.892 21.425,-0.067L21.425,26.313C21.425,32.206 16.604,36.959 10.78,36.959C4.821,36.959 0,32.206 0,26.313" style="fill-rule:nonzero;stroke:black;stroke-width:0.5px;"/>
                    </g>
                    <g transform="matrix(2.66573,0,0,2.66573,661.51,128.31)">
                        <path d="M0,-47.604C6.227,-47.604 11.315,-42.248 11.315,-36.221C11.315,-29.928 6.227,-24.907 0,-24.907C-3.348,-24.907 -5.959,-26.446 -7.968,-26.446C-9.373,-26.446 -10.579,-25.241 -10.579,-23.835C-10.579,-22.497 -9.373,-21.424 -7.968,-21.424C-5.959,-21.424 -3.348,-22.965 0,-22.965C6.227,-22.965 11.315,-17.608 11.315,-11.315C11.315,-5.29 6.227,0 0,0L-9.709,0C-22.563,0 -33.075,-11.18 -33.075,-23.835C-33.075,-37.092 -22.43,-47.403 -9.373,-47.604L0,-47.604Z" style="fill-rule:nonzero;stroke:black;stroke-width:0.5px;"/>
                    </g>
                    <g transform="matrix(2.66573,0,0,2.66573,508.653,29.9663)">
                        <path d="M0,26.313L0,24.037C0,23.233 -0.669,22.564 -1.473,22.564C-2.276,22.564 -2.945,23.233 -2.945,24.037L-2.945,26.313C-2.945,32.338 -7.633,36.959 -13.592,36.959C-19.416,36.959 -24.237,32.338 -24.237,26.313L-24.237,-0.067C-24.237,-6.025 -19.416,-10.646 -13.592,-10.646C-7.633,-10.646 -2.945,-6.025 -2.945,-0.067L-2.945,2.344C-2.945,3.081 -2.276,3.75 -1.473,3.75C-0.669,3.75 0,3.081 0,2.344L0,-0.067C0,-5.892 4.82,-10.646 10.779,-10.646C16.603,-10.646 21.424,-5.892 21.424,-0.067L21.424,26.313C21.424,32.206 16.603,36.959 10.779,36.959C4.82,36.959 0,32.206 0,26.313" style="fill-rule:nonzero;stroke:black;stroke-width:0.5px;"/>
                    </g>
                    <g transform="matrix(2.66573,0,0,2.66573,405.402,128.31)">
                        <path d="M0,-47.604C6.227,-47.604 11.315,-42.248 11.315,-36.221C11.315,-29.928 6.227,-24.907 0,-24.907C-3.348,-24.907 -5.958,-26.446 -7.967,-26.446C-9.374,-26.446 -10.579,-25.241 -10.579,-23.835C-10.579,-22.497 -9.374,-21.424 -7.967,-21.424C-5.958,-21.424 -3.348,-22.965 0,-22.965C6.227,-22.965 11.315,-17.608 11.315,-11.315C11.315,-5.29 6.227,0 0,0L-9.708,0C-22.563,0 -33.075,-11.18 -33.075,-23.835C-33.075,-37.092 -22.43,-47.403 -9.374,-47.604L0,-47.604Z" style="fill-rule:nonzero;stroke:black;stroke-width:0.5px;"/>
                    </g>
                    <g transform="matrix(2.66573,0,0,2.66573,224.74,30.1487)">
                        <path d="M0,25.977L0,-0.203C0,-6.027 4.753,-10.847 10.646,-10.847C16.604,-10.847 21.358,-6.027 21.358,-0.203L21.224,15.399L23.568,15.399C37.494,15.399 37.494,36.824 23.568,36.824L10.846,36.824C4.62,36.824 -0.201,32.137 0,25.977" style="fill-rule:nonzero;stroke:black;stroke-width:0.5px;"/>
                    </g>
                    <g transform="matrix(2.66573,0,0,2.66573,158.234,30.5043)">
                        <path d="M0,25.91L0,-0.201C0,-6.027 4.687,-10.713 10.579,-10.713C16.671,-10.713 21.359,-6.027 21.359,-0.201L21.359,25.91C21.359,31.736 16.671,36.623 10.579,36.623C4.687,36.623 0,31.736 0,25.91" style="fill-rule:nonzero;stroke:black;stroke-width:0.5px;"/>
                    </g>
                    <g transform="matrix(2.66573,0,0,2.66573,119.86,128.134)">
                        <path d="M0,-47.337C-3.737,-47.337 -5.522,-46.208 -8.863,-42.581C-12.204,-38.956 -15.61,-34.627 -15.61,-34.627C-15.449,-34.316 -12.945,-29.959 -12.908,-29.445C-12.872,-28.931 -13.349,-29.243 -13.704,-29.556C-14.141,-29.94 -22.787,-39.785 -25.106,-42.625C-27.426,-45.465 -30.289,-47.337 -34.134,-47.337C-40.026,-47.337 -44.713,-42.65 -44.713,-36.825L-44.713,-10.713C-44.713,-4.888 -40.026,0 -34.134,0C-29.87,0 -26.31,-2.401 -24.551,-5.836C-25.025,-6.555 -28.111,-11.071 -28.365,-11.704C-28.576,-12.232 -28.304,-12.14 -28.164,-12.089C-28.096,-12.064 -27.791,-11.978 -25.543,-9.718C-24.95,-9.12 -23.718,-7.989 -23.716,-7.999C-21.889,-6.554 -19.505,-5.62 -16.966,-5.62C-14.326,-5.62 -12.005,-6.548 -10.215,-7.985C-10.213,-7.98 -5.942,-11.944 -5.77,-12.089C-5.597,-12.233 -5.291,-12.232 -5.568,-11.704C-5.885,-11.101 -8.91,-6.552 -9.386,-5.831C-7.637,-2.399 -4.121,0 0,0C6.093,0 10.78,-4.888 10.78,-10.713L10.78,-36.825C10.78,-42.65 6.093,-47.337 0,-47.337" style="fill-rule:nonzero;stroke:black;stroke-width:0.5px;"/>
                    </g>
                    <g transform="matrix(2.66573,0,0,2.66573,910.786,72.8974)">
                        <path d="M0,-6.241L-2.539,-3.766L-1.939,-0.272C-1.855,0.22 -2.058,0.716 -2.461,1.009C-2.689,1.175 -2.96,1.26 -3.231,1.26C-3.44,1.26 -3.649,1.209 -3.841,1.109L-6.979,-0.54L-10.117,1.109C-10.559,1.341 -11.093,1.303 -11.497,1.009C-11.9,0.716 -12.103,0.22 -12.019,-0.272L-11.419,-3.766L-13.958,-6.241C-14.315,-6.59 -14.443,-7.109 -14.289,-7.584C-14.135,-8.058 -13.725,-8.404 -13.231,-8.475L-9.724,-8.986L-8.154,-12.165C-7.934,-12.612 -7.478,-12.894 -6.979,-12.894C-6.48,-12.894 -6.024,-12.612 -5.804,-12.165L-4.235,-8.986L-0.727,-8.475C-0.233,-8.404 0.177,-8.058 0.331,-7.584C0.485,-7.109 0.356,-6.59 0,-6.241M-6.979,-27.096C-19.59,-27.096 -29.812,-16.874 -29.812,-4.264L-29.811,10.208C-29.811,16.234 -24.99,20.855 -19.165,20.855C-13.206,20.855 -8.52,16.234 -8.52,10.208L-8.52,7.932C-8.52,7.128 -7.85,6.459 -7.047,6.459C-6.242,6.459 -5.573,7.128 -5.573,7.932L-5.573,10.208C-5.573,16.101 -0.752,20.855 5.206,20.855C11.031,20.855 15.852,16.101 15.852,10.208L15.854,-4.264C15.854,-16.874 5.631,-27.096 -6.979,-27.096" style="fill-rule:nonzero;stroke:black;stroke-width:0.5px;"/>
                    </g>
                </svg>
            </div>
        </transition>
        <transition name="fade">
            <div class="progress" v-if="progress !== 0.0" v-bind:style="{width: String(100.0 * progress) + '%'}"
                v-cloak>
            </div>
        </transition>
        <nav id="heading" class="navbar is-fixed-top" role="navigation">
            <div class="navbar-item is-expanded columns is-desktop">
                <div class="column is-full has-content-centered" v-cloak>
                    <div class="columns is-mobile" ref="indicator">
                        <div class="column is-full">
                            <div class="columns is-mobile">
                                <div class="column is-3 is-mobile">
                                    <button class="button is-white" type="button" @click="isRevealed = !isRevealed">
                                        <span class="icon is-small">
                                            <i class="fas fa-bars"></i>
                                        </span>
                                    </button>
                                </div>
                                <div class="column is-6 is-mobile">
                                    <div class="control has-text-centered">
                                        <nav class="level">
                                            <div class="level-item has-text-centered">
                                                <div class="field is-grouped is-vcentered">
                                                    <span class="icon is-small has-text-black">
                                                        <i class="fas fa-star"></i>
                                                    </span>
                                                    <span
                                                        class="title is-size-1 is-uppercase has-text-black">{{ animatedStars }}</span>
                                                </div>
                                            </div>
                                        </nav>
                                        <!--<nav class="level">
                                            <div class="level-item has-text-centered">
                                                <div class="field">
                                                    <h6
                                                        class="subtitle is-size-6 is-uppercase has-text-weight-bold has-text-black">
                                                        つかったことば
                                                    </h6>
                                                </div>
                                            </div>
                                        </nav>-->
                                    </div>
                                </div>
                                <div class="column is-3 is-mobile">
                                    <transition name="fade" mode="out-in">
                                        <button class="button is-white" type="button" v-bind:disabled="user === null"
                                            @click="like" v-if="isSuggested" key="cancel">
                                            <span class="icon is-small">
                                                <i class="fas fa-times"></i>
                                            </span>
                                        </button>
                                        <button class="button is-white" type="button" v-bind:disabled="user === null"
                                            @click="talk" v-else key="suggest">
                                            <span class="icon is-small">
                                                <i class="fas fa-comment"></i>
                                            </span>
                                        </button>
                                    </transition>
                                </div>
                            </div>
                            <!--<div class="columns">
                                <div class="column is-half is-mobile has-content-centered">
                                    <div class="control has-text-centered">
                                        <nav class="level">
                                            <div class="level-item has-text-centered">
                                                <div class="field" ref="ticker">
                                                    <div class="clip">
                                                        <div class="ticker-wrap">
                                                            <transition-group name="ticker-item-list" class="ticker"
                                                                tag="div"
                                                                v-bind:style="{ animationPlayState: 'running' }">
                                                                <div class="item" v-show="messages.length > 0"
                                                                    key="merku-statuses" v-cloak>
                                                                    <article class="media">
                                                                        <figure class="media-left">
                                                                            <span class="image is-24x24">
                                                                                <img class="is-rounded"
                                                                                    src="/images/Merku.png"
                                                                                    alt="メルクちゃん">
                                                                            </span>
                                                                        </figure>
                                                                        <div class="media-content">
                                                                            <div class="content has-text-left">
                                                                                <span
                                                                                    class="is-size-6 has-text-weight-bold has-text-gray">ミルヒちゃんねるのニュースだよぉ</span>
                                                                            </div>
                                                                        </div>
                                                                    </article>
                                                                </div>
                                                                <div class="item" v-for="message in messages"
                                                                    v-bind:key="message.id">
                                                                    <span
                                                                        class="is-size-6 has-text-weight-bold has-text-gray"
                                                                        v-cloak>{{ message.text }}</span>
                                                                </div>
                                                                <div class="item" v-show="messages.length > 0"
                                                                    key="merku-statuses-alt" v-cloak>
                                                                    <article class="media">
                                                                        <figure class="media-left">
                                                                            <span class="image is-24x24">
                                                                                <img class="is-rounded"
                                                                                    src="/images/Merku.png"
                                                                                    alt="メルクちゃん">
                                                                            </span>
                                                                        </figure>
                                                                        <div class="media-content">
                                                                            <div class="content has-text-left">
                                                                                <span
                                                                                    class="is-size-6 has-text-weight-bold has-text-gray">ミルヒちゃんねるのニュースだよぉ</span>
                                                                            </div>
                                                                        </div>
                                                                    </article>
                                                                </div>
                                                                <div class="item" v-for="message in messages"
                                                                    v-bind:key="message.id + '-alt'">
                                                                    <span
                                                                        class="is-size-6 has-text-weight-bold has-text-gray"
                                                                        v-cloak>{{ message.text }}</span>
                                                                </div>
                                                            </transition-group>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </nav>
                                    </div>
                                </div>
                            </div>-->
                        </div>
                    </div>
                    <div class="columns">
                        <div class="column is-half is-mobile">
                            <div class="control has-text-centered">
                                <transition name="reveal">
                                    <!--<nav class="level">
                                        <div class="level-item has-text-centered">
                                            <div class="field is-grouped is-vcentered">
                                                <span class="icon is-small">
                                                    <i class="fas fa-star"></i>
                                                </span>
                                                <span class="title is-size-4"
                                                    v-bind:class="{'is-invisible': words === -1}">{{ likes }}</span>
                                            </div>
                                        </div>
                                    </nav>
                                    <nav class="level">
                                        <div class="level-item has-text-centered">
                                            <div class="field">
                                                <h6 class="subtitle is-size-6 is-uppercase has-text-weight-bold">いいね
                                                </h6>
                                            </div>
                                        </div>
                                    </nav>-->
                                    <nav class="level" v-if="isRevealed" v-cloak>
                                        <div class="level-item">
                                            <article class="media">
                                                <figure class="media-content">
                                                    <p class="image is-64x64">
                                                        <img class="is-rounded" src="/images/Milch.png" alt="ミルヒちゃん">
                                                    </p>
                                                </figure>
                                            </article>
                                        </div>
                                        <!--<div class="level-item">
                                            <article class="media">
                                                <figure class="media-content">
                                                    <p class="image">
                                                        <img src="/images/Logo.png"
                                                            srcset="/images/Logo.png 1x, /images/Logo@2x.png 2x, /images/Logo@3x.png 3x"
                                                            alt="milchchan.com">
                                                    </p>
                                                </figure>
                                            </article>
                                        </div>-->
                                        <div class="level-item">
                                            <article class="media">
                                                <div class="media-content">
                                                    <div class="content">
                                                        <h1
                                                            class="is-size-1 is-uppercase has-text-weight-bold has-text-black">
                                                            #milchchan</h1>
                                                        <h2 class="is-size-6 has-text-weight-bold has-text-black">
                                                            milchchan.com</h2>
                                                        <hr>
                                                    </div>
                                                </div>
                                            </article>
                                        </div>
                                        <!--<div class="level-item">
                                            <article class="media">
                                                <div class="media-content">
                                                    <p class="content is-size-6 has-text-weight-bold has-text-black">
                                                        
                                                    </p>
                                                </div>
                                            </article>
                                        </div>-->
                                        <div class="level-item">
                                            <div class="level is-mobile">
                                                <div class="level-item">
                                                    <a href="https://twitter.com/milchchan"><span
                                                            class="icon is-small has-text-black"><i
                                                                class="fab fa-twitter"></i></span></a>
                                                </div>
                                                <div class="level-item">
                                                    <a href="https://instagram.com/milchchan"><span
                                                            class="icon is-small has-text-black"><i
                                                                class="fab fa-instagram"></i></span></a>
                                                </div>
                                                <div class="level-item">
                                                    <a href="https://github.com/milchchan"><span
                                                            class="icon is-small has-text-black"><i
                                                                class="fab fa-github"></i></span></a>
                                                </div>
                                            </div>
                                        </div>
                                        <transition name="fade" mode="out-in">
                                            <div class="level-item" v-if="isUpdating" key="updating">
                                                <span class="has-text-black">
                                                    <i class="fas fa-spinner updating"></i>
                                                </span>
                                            </div>
                                            <div class="level-item" v-else key="updated">
                                                <!--<div class="tags are-normal field is-grouped is-grouped-multiline is-hidden">
                                                <div class="control">
                                                    <div class="tags has-addons">
                                                        <span class="tag is-white"><a class="has-text-black"
                                                                href="https://www.microsoft.com/store/apps/9WZDNCRDT09Q">Apricot</a></span>
                                                        <span class="tag is-black">Windows</span>
                                                    </div>
                                                </div>
                                                <div class="control">
                                                    <div class="tags has-addons">
                                                        <span class="tag is-white"><a class="has-text-black"
                                                                href="https://clock.milchchan.com/">Clock</a></span>
                                                        <span class="tag is-black">Web</span>
                                                    </div>
                                                </div>
                                                <div class="control">
                                                    <div class="tags has-addons">
                                                        <span class="tag is-white"><a class="has-text-black"
                                                                href="https://apps.apple.com/jp/app/id1130755997">Wonderland</a></span>
                                                        <span class="tag is-black">iOS</span>
                                                    </div>
                                                </div>
                                            </div>-->
                                                <div class="tags are-medium field is-grouped is-grouped-multiline">
                                                    <div class="control" v-for="tag in tags" v-bind:key="tag.index">
                                                        <div class="tags has-addons">
                                                            <button
                                                                class="button tag is-rounded is-size-7 has-text-weight-bold"
                                                                type="button"
                                                                v-bind:style="{ color: 'rgba(0, 0, 0, ' + (0.25 + 0.75 * tag.score) + ')' }"
                                                                @click="learn(tag.name); isRevealed = false;">{{ tag.name }}</button>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </transition>
                                    </nav>
                                    <!--<nav class="level">
                                        <div class="level-item">
                                            <span class="has-text-black">
                                                <button class="button is-white is-rounded"
                                                    v-bind:class="{'is-selected': isOverlayed, 'is-info': isOverlayed}"
                                                    @click="isOverlayed = !isOverlayed"><span class="icon is-small">
                                                        <i class="fas fa-comments"></i>
                                                    </span></button>
                                            </span>
                                        </div>
                                    </nav>-->
                                </transition>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </nav>
        <div id="container" ref="container">
            <transition name="fade">
                <div class="columns is-desktop" v-if="word">
                    <div class="column is-half has-content-centered">
                        <article class="media" v-cloak>
                            <figure class="media-left">
                                <p class="image is-64x64">
                                    <img class="is-rounded" v-bind:src="character.image" v-bind:alt="character.name"
                                        v-cloak>
                                </p>
                            </figure>
                            <div class="media-content">
                                <div class="content has-text-left">
                                    <div class="balloon" v-bind:style="{ backgroundColor: character.accent }" v-cloak>
                                        <p class="has-text-weight-bold has-text-white" v-cloak>
                                            {{ word.name }}
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </article>
                        <article class="media">
                            <div class="media-content">
                                <div class="content">
                                    <div class="columns is-mobile is-gapless" v-for="row in arrange(word.attributes, 2)"
                                        v-cloak>
                                        <div class="column is-half" v-for="column in row" v-bind:key="column.name"
                                            v-cloak>
                                            <div class="field">
                                                <label class="checkbox">
                                                    <input type="checkbox" v-bind:data-word="word.name"
                                                        v-bind:data-attribute="column.name" @change="check"
                                                        v-model="column.value">
                                                    <span class="custom"></span>
                                                    <span
                                                        class="title is-size-6 has-text-weight-bold has-text-black">{{ column.name }}</span>
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <nav class="level">
                                    <div class="level-item">
                                        <button class="button is-white" type="button" @click="word = null" v-cloak>
                                            <span class="icon is-small">
                                                <i class="fas fa-times"></i>
                                            </span>
                                        </button>
                                    </div>
                                </nav>
                            </div>
                        </article>
                    </div>
                </div>
            </transition>
        </div>
        <!--
        <transition name="collapse">
            <transition-group id="container" name="message-list" tag="div" v-show="isOverlayed && !isSuggested">
                <div class="columns is-desktop is-invisible" v-for="message in messages" v-bind:key="message.id">
                    <div class="column is-half has-content-centered">
                        <hr class="is-invisible">
                        <article class="media" v-if="user.uid === message.user.id" v-cloak>
                            <div class="media-content">
                                <div class="content has-text-right">
                                    <div class="balloon" v-bind:style="{ color: message.user.accent }">
                                        <p class="has-text-weight-bold">
                                            {{ message.text }}
                                        </p>
                                    </div>
                                    <div>
                                        <p class="is-size-7 has-text-weight-normal has-text-grey">
                                            {{ formatDate(message.timestamp) }}
                                        </p>
                                    </div>
                                </div>
                            </div>
                            <figure class="media-right" v-if="message.user.image">
                                <p class="image is-64x64">
                                    <img class="is-rounded" v-bind:src="message.user.image"
                                        v-bind:alt="message.user.name ? message.user.name : message.id">
                                </p>
                            </figure>
                        </article>
                        <article class="media" v-else v-cloak>
                            <figure class="media-left" v-if="message.user.image">
                                <p class="image is-64x64">
                                    <img class="is-rounded" v-bind:src="message.user.image"
                                        v-bind:alt="message.user.name ? message.user.name : message.id">
                                </p>
                            </figure>
                            <div class="media-content">
                                <div class="content has-text-left">
                                    <div class="balloon" v-bind:style="{ color: message.user.accent }">
                                        <p class="has-text-weight-bold">
                                            <span v-bind:class="{'is-hidden': message.text}">
                                                <i class="fas fa-spinner updating"></i>
                                            </span>
                                            {{ message.text }}
                                        </p>
                                    </div>
                                    <div>
                                        <p class="is-size-7 has-text-weight-normal has-text-grey">
                                            {{ formatDate(message.timestamp) }}</p>
                                    </div>
                                </div>
                            </div>
                        </article>
                    </div>
                </div>
            </transition-group>
        </transition>-->
        <transition name="popup" v-on:before-enter="animationStart" v-on:after-enter="animationEnd"
            v-on:enter-cancelled="animationEnd" v-on:before-leave="animationStart" v-on:after-leave="animationEnd"
            v-on:leave-cancelled="animationEnd">
            <nav id="popup" class="navbar is-fixed-bottom" v-show="isPopup" v-cloak>
                <div class=" navbar-item is-expanded columns is-desktop">
                    <div class="column is-half has-content-centered is-mobile">
                        <div class="control">
                            <nav class="level is-mobile" v-if="character !== null">
                                <article class="media" v-bind:style="{ backgroundColor: character.accent }">
                                    <figure class="media-left">
                                        <span class="image is-24x24">
                                            <img class="is-rounded" v-bind:src="character.image"
                                                v-bind:alt="character.name" v-cloak>
                                        </span>
                                    </figure>
                                    <div class="media-content">
                                        <div class="content has-text-left">
                                            <span class="is-size-6 has-text-weight-bold has-text-white" v-cloak>
                                                {{ character.name }}
                                            </span>
                                        </div>
                                    </div>
                                </article>
                            </nav>
                            <nav class="level">
                                <article class="media">
                                    <div class="media-content"
                                        v-bind:style="{ height: animatedPopupTextHeight + 'px' }">
                                        <div class="content has-text-left" ref="popupText">
                                            <span class="title is-4 has-text-weight-bold has-text-white"
                                                v-bind:class="{ break: character.value == '\n' }"
                                                v-for="character in text" v-bind:key="character.key"
                                                v-cloak>{{ character.value }}</span>
                                        </div>
                                    </div>
                                </article>
                            </nav>
                        </div>
                    </div>
                </div>
            </nav>
        </transition>
        <nav id="input" class="navbar is-fixed-bottom" role="navigation">
            <div class=" navbar-item is-expanded columns is-desktop">
                <div class="column is-half has-content-centered is-mobile">
                    <transition-group name="notification-list" class="control" tag="div" v-cloak>
                        <nav class="level" v-for="notification in notifications" v-bind:key="notification.id">
                            <div class="notification is-info is-light" v-cloak>
                                <article class="media" v-bind:style="{ backgroundColor: notification.accent }" v-cloak>
                                    <figure class="media-left" v-if="notification.image" v-cloak>
                                        <span class="image is-24x24">
                                            <img class="is-rounded" v-bind:src="notification.image" alt="Avatar"
                                                v-cloak>
                                        </span>
                                    </figure>
                                    <div class="media-content" v-cloak>
                                        <div class="content has-text-left">
                                            <span class="has-text-weight-bold has-text-white" v-cloak>
                                                {{ notification.text }}
                                            </span>
                                        </div>
                                    </div>
                                </article>
                            </div>
                        </nav>
                    </transition-group>
                    <div class="control">
                        <transition name="fade">
                            <nav class="level" v-show="isExpanded">
                                <div class="level-left">
                                    <div class="level-item">
                                        <div class="field">
                                            <label class="checkbox" v-cloak>
                                                <input type="radio" name="mode" checked="checked"
                                                    @change="isLearning = true; isExpanded = false;">
                                                <span class="custom"></span>
                                                <span
                                                    class="title is-size-6 has-text-weight-bold has-text-black">言葉を教える</span>
                                            </label>
                                        </div>
                                    </div>
                                    <div class="level-item">
                                        <div class="field">
                                            <label class="checkbox" v-cloak>
                                                <input type="radio" name="mode"
                                                    @change="isLearning = false; isExpanded = false;">
                                                <span class="custom"></span>
                                                <span
                                                    class="title is-size-6 has-text-weight-bold has-text-black">ニュースを投稿</span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </nav>
                        </transition>
                        <nav class="level" ref="input">
                            <form onsubmit="return false;">
                                <div class="field has-addons">
                                    <div class="control">
                                        <transition name="fade" mode="out-in">
                                            <button class="button is-rounded" type="button"
                                                v-bind:disabled="user === null" @click="isExpanded = false"
                                                v-if="isExpanded" key="unexpand" v-cloak>
                                                <span class="icon is-small is-black">
                                                    <i class="fas fa-angle-down"></i>
                                                </span>
                                            </button>
                                            <button class="button is-white" type="button"
                                                v-bind:disabled="user === null" @click="isExpanded = true" v-else
                                                key="expand" v-cloak>
                                                <span class="icon is-small">
                                                    <i class="fas fa-angle-up"></i>
                                                </span>
                                            </button>
                                        </transition>
                                    </div>
                                    <div class="control is-expanded">
                                        <input class="input is-rounded" type="text"
                                            v-bind:class="{ 'is-danger': inputHasError }"
                                            v-bind:placeholder="isLearning ? '教える言葉' : '投稿するニュース'"
                                            v-bind:disabled="word !== null" v-model="input" @input="change" v-cloak>
                                    </div>
                                    <div class="control">
                                        <span class="is-size-7 has-text-weight-bold has-text-grey" v-cloak>
                                            {{ maxInputLength - animatedInputLength }}
                                        </span>
                                    </div>
                                    <div class="control">
                                        <button class="button is-rounded is-primary" type="submit"
                                            v-bind:class="{ 'is-loading': isLoading, 'is-static': word !== null }"
                                            v-bind:disabled="user === null" @click="send"><span class="icon is-small"
                                                v-cloak>
                                                <i class="fas fa-paper-plane"></i>
                                            </span>
                                        </button>
                                    </div>
                                </div>
                            </form>
                        </nav>
                    </div>
                </div>
            </div>
        </nav>
        <audio preload="auto" ref="alert">
            <source src="/sounds/float_001.mp3" type="audio/mpeg" />
            <source src="/sounds/float_001.wav" type="audio/wav" />
        </audio>
        <audio preload="auto" ref="twinkle">
            <source src="/sounds/plastic_up_hi.mp3" type="audio/mpeg" />
            <source src="/sounds/plastic_up_hi.wav" type="audio/wav" />
        </audio>
    </div>
    <!-- The core Firebase JS SDK is always required and must be listed first -->
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-database.js"></script>
    <!-- TODO: Add SDKs for Firebase products that you want to use
     https://firebase.google.com/docs/web/setup#available-libraries -->
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-analytics.js"></script>
    <script src="https://unpkg.com/three@0.121.1/build/three.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/stats-js@1.0.1/build/stats.min.js"></script>
    <!--<script src="https://unpkg.com/vue@next"></script>-->
    <script src="https://unpkg.com/vue@3.0.2/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
    <script src="/js/moment-with-locales.js"></script>
    <script src="/js/three-vrm.js"></script>
    <script src="/js/particles.js"></script>
    <script src="/js/tiny-segmenter.js"></script>
    <script type="module">
        import { GLTFLoader } from 'https://unpkg.com/three@0.121.1/examples/jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';

        // Your web app's Firebase configuration
        var firebaseConfig = {
            apiKey: "AIzaSyDTVxDJj7rqG9L-Clvba2Tao9B0hkcxjcE",
            authDomain: "milchchan.firebaseapp.com",
            databaseURL: "https://milchchan.firebaseio.com",
            projectId: "milchchan",
            storageBucket: "milchchan.appspot.com",
            messagingSenderId: "355698971889",
            appId: "1:355698971889:web:e3653c5c31bd7289cd4550",
            measurementId: "G-3998FJYNWX"
        };
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        firebase.analytics();

        const debug = getParameterByName("debug") || false;
        const channel = decodeURIComponent(window.location.hash.substring(1));
        const databaseRoot = 'bot';
        const databaseChannel = channel.length > 0 ? databaseRoot + '/channels/' + channel : databaseRoot;
        const databaseMessages = databaseChannel + '/feed';
        let database = firebase.database();
        const milch = { name: 'ミルヒちゃん', accent: '#ffa6bb', image: '/images/Milch.png' };
        const merku = { name: 'メルクちゃん', accent: '#5bcbe1', image: '/images/Merku.png' };

        //databaseRoot.remove();

        /*databaseRoot.remove().orderByChild('timestamp')
            .startAt(1).limitToFirst(2)
            .once('value', function (snapshot) { console.log(snapshot.val()) })*/

        function random(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);

            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function getParameterByName(name) {
            name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");

            var regex = new RegExp("[\\?&]" + name + "=([^&#]*)");
            var results = regex.exec(window.location.href);

            if (results == null) {
                return null;
            }

            return decodeURIComponent(results[1].replace(/\+/g, " "));
        }

        document.title = channel.length === 0 ? 'ミルヒちゃんねる' : '#' + channel;

        //var channel = getParameterByName("channel") || getParameterByName("ch") || "";

        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });

        renderer.setSize(window.innerWidth, window.outerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0xffffff, 0);

        if (channel.length > 0) {
            renderer.domElement.classList.add("is-hidden");
        }

        const CAMERA_FOV = 60.0;
        const CAMERA_Z = 1.0;
        const camera = new THREE.PerspectiveCamera(CAMERA_FOV, window.innerWidth / window.outerHeight, 0.1, 1000);

        camera.position.set(0.0, 1.25, CAMERA_Z);

        const controls = new OrbitControls(camera, renderer.domElement);

        //controls.enabled = false;
        controls.enableKeys = false;
        controls.screenSpacePanning = true;
        controls.enableDamping = true;
        /*controls.minPolarAngle = 30 * Math.PI / 180;
        controls.maxPolarAngle = 150 * Math.PI / 180;
        controls.minAzimuthAngle = -45 * Math.PI / 180;
        controls.maxAzimuthAngle = 45 * Math.PI / 180;*/
        controls.minDistance = 0.75;
        controls.maxDistance = 1.5;
        controls.target.set(0.0, 0.95, 0.025);
        controls.update();

        const scene = new THREE.Scene();
        const light = new THREE.DirectionalLight(0xffffff);

        light.intensity = 1;
        light.position.set(0.0, 10.0, 10.0).normalize();

        scene.add(light);
        //scene.add(new THREE.GridHelper(10, 10));
        //scene.add(new THREE.AxesHelper(5));

        const lookAtTarget = new THREE.Object3D();

        camera.add(lookAtTarget);

        const stats = new Stats();

        stats.domElement.style.position = "fixed";
        stats.domElement.style.top = "auto";
        stats.domElement.style.bottom = "0";

        if (!debug) {
            stats.domElement.classList.add("is-hidden");
        }

        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let vrmModel = null;
        let animationIndex = 0;
        const animationSkipFrames = 2;
        let idleTime = 0.0;
        const blinkThreshold = 5.0;
        let waitTime = 0.0;
        const waitThreshold = 1.0;
        let activateTime = 0.0;
        const activateThreshold = 10.0;
        let alertTime = 0.0;
        const alertThreshold = 30.0;
        let lookAnimation = null;
        let timeoutID = undefined;

        var app = Vue.createApp({
            data() {
                return {
                    isReady: false,
                    isLoading: false,
                    isRevealed: false,
                    isUpdating: false,
                    isBlinded: false,
                    isOverlayed: true,
                    isSuggested: false,
                    isPopup: false,
                    isExpanded: false,
                    isLearning: true,
                    isAnimating: false,
                    feedQueue: [],
                    suggestionQueue: [],
                    sequenceQueue: [],
                    progress: 0,
                    user: null,
                    input: "",
                    animatedInputLength: 0,
                    maxInputLength: 100,
                    inputHasError: false,
                    messages: [],
                    maxMessages: 10,
                    word: null,
                    words: [],
                    tags: [],
                    maxTags: 10,
                    scrollTimeoutID: undefined,
                    isScrolling: false,
                    stars: -1,
                    animatedStars: 0,
                    notifications: [],
                    presetImages: null,
                    backgroundImages: [],
                    preloadImages: [],
                    animations: null,
                    currentAnimations: [],
                    blendShapeAnimations: [],
                    highlight: null,
                    cover: null,
                    isPreloading: false,
                    isComputing: false,
                    text: [],
                    popupTextHeight: 0,
                    animatedPopupTextHeight: 0,
                    message: null,
                    states: {},
                    character: null,
                    attributes: ["名前", "所属", "時間", "場所", "する事", "生き物", "食べ物", "飲み物", "聞くもの", "見るもの", "読むもの", "使う物", "身につけるもの", "乗り物", "部位", "病気"]
                }
            },
            watch: {
                messages: {
                    handler: () => {
                        app.$nextTick(() => {
                            /*let width = 0;

                            for (const element of document.body.querySelectorAll("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker .item")) {
                                width += element.getBoundingClientRect().width;
                            }

                            document.body.querySelector("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker").style.width = width + 'px';
                            document.body.querySelector("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker").animate([
                                {
                                    transform: "translate3d(0, 0, 0)"
                                },
                                {
                                    transform: "translate3d(-" + width / 2 + "px, 0, 0)"
                                }
                            ], {
                                duration: 30000,
                                iterations: Infinity
                            });*/

                            //app.scrollToEnd();
                        });
                    },
                    deep: true
                },
                words: {
                    handler: () => {
                        app.$nextTick(() => {
                            let width = 0;

                            for (const element of document.body.querySelectorAll(".background .ticker-wrap .ticker .item")) {
                                width += element.getBoundingClientRect().width;
                            }

                            document.body.querySelector(".background .ticker-wrap .ticker").style.width = width + 'px';
                            document.body.querySelector(".background .ticker-wrap .ticker").animate([
                                {
                                    transform: "translate3d(0, 0, 0)"
                                },
                                {
                                    transform: "translate3d(-" + width / 2 + "px, 0, 0)"
                                }
                            ], {
                                duration: 5 * 60 * 1000,
                                iterations: Infinity
                            });
                        });
                    },
                    deep: true
                },
                backgroundImages: {
                    handler: () => {
                        app.$nextTick(() => {
                            const elements = document.body.querySelectorAll("#app>.background>div");
                            const offset = elements.length - 1;
                            const frameRate = 15;

                            for (const element of elements) {
                                element.animate([
                                    {
                                        transform: "translate3d(0, 0, 0)"
                                    },
                                    {
                                        transform: "translate3d(-" + offset * 100 + "%, 0, 0)"
                                    }
                                ], {
                                    fill: 'forwards',
                                    easing: 'steps(' + offset + ')',
                                    duration: 1000 / frameRate * elements.length,
                                    iterations: Infinity
                                });
                            }
                        });
                    },
                    deep: true
                },
                text: {
                    handler: () => {
                        app.$nextTick(() => {
                            app.popupTextHeight = app.$refs.popupText.getBoundingClientRect().height;
                        });
                    },
                    deep: true
                },
                popupTextHeight(newValue) {
                    const obj = { height: this.animatedPopupTextHeight };

                    anime({
                        targets: obj,
                        height: newValue,
                        round: 1,
                        duration: 500,
                        easing: 'linear',
                        update: () => {
                            this.animatedPopupTextHeight = obj.height
                        }
                    });
                },
                stars(newValue) {
                    const obj = { count: this.animatedStars };

                    anime({
                        targets: obj,
                        count: newValue,
                        round: 1,
                        duration: 500,
                        easing: 'linear',
                        update: () => {
                            this.animatedStars = obj.count
                        }
                    });
                },
                input: {
                    handler: () => {
                        app.$nextTick(() => {
                            const obj = { count: app.animatedInputLength };

                            anime({
                                targets: obj,
                                count: app.input.length,
                                round: 1,
                                duration: 500,
                                easing: 'linear',
                                update: () => {
                                    app.animatedInputLength = obj.count
                                }
                            });
                        });
                    },
                    deep: true
                }
            },
            methods: {
                send: async function (event) {
                    if (this.input.length > 0 && this.input.length <= this.maxInputLength) {
                        if (this.isLearning) {
                            this.learn(this.input);
                            this.input = "";
                        } else if (confirm(this.input)) {
                            function format(format) {
                                var args = arguments;

                                return format.replace(/\{(\d)\}/g, function (m, c) { return args[parseInt(c) + 1] });
                            }

                            function shuffle(array) {
                                function _random(min, max) {
                                    min = Math.ceil(min);
                                    max = Math.floor(max);

                                    return Math.floor(Math.random() * (max - min)) + min;
                                }

                                let a = [].concat(array);
                                let n = array.length;

                                while (n > 1) {
                                    const k = _random(0, n);

                                    n--;

                                    const temp = a[n];

                                    a[n] = a[k];
                                    a[k] = temp;
                                }

                                return a;
                            }

                            let segmenter = new TinySegmenter();
                            let tokens = segmenter.segment(this.input).sort((x, y) => y.length - x.length);

                            database.ref(databaseMessages).push({ text: this.input, timestamp: Math.floor(new Date() / 1000), user: { id: app.user.uid, name: null, accent: null, image: null } });

                            this.input = "";
                            this.$refs.alert.play();

                            if (tokens.length > 5) {
                                tokens.splice(5);
                            }

                            for (const token of shuffle(tokens)) {
                                let snapshot = await database.ref(databaseRoot + "/dictionary/words/" + token).once('value');

                                if (!snapshot.exists()) {
                                    this.learn(token);

                                    break;
                                }
                            }
                        }

                        return;

                        const url = "https://api.milchchan.com/talk?text=" + text + "&threshold=1.0";
                        //let segmenter = new TinySegmenter();
                        let regex = new RegExp('[.#$\\[\\]]');
                        //let tokens = [];

                        /*for (let token of segmenter.segment(text)) {
                            if (!regex.test(token)) {
                                tokens.push(token);
                            }
                        }*/

                        this.input = '';

                        document.body.querySelector("#alert").play();

                        let completed = 0;
                        let learnedWords = [];

                        database.ref(databaseMessages).push({ text: text, timestamp: Math.floor(new Date() / 1000), user: { id: app.user.uid, name: null, accent: null, image: null } });

                        /*for (let token of tokens) {
                            database.ref(databaseRoot + "/dictionary/words/" + token).transaction(function (word) {
                                if (word === null) {
                                    return ref.key;
                                }

                                return;
                            }, function (error, committed, snapshot) {
                                if (committed) {
                                    learnedWords.push(token);

                                    database.ref(databaseRoot + "/dictionary/count").transaction(function (count) {
                                        return (count || 0) + 1;
                                    });
                                } else if (error) {
                                    console.error(error);
                                }

                                completed++;

                                if (completed == tokens.length && learnedWords.length > 0) {
                                    for (let i = 0; i < learnedWords.length; i++) {
                                        window.setTimeout(function () {
                                            app.notify({ text: format(channel.length == 0 ? '「{0}」をおぼえたよぉ' : '「{0}」をおぼえたよ', learnedWords[i]), accent: merku.accent, image: channel.length == 0 ? merku.image : null });
                                        }, (i + 1) * 500);
                                    }

                                    window.pJSDom[0].pJS.fn.modes.pushParticles(learnedWords.length);
                                }
                            });
                        }*/

                        window.setTimeout(async () => {
                            let ref = database.ref(databaseMessages).push();

                            app.messages.push({ id: ref.key, text: null, timestamp: new Date(), user: { id: null, name: milch.name, accent: milch.accent, image: milch.image } });

                            try {
                                app.isLoading = true;

                                const response = await fetch(encodeURI(url), {
                                    mode: "cors",
                                    method: "GET",
                                    headers: {
                                        "Content-Type": "application/x-www-form-urlencoded"
                                    }
                                });

                                if (response.ok) {
                                    const json = await response.json();

                                    if (json.text.length > 0) {
                                        ref.set({ text: json.text, timestamp: Math.floor(new Date() / 1000), thread: ref.key, user: { id: null, name: milch.name, accent: milch.accent, image: milch.image } });
                                    }
                                }
                                else {
                                    throw new Error(response.statusText);
                                }

                                app.isLoading = false;
                            }
                            catch (e) {
                                app.isLoading = false;
                                app.notify({ text: channel.length == 0 ? 'もう一度試してほしいよぉ' : 'もう一度試してみてね', accent: merku.accent, image: channel.length == 0 ? merku.image : null });

                                console.error(e.message);
                            }


                        }, random(500, 1000));
                    }
                },
                change: function (event) {
                    if (this.input.length <= this.maxInputLength) {
                        this.inputHasError = false;
                    } else {
                        this.inputHasError = true;
                    }
                },
                like: function () {
                    if (this.isSuggested) {
                        if (this.suggestionQueue.length > 0) {
                            this.suggestionQueue[0].messages[0].type.reverse = true;
                            this.isBlinded = true;
                        } else {
                            this.isBlinded = false;
                        }

                        this.isSuggested = false;
                    } else {
                        this.suggestionQueue.splice(0);
                        this.isBlinded = true;
                        this.isSuggested = true;
                        this.$refs.twinkle.play();
                    }

                    return;
                    /*if (this.isLearning) {
                        this.messages.push({ id: this.messages.length, text: 'また今度教えてね', tint: merku.tint, avatar: merku.avatar, author: merku.name, timestamp: new Date() });
                        this.isLearning = false;
                    } else {
                        this.messages.push({ id: this.messages.length, text: '最初にミルヒちゃんに送るメッセージを教えて欲しいよぉ', tint: merku.tint, avatar: merku.avatar, author: merku.name, timestamp: new Date() });
                        this.isLearning = true;
                    }
                    */

                    database.ref(databaseChannel + "/likes").transaction(function (count) {
                        return (count || 0) + 1;
                    });

                    window.pJSDom[0].pJS.fn.modes.pushParticles(1);

                    //this.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }]);

                    /*database.ref(databaseChannel + "likes").once('value', snapshot => {
                        const count = snapshot.val();
            
                        if (count === null) {
                            database.ref(databaseChannel + "likes").update({ 'likes': 1 })
                        }
                        else {
                            database.ref(databaseChannel).update({ 'likes': count + 1 })
                        }
                    });*/

                    document.body.querySelector("#twinkle").play();
                },
                check: function (event) {
                    function format(format) {
                        var args = arguments;

                        return format.replace(/\{(\d)\}/g, function (m, c) { return args[parseInt(c) + 1] });
                    }

                    let self = this;
                    const timestamp = Math.floor(new Date() / 1000);
                    const isChecked = event.target.checked;
                    const attribute = event.target.dataset.attribute;

                    database.ref(databaseRoot + "/words/" + event.target.dataset.word).transaction(function (current) {
                        if (!current) {
                            current = {};

                            for (const a of self.attributes) {
                                if (a != attribute) {
                                    current[a] = false;
                                }
                            }
                        }

                        current[attribute] = isChecked;
                        current["timestamp"] = timestamp;

                        return current;
                    }, function (error, committed, snapshot) {
                        if (committed) {
                            const dictionary = snapshot.val();
                            let checked = 0;

                            for (const key in dictionary) {
                                if (typeof dictionary[key] === "boolean" && dictionary[key]) {
                                    checked++;
                                }
                            }

                            if (checked == 0) {
                                database.ref(databaseRoot + "/stars").transaction(function (count) {
                                    if (count) {
                                        return count - 1;
                                    }

                                    return undefined;
                                });
                            }
                            else if (checked == 1) {
                                database.ref(databaseRoot + "/stars").transaction(function (count) {
                                    return (count || 0) + 1;
                                });

                                self.notify({ text: format(channel.length == 0 ? '「{0}」をおぼえたよぉ' : '「{0}」をおぼえたよ', snapshot.key), accent: merku.accent, image: channel.length == 0 ? merku.image : null });
                                self.$refs.twinkle.play();
                            }

                            self.word = null;
                        } else if (error) {
                            console.error(error);
                        }
                    });

                    return;

                    if (index > 0) {

                    } else {
                        database.ref(databaseRoot + "/dictionary/words/" + this.input).transaction(function (current) {
                            return null;
                        }, function (error, committed, snapshot) {
                            if (committed) {
                                /*database.ref(databaseRoot + "/vocabularies").transaction(function (count) {
                                    if (count) {
                                        count -= 1;

                                        if (count > 0) {
                                            return count;
                                        } else {
                                            return null;
                                        }
                                    }

                                    return;
                                });*/
                            } else if (error) {
                                console.error(error);
                            }
                        });
                    }
                },
                learn: async function (term) {
                    function format(format) {
                        var args = arguments;

                        return format.replace(/\{(\d)\}/g, function (m, c) { return args[parseInt(c) + 1] });
                    }

                    let attributes = [];

                    for (const attribute of this.attributes) {
                        attributes.push({ name: attribute, value: false });
                    }

                    const snapshot = await database.ref(databaseRoot + "/words/" + term).once('value');
                    let sequences = [];
                    let sequence = [];

                    if (snapshot.exists()) {
                        const word = snapshot.val();

                        for (let attribute of attributes) {
                            if (attribute.name in word) {
                                attribute.value = word[attribute.name];
                            }
                        }
                    }

                    this.word = { name: term, attributes: attributes };

                    for (const sequence of this.character.sequences) {
                        if (sequence.name == "Learn") {
                            sequences.push(sequence);
                        }
                    }

                    for (const obj of this.prepare(sequences)) {
                        if (obj.type == "Message") {
                            sequence.push({ type: obj.type, speed: obj.speed, duration: obj.duration, text: format(obj.text, term) });
                        } else {
                            sequence.push(obj);
                        }
                    }

                    if (sequence.length > 0) {
                        this.sequenceQueue.push(sequence);
                    }
                },
                talk: async function () {
                    function generateUuid() {
                        // https://github.com/GoogleChrome/chrome-platform-analytics/blob/master/src/internal/identifier.js
                        // const FORMAT: string = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
                        let chars = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".split("");

                        for (let i = 0, len = chars.length; i < len; i++) {
                            switch (chars[i]) {
                                case "x":
                                    chars[i] = Math.floor(Math.random() * 16).toString(16);
                                    break;
                                case "y":
                                    chars[i] = (Math.floor(Math.random() * 4) + 8).toString(16);
                                    break;
                            }
                        }

                        return chars.join("");
                    }

                    let sequences = [];
                    let sequence = [];

                    for (const sequence of this.character.sequences) {
                        if (sequence.name == "Activate") {
                            sequences.push(sequence);
                        }
                    }

                    for (const obj of this.prepare(sequences)) {
                        if (obj.type == "Message") {
                            let text;
                            let cache;

                            [text, cache] = await this.generate(obj.text);

                            sequence.push({ type: obj.type, speed: obj.speed, duration: obj.duration, text: text });
                        } else {
                            sequence.push(obj);
                        }
                    }

                    /*const presets = [{ animation: 'idle2', name: THREE.VRMSchema.BlendShapePresetName.Fun },
                    { animation: 'jump', name: THREE.VRMSchema.BlendShapePresetName.Joy },
                    { animation: 'win', name: THREE.VRMSchema.BlendShapePresetName.Joy },
                    { animation: 'lose', name: THREE.VRMSchema.BlendShapePresetName.Sorrow }];
                    const item = presets[random(0, 3)];*/

                    if (sequence.length > 0) {
                        this.sequenceQueue.push(sequence);
                    }
                    //{ messages: [{ time: 0, duration: 5, type: { elapsed: -1, speed: 50, reverse: false, buffer: '', count: 0 }, text: generatedText }], animation: item.animation, morphs: { animations: [{ name: item.name, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }], defaults: [{ name: THREE.VRMSchema.BlendShapePresetName.Joy, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Sorrow, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Fun, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Blink, weight: 0.0 }] } });

                    /*this.messages.push({ id: generateUuid(), text: generatedText, timestamp: new Date(), user: { id: null, name: milch.name, accent: milch.accent, image: milch.image } });

                    if (this.messages.length > this.maxMessages) {
                        this.messages.shift();
                    }*/
                },
                generate: async function (message) {
                    function choice(probabilities) {
                        const r = Math.random();
                        let sum = 0.0;
                        let index = 0;

                        for (let probability of probabilities) {
                            if (sum <= r && r < sum + probability) {
                                break;
                            }

                            sum += probability;
                            index++;
                        }

                        return index;
                    }

                    function softmax(x) {
                        let y = [];
                        let max = Number.MIN_VALUE;
                        let sum = 0.0;

                        for (let i = 0; i < x.length; i++) {
                            if (x[i] > max) {
                                max = x[i];
                            }
                        }

                        for (let i = 0; i < x.length; i++) {
                            sum += Math.exp(x[i] - max);
                        }

                        for (let i = 0; i < x.length; i++) {
                            y.push(Math.exp(x[i] - max) / sum);
                        }

                        return y;
                    }

                    let segmenter = new TinySegmenter();
                    let tokens = segmenter.segment(message);
                    let tokenSet = [];
                    let regex = new RegExp('[.#$\\[\\]]');
                    let cachDictionary = {};
                    let text = '';
                    let index = 0;
                    const epsilon = Math.pow(10, -6);
                    const beamWidth = 10;
                    let sequences = [{ sequence: [], score: 1.0 }]

                    for (const token of tokens) {
                        if (!tokenSet.includes(token)) {
                            if (!regex.test(token)) {
                                let terms = [];
                                let scores = [];
                                const snapshot1 = await database.ref(databaseRoot + "/words/" + token).once('value');

                                if (snapshot1.exists()) {
                                    const word = snapshot1.val();

                                    for (let attribute in word) {
                                        if (word[attribute]) {
                                            const snapshot2 = await database.ref(databaseRoot + "/words/").orderByChild(attribute).equalTo(true).once('value');

                                            if (snapshot2.exists()) {
                                                const words = snapshot2.val();

                                                for (let key in words) {
                                                    if (!terms.includes(key)) {
                                                        let isNew = true;

                                                        terms.push(key);

                                                        for (const tag of this.tags) {
                                                            if (key == tag.name) {
                                                                scores.push(tag.score);
                                                                isNew = false;

                                                                break;
                                                            }
                                                        }

                                                        if (isNew) {
                                                            scores.push(epsilon);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                if (terms.length > 0) {
                                    const probabilities = softmax(scores);
                                    let candidates = [];

                                    for (let i = 0; i < sequences.length; i++) {
                                        for (let j = 0; j < probabilities.length; j++) {
                                            let sequence = [].concat(sequences[i].sequence);

                                            sequence.push({ index: index, term: terms[j] });
                                            candidates.push({ sequence: sequence, score: sequences[i].score * probabilities[j] });
                                        }
                                    }

                                    sequences.splice(0);

                                    for (const candidate of this.take(candidates.sort((x, y) => y.score - x.score), beamWidth)) {
                                        sequences.push(candidate);
                                    }
                                }
                            }

                            tokenSet.push(token);
                        }

                        index++;
                    }

                    const s = sequences[choice(sequences.map(x => x.score))];

                    for (let i = 0; i < tokens.length; i++) {
                        if (tokens[i] in cachDictionary) {
                            if (typeof cachDictionary[tokens[i]] === "undefined") {
                                text += tokens[i];
                            } else {
                                text += cachDictionary[tokens[i]]
                            }
                        } else {
                            let isNew = true;

                            for (let j = 0; j < s.sequence.length; j++) {
                                if (s.sequence[j].index == i) {
                                    if (tokens[i] == s.sequence[j].term) {
                                        cachDictionary[tokens[i]] = undefined;
                                    } else {
                                        cachDictionary[tokens[i]] = s.sequence[j].term;
                                        text += s.sequence[j].term;
                                        isNew = false;
                                    }

                                    break;
                                }
                            }

                            if (isNew) {
                                text += tokens[i];
                            }
                        }
                    }

                    return [text, cachDictionary];
                },
                notify: function (data) {
                    let id = -1;

                    for (const notification of this.notifications) {
                        if (notification.id > id) {
                            id = notification.id;
                        }
                    }

                    id++;
                    data['id'] = id;

                    this.notifications.push(data);

                    window.setTimeout(async function () {
                        for (let i = 0; i < app.notifications.length; i++) {
                            if (app.notifications[i].id == id) {
                                app.notifications.splice(i, 1);

                                break;
                            }
                        }
                    }, 3000);
                },
                blinded: async function () {
                    function _random(min, max) {
                        min = Math.ceil(min);
                        max = Math.floor(max);

                        return Math.floor(Math.random() * (max - min)) + min;
                    }

                    this.preloadImages.splice(0);
                    this.backgroundImages.splice(0);

                    for (const image of this.presetImages[_random(0, this.presetImages.length)]) {
                        this.preloadImages.push({
                            url: image
                        });
                    }

                    if (this.presetImages.length > 1) {
                        setTimeout(() => {
                            this.isBlinded = true;
                        }, 50000);
                    }
                },
                load: function (url) {
                    let isCompleted = true;

                    for (let image of this.preloadImages) {
                        if (image.url == url) {
                            image["isLoaded"] = true;
                        } else if (!("isLoaded" in image)) {
                            isCompleted = false;
                        }
                    }

                    if (isCompleted) {
                        let index = 0;

                        for (const image of this.preloadImages) {
                            if (image.isLoaded) {
                                this.backgroundImages.push({
                                    index: index,
                                    url: image.url
                                });

                                index++;
                            }
                        }

                        this.preloadImages.splice(0);
                        this.isBlinded = false;
                    }
                },
                error: function (url) {
                    let isCompleted = true;

                    for (let image of this.preloadImages) {
                        if (image.url == url) {
                            image["isLoaded"] = true;
                        } else if (!("isLoaded" in image)) {
                            isCompleted = false;
                        }
                    }

                    if (isCompleted) {
                        for (const image of this.preloadImages) {
                            if (image.isLoaded) {
                                this.backgroundImages.push(image.url);
                            }
                        }

                        this.preloadImages.splice(0);
                        this.isBlinded = false;
                    }
                },
                update: async function (data, max) {
                    this.isUpdating = true;

                    try {
                        const results = await new Promise(resolve => {
                            let segmenter = new TinySegmenter();
                            let documents = [];
                            let filteredDocuments = [];
                            let termFrequencies = [];
                            let inverseDocumentFrequency = {};
                            const baseTime = new Date().getTime() - 12 * 60 * 60 * 1000;
                            const limit = 10;
                            let scoreDictionary = {};
                            let scores = [];
                            let maxScore = 0.0;

                            for (const key in data) {
                                const tokens = segmenter.segment(data[key].text);

                                if (tokens.length > 0) {
                                    let termSet = [];

                                    documents.push({ tokens: tokens, timestamp: data[key].timestamp });

                                    for (const token of tokens) {
                                        if (!termSet.includes(token)) {
                                            if (token in inverseDocumentFrequency) {
                                                inverseDocumentFrequency[token] += 1.0;
                                            } else {
                                                inverseDocumentFrequency[token] = 1.0;
                                            }

                                            termSet.push(token);
                                        }
                                    }
                                }
                            }

                            for (const key in inverseDocumentFrequency) {
                                inverseDocumentFrequency[key] = Math.log(documents.length / inverseDocumentFrequency[key]);
                            }

                            for (const document of documents) {
                                if (document.timestamp * 1000 > baseTime) {
                                    filteredDocuments.push(document);
                                }
                            }

                            if (filteredDocuments.length < limit) {
                                const min = Math.max(documents.length - limit, 0);

                                filteredDocuments.splice(0);

                                for (let i = documents.length - 1; i >= min; i--) {
                                    filteredDocuments.unshift(documents[i]);
                                }
                            }

                            for (const document of filteredDocuments) {
                                let tf = {};

                                for (const token of document.tokens) {
                                    if (token in tf) {
                                        tf[token] += 1.0;
                                    } else {
                                        tf[token] = 1.0;
                                    }
                                }

                                for (const key in tf) {
                                    tf[key] /= document.tokens.length;

                                    if (!(key in scoreDictionary)) {
                                        scoreDictionary[key] = 0.0;
                                    }
                                }

                                termFrequencies.push(tf);
                            }

                            for (const key in scoreDictionary) {
                                for (const termFrequency of termFrequencies) {
                                    if (key in termFrequency) {
                                        const tfidf = termFrequency[key] * inverseDocumentFrequency[key];

                                        if (tfidf > scoreDictionary[key]) {
                                            scoreDictionary[key] = tfidf;
                                        }
                                    }
                                }
                            }

                            for (const key in scoreDictionary) {
                                if (key.length > 1 && key != '...') {
                                    scores.push({ term: key, value: scoreDictionary[key] });
                                }
                            }

                            scores.sort((x, y) => y.value - x.value);

                            if (scores.length > max) {
                                scores.splice(max);
                            }

                            for (const score of scores) {
                                if (score.value > maxScore) {
                                    maxScore = score.value;
                                }
                            }

                            for (const score of scores) {
                                score.value /= maxScore;
                            }

                            scores.sort((x, y) => {
                                if (x.term > y.term) {
                                    return 1;
                                } else if (x.term < y.term) {
                                    return -1;
                                }

                                return 0;
                            });

                            resolve(scores);
                        });

                        this.tags.splice(0);

                        for (let i = 0; i < results.length; i++) {
                            this.tags.push({ index: i, name: results[i].term, score: results[i].value })
                        }
                    } catch (e) {
                        console.error(e);
                    }

                    this.isUpdating = false;
                },
                scrollToEnd: function () {
                    if (typeof this.scrollTimeoutID === 'number') {
                        clearTimeout(this.scrollTimeoutID);
                    }

                    this.scrollTimeoutID = setTimeout(function () {
                        window.scrollTo(0, document.body.scrollHeight);
                    }, 500);
                },
                formatDate: function (event) {
                    moment.locale(window.navigator.language);

                    return moment(event).format('LT');
                },
                animationStart: function (el) {
                    this.isAnimating = true;
                },
                animationEnd: function (el) {
                    if (!this.isPopup) {
                        this.message = null;
                    }

                    this.isAnimating = false;
                },
                arrange: function (collection, limit) {
                    let rows = [];
                    let columns = [];

                    for (const item of collection) {
                        if (columns.length < limit) {
                            columns.push(item);
                        } else {
                            rows.push(columns);
                            columns = [item];
                        }
                    }

                    rows.push(columns);

                    return rows;
                },
                take: function (collection, count) {
                    if (collection.length > count) {
                        return collection.splice(count);
                    }

                    return collection;
                },
                prepare: function (sequences) {
                    let choosedSequences = [];
                    let flattenedSequence = [];

                    for (const s of sequences) {
                        if ('state' in s && s.name in this.states) {
                            let regex = new RegExp(s.state);

                            if (!regex.test(this.states[s.name])) {
                                continue;
                            }
                        }

                        choosedSequences.push(s);
                    }

                    if (choosedSequences.length > 0) {
                        let queue = [];

                        for (const s of choosedSequences[random(0, choosedSequences.length - 1)].sequence) {
                            queue.push(s);
                        }

                        while (queue.length > 0) {
                            const obj = queue.shift();

                            if (obj.type == "Sequence") {
                                if (!('sequence' in obj)) {
                                    let tracedSequences = [];
                                    let callableSequences = [];

                                    for (const s of this.character.sequences) {
                                        let sequenceStack = this.getSequenceStack(s, obj);

                                        if (sequenceStack.length > 0) {
                                            let stack = [];

                                            do {
                                                let poppedSequence = sequenceStack.pop();

                                                if (sequenceStack.length > 0) {
                                                    let tempStack = [];

                                                    for (const o of sequenceStack[sequenceStack.length - 1].sequence) {
                                                        if (o.type == "Sequence") {
                                                            if ('sequence' in o) {
                                                                let isNew = true;

                                                                for (const tempSequence of stack) {
                                                                    if (tempSequence === o) {
                                                                        isNew = false;

                                                                        break;
                                                                    }
                                                                }

                                                                if (isNew) {
                                                                    tempStack.push(o);
                                                                }
                                                            }

                                                            if (o === poppedSequence) {
                                                                break;
                                                            }
                                                        }
                                                    }

                                                    while (tempStack.length > 0) {
                                                        stack.push(tempStack.pop());
                                                    }
                                                }

                                                if ('sequence' in poppedSequence) {
                                                    let isNew = true;

                                                    for (const tempSequence of stack) {
                                                        if (tempSequence === poppedSequence) {
                                                            isNew = false;

                                                            break;
                                                        }
                                                    }

                                                    if (isNew) {
                                                        stack.Push(poppedSequence);
                                                    }
                                                }
                                            } while (sequenceStack.length > 0);

                                            while (stack.length > 0) {
                                                sequenceList.push(stack.pop());
                                            }
                                        }
                                        else {
                                            tracedSequences.push(s);
                                        }
                                    }

                                    if ('state' in obj) {
                                        this.states[obj.name] = obj.state;

                                        for (const s of tracedSequences) {
                                            if (s.name == obj.name) {
                                                let regex = new RegExp(s.state);

                                                if (!regex.test(obj.state)) {
                                                    continue;
                                                }

                                                callableSequences.push(s);
                                            }
                                        }
                                    } else {
                                        for (const s of tracedSequences) {
                                            if (s.name == obj.name) {
                                                if (s.name in this.states) {
                                                    let regex = new RegExp(s.state);

                                                    if (!regex.test(this.states[s.name])) {
                                                        continue;
                                                    }
                                                }

                                                callableSequences.push(s);
                                            }
                                        }
                                    }

                                    if (callableSequences.length > 0) {
                                        let index = 0;

                                        for (const o of callableSequences[random(0, callableSequences.length - 1)].sequence) {
                                            queue.splice(index, 0, o);
                                            index++;
                                        }
                                    }
                                }
                            } else {
                                flattenedSequence.push(obj);
                            }
                        }
                    }

                    return flattenedSequence;
                },
                getSequenceStack: function (sourceSequence, targetSequence) {
                    let sequenceStack = [];

                    sequenceStack.push(sourceSequence);

                    if (sequenceStack[sequenceStack.length - 1] !== targetSequence) {
                        for (const o in sourceSequence.sequence) {
                            if (o.type == "Sequence") {
                                let stack = this.getSequenceStack(o, targetSequence);

                                if (stack.length > 0 && stack[stack.length - 1] === targetSequence) {
                                    let tempStack = [];

                                    do {
                                        tempStack.push(stack.pop());
                                    } while (stack.length > 0);

                                    do {
                                        sequenceStack.push(tempStack.pop());
                                    } while (tempStack.length > 0);

                                    return sequenceStack;
                                }
                            }
                        }

                        sequenceStack.pop();
                    }

                    return sequenceStack;
                },
                animate: function () {
                    requestAnimationFrame(this.animate);

                    const deltaTime = clock.getDelta();
                    const app = this;

                    if (vrmModel) {
                        let isActive = false;
                        let isAnimating = false;
                        let isDeforming = false;
                        let messageData = null;
                        let updatedBlendShapeNames = [];

                        if (app.currentAnimations.length > 0 && animationIndex < app.currentAnimations.length) {
                            messageData = app.currentAnimations[animationIndex];
                            animationIndex += animationSkipFrames;
                            isActive = true;
                            isAnimating = true;
                        }

                        /*if (app.blendShapeAnimations.length == 0 && app.blendShapeAnimationQueue.length > 0) {
                            for (let blendShapeAnimation of app.blendShapeAnimationQueue.shift()) {
                                app.blendShapeAnimations.unshift(blendShapeAnimation);
                            }

                            isActive = true;
                            isDeforming = true;
                        }*/

                        for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                            let blendShapeAnimation = app.blendShapeAnimations[i];

                            if (!updatedBlendShapeNames.includes(blendShapeAnimation.name)) {
                                if (blendShapeAnimation.time <= blendShapeAnimation.duration) {
                                    blendShapeAnimation.time += deltaTime;

                                    if (blendShapeAnimation.time >= blendShapeAnimation.duration) {
                                        vrmModel.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.end / 2 * Math.PI)));
                                        app.blendShapeAnimations.splice(i, 1);
                                    } else {
                                        vrmModel.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin((blendShapeAnimation.time / blendShapeAnimation.duration * (blendShapeAnimation.end - blendShapeAnimation.start) + blendShapeAnimation.start) / 2 * Math.PI)));
                                    }

                                    isActive = true;
                                    isDeforming = true;
                                }

                                updatedBlendShapeNames.push(blendShapeAnimation.name);
                            }
                        }

                        if (app.sequenceQueue.length > 0) {
                            idleTime = 0.0;
                        } else {
                            idleTime += deltaTime;
                            activateTime += deltaTime;
                            alertTime += deltaTime;

                            if (alertTime >= alertThreshold) {
                                if (app.feedQueue.length > 0) {
                                    function format(format) {
                                        var args = arguments;

                                        return format.replace(/\{(\d)\}/g, function (m, c) { return args[parseInt(c) + 1] });
                                    }

                                    let sequences = [];
                                    let sequence = [];

                                    for (const sequence of this.character.sequences) {
                                        if (sequence.name == "Alert") {
                                            sequences.push(sequence);
                                        }
                                    }

                                    for (const obj of this.prepare(sequences)) {
                                        if (obj.type == "Message") {
                                            sequence.push({ type: obj.type, speed: obj.speed, duration: obj.duration, text: format(obj.text, app.feedQueue[0].text) });
                                        } else {
                                            sequence.push(obj);
                                        }
                                    }

                                    if (sequence.length > 0) {
                                        this.sequenceQueue.push(sequence);
                                    }

                                    app.feedQueue.push(app.feedQueue.shift());
                                }

                                idleTime = activateTime = alertTime = 0.0;
                            } else if (activateTime >= activateThreshold) {
                                app.talk();

                                idleTime = activateTime = 0.0;
                            } else if (idleTime >= blinkThreshold) {
                                let sequences = [];

                                for (const sequence of this.character.sequences) {
                                    if (sequence.name == "Idle") {
                                        sequences.push(sequence);
                                    }
                                }

                                this.sequenceQueue.push(this.prepare(sequences));

                                idleTime = 0.0;
                            }
                        }

                        if (app.sequenceQueue.length > 0) {
                            const sequence = app.sequenceQueue[0];

                            if (sequence.length > 0) {
                                if (sequence[0].type == "Animation") {
                                    if (sequence[0].name in app.animations) {
                                        if (!isAnimating) {
                                            /*const skipFrames = 60 / 12;
                                            let animations = app.animations[suggestion.animation];
                                            let maxFrames = Math.min(animations.length, 60);
                                            let offset = Math.floor(Math.max(0, random(0, animations.length - maxFrames - 1)) / 2);
                                            let length = Math.round(90 / 24);
                
                                            for (let i = 0; i < maxFrames; i += skipFrames) {
                                                for (let j = 0; j < length; j++) {
                                                    app.currentAnimations.push(animations[offset + i]);
                                                }
                                            }
                
                                            for (let i = app.currentAnimations.length - 1; i >= 0; i--) {
                                                app.currentAnimations.push(animations[offset + i]);
                                            }*/

                                            for (let animation of app.animations[sequence[0].name]) {
                                                app.currentAnimations.push(animation);
                                            }

                                            sequence.shift();

                                            animationIndex = 0;
                                            messageData = app.currentAnimations[animationIndex];
                                            animationIndex += animationSkipFrames;
                                        }
                                    } else if (!isDeforming) {
                                        let nameSet = [];

                                        app.blendShapeAnimations.unshift({ name: sequence[0].name, time: 0.0, duration: sequence[0].duration, start: sequence[0].start, end: sequence[0].end });
                                        sequence.shift();

                                        while (sequence.length > 0) {
                                            if (sequence[0].type != "Animation" || sequence[0].name in app.animations) {
                                                break;
                                            }

                                            app.blendShapeAnimations.unshift({ name: sequence[0].name, time: 0.0, duration: sequence[0].duration, start: sequence[0].start, end: sequence[0].end });
                                            sequence.shift();
                                        }

                                        for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                                            let blendShapeAnimation = app.blendShapeAnimations[i];

                                            if (!nameSet.includes(blendShapeAnimation.name)) {
                                                vrmModel.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.start / 2 * Math.PI)));
                                                nameSet.push(blendShapeAnimation.name);
                                            }
                                        }
                                    }

                                    if (lookAtTarget.position.x != 0.0 || lookAtTarget.position.y != 0.0) {
                                        lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: 0.0, y: 0.0 } };
                                    }
                                } else if (sequence[0].type == "Message" && app.message === null && !isAnimating && !isDeforming) {
                                    app.message = { time: 0, duration: sequence[0].duration, type: { elapsed: -1, speed: sequence[0].speed, reverse: false, buffer: '', count: 0 }, text: sequence[0].text };
                                    sequence.shift();
                                }
                            } else if (app.message === null && !isAnimating && !isDeforming) {
                                app.sequenceQueue.shift();
                            }
                        } else if (app.suggestionQueue.length > 0) {
                            const suggestion = app.suggestionQueue[0];
                            const message = suggestion.messages[0];
                            let loopRequired = true;

                            if (message.type.reverse) {
                                if (message.type.count > 0) {
                                    message.type.elapsed += deltaTime;

                                    if (message.type.elapsed >= message.type.speed / 1000.0) {
                                        let index = message.type.count - 1;

                                        if (index < message.text.length) {
                                            let width = Math.floor(message.text.length / 2);

                                            if (message.type.buffer.length <= width) {
                                                message.type.count -= 1;
                                            }

                                            if (message.type.buffer.length > 0) {
                                                message.type.buffer = message.type.buffer.substring(message.type.buffer.length - 2, message.type.buffer.length - 1);
                                            }
                                        }

                                        message.type.elapsed = 0;
                                    }
                                } else if (app.isSuggested) {
                                    /*suggestion.time = 0;
                                    suggestion.type.elapsed = -1;
                                    suggestion.type.reverse = false;
                                    suggestion.type.buffer = '';
                                    suggestion.type.count = 0;
        
                                    if ('morphs' in suggestion) {
                                        for (let blendShapeAnimation of suggestion.morphs.animations) {
                                            blendShapeAnimation.time = 0;
                                        }
                                    }*/

                                    if (suggestion.messages.length > 1) {
                                        suggestion.messages.shift();
                                    } else {
                                        app.suggestionQueue.shift();

                                        if (app.suggestionQueue.length > 0 && 'highlight' in app.suggestionQueue[0]) {
                                            if ('text' in app.suggestionQueue[0].highlight) {
                                                app.highlight = app.suggestionQueue[0].highlight.text;
                                            } else {
                                                app.highlight = null;
                                            }

                                            if ('image' in app.suggestionQueue[0].highlight) {
                                                app.cover = app.suggestionQueue[0].highlight.image;
                                            } else {
                                                app.cover = app;
                                            }
                                        }

                                        app.isBlinded = true;
                                    }
                                } else if (app.isBlinded && !isActive) {
                                    if ('morphs' in suggestion) {
                                        for (let blendShape of suggestion.morphs.defaults) {
                                            vrmModel.blendShapeProxy.setValue(blendShape.name, Math.abs(Math.sin(blendShape.weight / 2 * Math.PI)));
                                        }
                                    }

                                    app.suggestionQueue.splice(0);
                                    app.isBlinded = false;
                                    loopRequired = false;
                                }
                            } else if (message.type.buffer.length < message.text.length) {
                                if (message.type.elapsed >= 0) {
                                    message.type.elapsed += deltaTime;
                                } else if (!isActive) {
                                    if (!app.isPreloading) {
                                        waitTime += deltaTime;
                                    }

                                    if (app.highlight === null && app.cover === null || waitTime >= waitThreshold) {
                                        message.type.elapsed = deltaTime;
                                        app.isBlinded = false;
                                        app.currentAnimations.splice(0);

                                        if ('animation' in suggestion && suggestion.animation in app.animations) {
                                            const skipFrames = 60 / 12;
                                            let animations = app.animations[suggestion.animation];
                                            let maxFrames = Math.min(animations.length, 60);
                                            let offset = Math.floor(Math.max(0, random(0, animations.length - maxFrames - 1)) / 2);
                                            let length = Math.round(90 / 24);

                                            for (let i = 0; i < maxFrames; i += skipFrames) {
                                                for (let j = 0; j < length; j++) {
                                                    app.currentAnimations.push(animations[offset + i]);
                                                }
                                            }

                                            for (let i = app.currentAnimations.length - 1; i >= 0; i--) {
                                                app.currentAnimations.push(animations[offset + i]);
                                            }
                                        }

                                        if ('morphs' in suggestion) {
                                            let nameSet = [];

                                            for (let blendShape of suggestion.morphs.defaults) {
                                                vrmModel.blendShapeProxy.setValue(blendShape.name, Math.abs(Math.sin(blendShape.weight / 2 * Math.PI)));
                                            }

                                            for (let blendShapeAnimation of suggestion.morphs.animations) {
                                                app.blendShapeAnimations.unshift(blendShapeAnimation);
                                            }

                                            for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                                                let blendShapeAnimation = app.blendShapeAnimations[i];

                                                if (!nameSet.includes(blendShapeAnimation.name)) {
                                                    vrmModel.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.start / 2 * Math.PI)));
                                                    nameSet.push(blendShapeAnimation.name);
                                                }
                                            }
                                        }

                                        waitTime = 0.0;
                                    } else {
                                        loopRequired = false;
                                    }
                                }

                                if (message.type.elapsed >= message.type.speed / 1000.0) {
                                    let index = message.type.buffer.length;
                                    let width = Math.floor(message.text.length / 2);
                                    let length = message.text.length;

                                    if (message.type.count >= width) {
                                        message.type.buffer += message.text.charAt(index);
                                    }

                                    if (message.type.count < length) {
                                        message.type.count += 1;
                                    }

                                    message.type.elapsed = 0;
                                }
                            } else {
                                message.time += deltaTime;

                                if (message.time >= message.duration) {
                                    message.type.reverse = true;
                                }
                            }

                            if (message.text.length === message.type.buffer.length) {
                                const characters = message.text.split('');

                                app.text.splice(0);

                                for (let i = 0; i < characters.length; i++) {
                                    app.text.push({ key: i, value: characters[i] });
                                }
                            } else {
                                let charArray = new Array();
                                let randomBuffer = '';

                                for (let i = 0; i < message.text.length; i++) {
                                    if (charArray.indexOf(message.text.charAt(i)) == -1 && message.text.charAt(i) != "\n" && message.text.charAt(i).match(/\s/) == null) {
                                        charArray.push(message.text.charAt(i));
                                    }
                                }

                                for (let i = 0; i < message.type.count; i++) {
                                    if (charArray.length > 0) {
                                        randomBuffer += charArray[~~random(0, charArray.length - 1)];
                                    }
                                }

                                if (randomBuffer.length > message.type.buffer.length) {
                                    const characters = (message.type.buffer + randomBuffer.substring(message.type.buffer.length, randomBuffer.length)).split('');

                                    app.text.splice(0);

                                    for (let i = 0; i < characters.length; i++) {
                                        app.text.push({ key: i, value: characters[i] });
                                    }
                                } else if (app.text.length !== message.type.buffer.length) {
                                    const characters = message.type.buffer.split('');

                                    app.text.splice(0);

                                    for (let i = 0; i < characters.length; i++) {
                                        app.text.push({ key: i, value: characters[i] });
                                    }
                                }
                            }

                            if (loopRequired && messageData === null) {
                                animationIndex = 0;
                                messageData = app.currentAnimations[animationIndex];
                                animationIndex += animationSkipFrames;
                            }
                        } else {
                            if (app.isSuggested && app.suggestionQueue.length == 0 && !app.isComputing) {
                                const tempMessages1 = [].concat(app.messages);
                                const tempTags = [].concat(app.tags);

                                app.isComputing = true;

                                new Promise(resolve => {
                                    let segmenter = new TinySegmenter();
                                    const presets = [{ animation: 'idle2', name: THREE.VRMSchema.BlendShapePresetName.Fun },
                                    { animation: 'jump', name: THREE.VRMSchema.BlendShapePresetName.Joy },
                                    { animation: 'win', name: THREE.VRMSchema.BlendShapePresetName.Joy },
                                    { animation: 'lose', name: THREE.VRMSchema.BlendShapePresetName.Sorrow }];
                                    let suggestions = [];
                                    let tempMessages2 = [];
                                    let ids1 = [];
                                    let ids2 = [];

                                    for (let tag of tempTags.sort((x, y) => y.score - x.score)) {
                                        for (let message of tempMessages1.reverse()) {
                                            if (!ids1.includes(message.id) && segmenter.segment(message.text).includes(tag.name)) {
                                                let thread = null;

                                                if ('thread' in message) {
                                                    for (let m of tempMessages1) {
                                                        if (message.thread == m.id) {
                                                            thread = m;

                                                            break;
                                                        }
                                                    }
                                                }

                                                if (thread === null) {
                                                    tempMessages2.push(message);
                                                } else {
                                                    const item = presets[random(0, 3)];

                                                    suggestions.push({ highlight: { text: '今日の' + document.title, image: '/images/Cover.png' }, messages: [{ time: 0, duration: 5, type: { elapsed: -1, speed: 50, reverse: false, buffer: '', count: 0 }, text: thread.text }, { time: 0, duration: 5, type: { elapsed: 0, speed: 50, reverse: false, buffer: '', count: 0 }, text: message.text }], animation: item.animation, morphs: { animations: [{ name: item.name, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }], defaults: [{ name: THREE.VRMSchema.BlendShapePresetName.Joy, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Sorrow, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Fun, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Blink, weight: 0.0 }] } });

                                                    if (!ids2.includes(thread.id)) {
                                                        ids2.push(thread.id);
                                                    }
                                                }

                                                ids1.push(message.id);
                                            }
                                        }
                                    }

                                    for (const message of tempMessages2) {
                                        if (!ids2.includes(message.id)) {
                                            const item = presets[random(0, 3)];

                                            suggestions.push({ highlight: { text: '今日の' + document.title, image: '/images/Cover.png' }, messages: [{ time: 0, duration: 5, type: { elapsed: -1, speed: 50, reverse: false, buffer: '', count: 0 }, text: message.text }], animation: item.animation, morphs: { animations: [{ name: item.name, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }], defaults: [{ name: THREE.VRMSchema.BlendShapePresetName.Joy, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Sorrow, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Fun, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Blink, weight: 0.0 }] } });
                                        }
                                    }

                                    resolve(suggestions);
                                }).then((result) => {
                                    if (app.isSuggested && result.length > 0) {
                                        for (const suggestion of result) {
                                            app.suggestionQueue.push(suggestion);
                                        }

                                        if ('highlight' in app.suggestionQueue[0]) {
                                            if ('text' in app.suggestionQueue[0].highlight) {
                                                app.highlight = app.suggestionQueue[0].highlight.text;
                                            } else {
                                                app.highlight = null;
                                            }

                                            if ('image' in app.suggestionQueue[0].highlight) {
                                                app.cover = app.suggestionQueue[0].highlight.image;
                                            } else {
                                                app.cover = null;
                                            }
                                        }
                                    }

                                    app.isComputing = false;
                                });
                            }

                            /*if (messageData === null) {
                                if (app.sequenceQueue.length > 0) {
                                    idleTime = activateTime = 0.0;
                                } else {
                                    idleTime += deltaTime;
                                    activateTime += deltaTime;

                                    if (activateTime >= activateThreshold) {
                                        app.talk();

                                        idleTime = activateTime = 0.0;
                                    } else if (idleTime >= blinkThreshold) {
                                        let sequences = [];

                                        for (const sequence of this.character.sequences) {
                                            if (sequence.name == "Idle") {
                                                sequences.push(sequence);
                                            }
                                        }

                                        this.sequenceQueue.push(this.prepare(sequences));

                                        idleTime = 0.0;
                                    }
                                }

                                app.currentAnimations.splice(0);

                                for (let animation of app.animations["idle1"]) {
                                    app.currentAnimations.push(animation);
                                }

                                animationIndex = 0;
                                messageData = app.currentAnimations[animationIndex];
                                animationIndex += animationSkipFrames;
                            } else if (app.sequenceQueue.length > 0) {
                                idleTime = activateTime = 0.0;
                            } else {
                                idleTime += deltaTime;
                                activateTime += deltaTime;
                            }*/
                        }

                        if (messageData === null) {
                            app.currentAnimations.splice(0);

                            for (let animation of app.animations["idle1"]) {
                                app.currentAnimations.push(animation);
                            }

                            animationIndex = 0;
                            messageData = app.currentAnimations[animationIndex];
                            animationIndex += animationSkipFrames;
                        }

                        if (app.message !== null) {
                            if (app.message.type.reverse) {
                                if (app.message.type.count > 0) {
                                    app.message.type.elapsed += deltaTime;

                                    if (app.message.type.elapsed >= 1.0 / app.message.type.speed) {
                                        let index = app.message.type.count - 1;

                                        if (index < app.message.text.length) {
                                            let width = Math.floor(app.message.text.length / 2);

                                            if (app.message.type.buffer.length <= width && app.message.type.count > 0) {
                                                app.message.type.count -= 1;
                                            }

                                            if (app.message.type.buffer.length > 0) {
                                                app.message.type.buffer = app.message.type.buffer.substring(0, app.message.type.buffer.length - 1);
                                            }
                                        }

                                        app.message.type.elapsed = 0;
                                    }
                                } else {
                                    /*if (suggestion.messages.length > 1) {
                                        suggestion.messages.shift();
                                    } else {
                                        if ('morphs' in suggestion) {
                                            for (let blendShape of suggestion.morphs.defaults) {
                                                vrmModel.blendShapeProxy.setValue(blendShape.name, Math.abs(Math.sin(blendShape.weight / 2 * Math.PI)));
                                            }
                                        }
        
        
                                    }*/

                                    app.isPopup = false;
                                }
                            } else if (app.message.type.buffer.length < app.message.text.length) {
                                if (app.message.type.elapsed >= 0) {
                                    app.message.type.elapsed += deltaTime;
                                } else if (!app.isAnimating) {
                                    if (app.isPopup) {
                                        app.message.type.elapsed = deltaTime;
                                        //app.isBlinded = false;
                                        //app.currentAnimations.splice(0);

                                        /*if ('animation' in suggestion && suggestion.animation in app.animations) {
                                            const skipFrames = 60 / 12;
                                            let animations = app.animations[suggestion.animation];
                                            let maxFrames = Math.min(animations.length, 60);
                                            let offset = Math.floor(Math.max(0, random(0, animations.length - maxFrames - 1)) / 2);
                                            let length = Math.round(90 / 24);
        
                                            for (let i = 0; i < maxFrames; i += skipFrames) {
                                                for (let j = 0; j < length; j++) {
                                                    app.currentAnimations.push(animations[offset + i]);
                                                }
                                            }
        
                                            for (let i = app.currentAnimations.length - 1; i >= 0; i--) {
                                                app.currentAnimations.push(animations[offset + i]);
                                            }
                                        }
        
                                        if ('morphs' in suggestion) {
                                            let nameSet = [];
        
                                            for (let blendShape of suggestion.morphs.defaults) {
                                                vrmModel.blendShapeProxy.setValue(blendShape.name, Math.abs(Math.sin(blendShape.weight / 2 * Math.PI)));
                                            }
        
                                            for (let blendShapeAnimation of suggestion.morphs.animations) {
                                                app.blendShapeAnimations.unshift(blendShapeAnimation);
                                            }
        
                                            for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                                                let blendShapeAnimation = app.blendShapeAnimations[i];
        
                                                if (!nameSet.includes(blendShapeAnimation.name)) {
                                                    vrmModel.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.start / 2 * Math.PI)));
                                                    nameSet.push(blendShapeAnimation.name);
                                                }
                                            }
                                        }*/
                                    } else {
                                        app.isPopup = true;
                                    }
                                }

                                if (app.message.type.elapsed >= 1.0 / app.message.type.speed) {
                                    let index = app.message.type.buffer.length;
                                    let width = Math.floor(app.message.text.length / 2);
                                    let length = app.message.text.length;

                                    if (app.message.type.count >= width) {
                                        app.message.type.buffer += app.message.text.charAt(index);
                                    }

                                    if (app.message.type.count < length) {
                                        app.message.type.count += 1;
                                    }

                                    app.message.type.elapsed = 0;
                                }
                            } else {
                                app.message.time += deltaTime;

                                if (app.message.time >= app.message.duration) {
                                    app.message.type.reverse = true;
                                }
                            }

                            if (app.message.text.length === app.message.type.buffer.length) {
                                const characters = app.message.text.split('');

                                app.text.splice(0);

                                for (let i = 0; i < characters.length; i++) {
                                    app.text.push({ key: i, value: characters[i] });
                                }
                            } else {
                                let charArray = new Array();
                                let randomBuffer = '';

                                for (let i = 0; i < app.message.text.length; i++) {
                                    if (charArray.indexOf(app.message.text.charAt(i)) == -1 && app.message.text.charAt(i) != "\n" && app.message.text.charAt(i).match(/\s/) == null) {
                                        charArray.push(app.message.text.charAt(i));
                                    }
                                }

                                if (charArray.length > 0) {
                                    for (let i = 0; i < app.message.type.count; i++) {
                                        if (app.message.text.charAt(i) == "\n") {
                                            randomBuffer += "\n";
                                        } else {
                                            randomBuffer += charArray[~~random(0, charArray.length - 1)];
                                        }
                                    }
                                }

                                if (randomBuffer.length > app.message.type.buffer.length) {
                                    const characters = (app.message.type.buffer + randomBuffer.substring(app.message.type.buffer.length, randomBuffer.length)).split('');

                                    app.text.splice(0);

                                    for (let i = 0; i < characters.length; i++) {
                                        app.text.push({ key: i, value: characters[i] });
                                    }
                                } else if (app.text.length !== app.message.type.buffer.length) {
                                    const characters = app.message.type.buffer.split('');

                                    app.text.splice(0);

                                    for (let i = 0; i < characters.length; i++) {
                                        app.text.push({ key: i, value: characters[i] });
                                    }
                                }
                            }
                        }

                        if (lookAnimation !== null) {
                            lookAnimation.time += deltaTime;

                            if (lookAnimation.time >= lookAnimation.duration) {
                                lookAtTarget.position.x = lookAnimation.target.x;
                                lookAtTarget.position.y = lookAnimation.target.y;
                                lookAnimation = null;
                            } else {
                                const rate = lookAnimation.time / lookAnimation.duration;

                                lookAtTarget.position.x = lookAnimation.source.x + (lookAnimation.target.x - lookAnimation.source.x) * rate;
                                lookAtTarget.position.y = lookAnimation.source.y + (lookAnimation.target.y - lookAnimation.source.y) * rate;
                            }
                        }

                        if (messageData) {
                            for (let animation of messageData.animations) {
                                switch (animation.bone) {
                                    case 'chest':
                                    case 'head':
                                    case 'hips':
                                    case 'jaw':
                                    case 'leftEye':
                                    case 'leftFoot':
                                    case 'leftHand':
                                    case 'leftIndexDistal':
                                    case 'leftIndexIntermediate':
                                    case 'leftIndexProximal':
                                    case 'leftLittleDistal':
                                    case 'leftLittleIntermediate':
                                    case 'leftLittleProximal':
                                    case 'leftLowerArm':
                                    case 'leftLowerLeg':
                                    case 'leftMiddleDistal':
                                    case 'leftMiddleIntermediate':
                                    case 'leftMiddleProximal':
                                    case 'leftRingDistal':
                                    case 'leftRingIntermediate':
                                    case 'leftRingProximal':
                                    case 'leftShoulder':
                                    case 'leftThumbDistal':
                                    case 'leftThumbIntermediate':
                                    case 'leftThumbProximal':
                                    case 'leftToes':
                                    case 'leftUpperArm':
                                    case 'leftUpperLeg':
                                    case 'neck':
                                    case 'rightEye':
                                    case 'rightFoot':
                                    case 'rightHand':
                                    case 'rightIndexDistal':
                                    case 'rightIndexIntermediate':
                                    case 'rightIndexProximal':
                                    case 'rightLittleDistal':
                                    case 'rightLittleIntermediate':
                                    case 'rightLittleProximal':
                                    case 'rightLowerArm':
                                    case 'rightLowerLeg':
                                    case 'rightMiddleDistal':
                                    case 'rightMiddleIntermediate':
                                    case 'rightMiddleProximal':
                                    case 'rightRingDistal':
                                    case 'rightRingIntermediate':
                                    case 'rightRingProximal':
                                    case 'rightShoulder':
                                    case 'rightThumbDistal':
                                    case 'rightThumbIntermediate':
                                    case 'rightThumbProximal':
                                    case 'rightToes':
                                    case 'rightUpperArm':
                                    case 'rightUpperLeg':
                                    case 'spine':
                                    case 'upperChest':
                                        break;
                                    case 'eye.L':
                                        animation.bone = 'leftEye';
                                        break;
                                    case 'foot.L':
                                        animation.bone = 'leftFoot';
                                        break;
                                    case 'hand.L':
                                        animation.bone = 'leftHand';
                                        break;
                                    case 'f_index.03.L':
                                        animation.bone = 'leftIndexDistal';
                                        break;
                                    case 'f_index.02.L':
                                        animation.bone = 'leftIndexIntermediate';
                                        break;
                                    case 'f_index.01.L':
                                        animation.bone = 'leftIndexProximal';
                                        break;
                                    case 'f_pinky.03.L':
                                        animation.bone = 'leftLittleDistal';
                                        break;
                                    case 'f_pinky.02.L':
                                        animation.bone = 'leftLittleIntermediate';
                                        break;
                                    case 'f_pinky.01.L':
                                        animation.bone = 'leftLittleProximal';
                                        break;
                                    case 'lower_arm.L':
                                        animation.bone = 'leftLowerArm';
                                        break;
                                    case 'shin.L':
                                        animation.bone = 'leftLowerLeg';
                                        break;
                                    case 'f_middle.03.L':
                                        animation.bone = 'leftMiddleDistal';
                                        break;
                                    case 'f_middle.02.L':
                                        animation.bone = 'leftMiddleIntermediate';
                                        break;
                                    case 'f_middle.01.L':
                                        animation.bone = 'leftMiddleProximal';
                                        break;
                                    case 'f_ring.03.L':
                                        animation.bone = 'leftRingDistal';
                                        break;
                                    case 'f_ring.02.L':
                                        animation.bone = 'leftRingIntermediate';
                                        break;
                                    case 'f_ring.01.L':
                                        animation.bone = 'leftRingProximal';
                                        break;
                                    case 'shoulder.L':
                                        animation.bone = 'leftShoulder';
                                        break;
                                    case 'thumb_distal.L':
                                        animation.bone = 'leftThumbDistal';
                                        break;
                                    case 'thumb_intermediate.L':
                                        animation.bone = 'leftThumbIntermediate';
                                        break;
                                    case 'thumb_proximal.L':
                                        animation.bone = 'leftThumbProximal';
                                        break;
                                    case 'toe.L':
                                        animation.bone = 'leftToes';
                                        break;
                                    case 'upper_arm.L':
                                        animation.bone = 'leftUpperArm';
                                        break;
                                    case 'thigh.L':
                                        animation.bone = 'leftUpperLeg';
                                        break;
                                    case 'eye.R':
                                        animation.bone = 'rightEye';
                                        break;
                                    case 'foot.R':
                                        animation.bone = 'rightFoot';
                                        break;
                                    case 'hand.R':
                                        animation.bone = 'rightHand';
                                        break;
                                    case 'f_index.03.R':
                                        animation.bone = 'rightIndexDistal';
                                        break;
                                    case 'f_index.02.R':
                                        animation.bone = 'rightIndexIntermediate';
                                        break;
                                    case 'f_index.01.R':
                                        animation.bone = 'rightIndexProximal';
                                        break;
                                    case 'f_pinky.03.R':
                                        animation.bone = 'rightLittleDistal';
                                        break;
                                    case 'f_pinky.02.R':
                                        animation.bone = 'rightLittleIntermediate';
                                        break;
                                    case 'f_pinky.01.R':
                                        animation.bone = 'rightLittleProximal';
                                        break;
                                    case 'lower_arm.R':
                                        animation.bone = 'rightLowerArm';
                                        break;
                                    case 'shin.R':
                                        animation.bone = 'rightLowerLeg';
                                        break;
                                    case 'f_middle.03.R':
                                        animation.bone = 'rightMiddleDistal';
                                        break;
                                    case 'f_middle.02.R':
                                        animation.bone = 'rightMiddleIntermediate';
                                        break;
                                    case 'f_middle.01.R':
                                        animation.bone = 'rightMiddleProximal';
                                        break;
                                    case 'f_ring.03.R':
                                        animation.bone = 'rightRingDistal';
                                        break;
                                    case 'f_ring.02.R':
                                        animation.bone = 'rightRingIntermediate';
                                        break;
                                    case 'f_ring.01.R':
                                        animation.bone = 'rightRingProximal';
                                        break;
                                    case 'shoulder.R':
                                        animation.bone = 'rightShoulder';
                                        break;
                                    case 'thumb_distal.R':
                                        animation.bone = 'rightThumbDistal';
                                        break;
                                    case 'thumb_intermediate.R':
                                        animation.bone = 'rightThumbIntermediate';
                                        break;
                                    case 'thumb_proximal.R':
                                        animation.bone = 'rightThumbProximal';
                                        break;
                                    case 'toe.R':
                                        animation.bone = 'rightToes';
                                        break;
                                    case 'upper_arm.R':
                                        animation.bone = 'rightUpperArm';
                                        break;
                                    case 'thigh.R':
                                        animation.bone = 'rightUpperLeg';
                                        break;
                                    case 'upper_chest':
                                        animation.bone = 'upperChest';
                                        break;
                                    default:
                                        animation.bone = null;
                                }

                                if (animation.bone && animation.rotation.length == 4) {
                                    try {
                                        vrmModel.humanoid.getBoneNode(animation.bone).position.set(animation.position[0], animation.position[1], -animation.position[2]);
                                        vrmModel.humanoid.getBoneNode(animation.bone).quaternion.set(-animation.rotation[0], -animation.rotation[1], animation.rotation[2], animation.rotation[3]);
                                    } catch (e) {
                                        console.log(animation.bone);
                                    }
                                }
                            }
                        }

                        vrmModel.update(deltaTime);
                        /*if (currentMixer) {
                            currentMixer.update(deltaTime);
                        }*/
                    }

                    controls.update();

                    renderer.render(scene, camera);

                    stats.update();
                }
            },
            updated: function () {
                let container = this.$refs.container;
                let popup = document.body.querySelector(".navbar:nth-of-type(2) .navbar-item .control:last-child .level:nth-last-of-type(1)");

                container.style.paddingTop = this.$refs.indicator.getBoundingClientRect().height + 'px'
                container.style.paddingBottom = this.$refs.input.getBoundingClientRect().height + 'px'

                //this.$refs.ticker.style.width = document.body.querySelector("#input .columns>.column .control:nth-last-of-type(1) .level:nth-last-of-type(1) form").getBoundingClientRect().width + 'px';

                //document.body.querySelector("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker").style.width = "100%";
                /*this.$refs.ticker.style.width = document.body.querySelector("#input .columns>.column .control:nth-last-of-type(1) .level:nth-last-of-type(1) form").getBoundingClientRect().width + 'px';
                this.$nextTick(() => {
                    let width = 0;

                    for (const item of document.body.querySelectorAll("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker .item")) {
                        width += item.getBoundingClientRect().width;
                    }

                    document.body.querySelector("#heading>.columns>.column>.columns:first-child>.column>.columns:last-child .level:first-child .level-item .field .ticker").style.width = width + 'px';
                });*/

                if (popup !== null) {
                    popup.style.paddingBottom = container.style.paddingBottom;
                }
            },
            mounted: async function () {
                const self = this;
                let container = this.$refs.container;
                let popup = document.body.querySelector(".navbar:nth-of-type(2) .navbar-item .control:last-child .level:nth-last-of-type(1)");
                const loader = new GLTFLoader();
                let sequences = [];

                this.$refs.three.appendChild(renderer.domElement);
                this.$refs.three.appendChild(stats.domElement);

                this.animate();

                container.style.paddingTop = this.$refs.indicator.getBoundingClientRect().height + 'px'
                container.style.paddingBottom = this.$refs.input.getBoundingClientRect().height + 'px'

                //this.$refs.ticker.style.width = document.body.querySelector("#input .columns>.column .control:nth-last-of-type(1) .level:nth-last-of-type(1) form").getBoundingClientRect().width + 'px';

                if (popup !== null) {
                    popup.style.paddingBottom = container.style.paddingBottom;
                }

                try {
                    const response1 = await fetch('/js/images.json', {
                        mode: "cors",
                        method: "GET",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded"
                        }
                    });

                    if (response1.ok) {
                        this.presetImages = await response1.json();

                        if (this.presetImages !== null && this.presetImages.length > 0) {
                            this.isBlinded = true;
                        }
                    }
                    else {
                        throw new Error(response1.statusText);
                    }
                } catch (e) {
                    console.error(e);
                }

                try {
                    const response2 = await fetch('/js/milch.json', {
                        mode: "cors",
                        method: "GET",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded"
                        }
                    });

                    if (response2.ok) {
                        self.character = await response2.json();
                    }
                    else {
                        throw new Error(response2.statusText);
                    }

                    loader.crossOrigin = "anonymous";
                    loader.load(
                        self.character.model,
                        (gltf) => {
                            THREE.VRM.from(gltf).then(async (vrm) => {
                                const urls = {
                                    idle1: '/models/animations/animation-idle1.json',
                                    idle2: '/models/animations/animation-idle2.json',
                                    //idle3: '/models/animations/animation-idle3.json',
                                    //idle4: '/models/animations/animation-idle4.json',
                                    jump: '/models/animations/animation-jump.json',
                                    lose: '/models/animations/animation-lose.json',
                                    //run: '/models/animations/animation-run.json',
                                    //walk: '/models/animations/animation-walk.json',
                                    win: '/models/animations/animation-win.json'
                                };
                                let animationDictionary = {};

                                try {
                                    if (channel.length == 0) {
                                        for (let key in urls) {
                                            const response3 = await fetch(encodeURI(urls[key]), {
                                                mode: "cors",
                                                method: "GET",
                                                headers: {
                                                    "Content-Type": "application/x-www-form-urlencoded"
                                                }
                                            });

                                            if (response3.ok) {
                                                const json = await response3.json();

                                                animationDictionary[key] = json.data;
                                            }
                                            else {
                                                throw new Error(response3.statusText);
                                            }
                                        }
                                    }

                                    self.animations = animationDictionary;
                                    vrmModel = vrm;

                                    scene.add(vrm.scene);

                                    vrm.scene.rotation.y = Math.PI;
                                    vrm.lookAt.target = lookAtTarget;

                                    //vrm.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName.Hips).rotation.y = Math.PI;
                                    //currentMixer = prepareAnimation(vrm);

                                    self.progress = 0.0;
                                } catch (e) {
                                    console.error(e);
                                }
                            });
                        },
                        (progress) => self.progress = progress.loaded / progress.total,
                        (error) => console.error(error)
                    );
                } catch (e) {
                    console.error(e);
                }

                for (const sequence of self.character.sequences) {
                    if (sequence.name == "Start") {
                        sequences.push(sequence);
                    }
                }

                self.sequenceQueue.push(this.prepare(sequences));

                firebase.auth().signInAnonymously().catch(function (error) {
                    console.error(error.code, error.message);
                });
                firebase.auth().onAuthStateChanged(function (user) {
                    if (user) {
                        // User is signed in.
                        self.user = user;

                        database.ref(databaseChannel + "/stars").on('value', snapshot => {
                            const count = snapshot.val();

                            if (count === null) {
                                self.stars = 0;
                            } else {
                                if (self.stars >= 0) {
                                    const particles = count - self.stars;

                                    if (particles > 0) {
                                        window.pJSDom[0].pJS.fn.modes.pushParticles(particles);
                                    }
                                }

                                self.stars = count;
                            }
                        });
                        database.ref(databaseChannel + "/words").orderByChild("timestamp").limitToLast(10).on('value', snapshot => {
                            if (snapshot.exists()) {
                                const words = snapshot.val();
                                let tempWords = [];
                                let index = 0;

                                for (const word in words) {
                                    tempWords.push({ name: word, timestamp: words[word].timestamp });
                                }

                                for (const word of tempWords.sort((x, y) => y.timestamp - x.timestamp)) {
                                    let removeIndex = -1;

                                    for (let i = 0; i < self.words.length; i++) {
                                        if (self.words[i] == word.name) {
                                            removeIndex = i;

                                            break;
                                        }
                                    }

                                    if (removeIndex >= 0) {
                                        self.words.splice(removeIndex, 1);
                                    }

                                    self.words.splice(index, 0, word.name);

                                    index++;
                                }
                            }
                        });
                        database.ref(databaseMessages).limitToLast(100).on('value', snapshot => {
                            if (snapshot.exists()) {
                                function format(format) {
                                    var args = arguments;

                                    return format.replace(/\{(\d)\}/g, function (m, c) { return args[parseInt(c) + 1] });
                                }

                                const messageDictionary = snapshot.val();
                                let keys = Object.keys(messageDictionary);
                                let received = null;
                                let sequences = [];
                                let sequence = [];

                                if (keys.length > app.maxMessages) {
                                    keys.splice(0, keys.length - app.maxMessages);
                                }

                                app.feedQueue.splice(0);

                                for (let key of keys) {
                                    const message = messageDictionary[key];
                                    const timestamp = message.timestamp * 1000;
                                    let index = -1;

                                    //console.log(date.toISOString());
                                    //console.log(date.toLocaleTimeString());

                                    for (let i = 0; i < app.messages.length; i++) {
                                        if (key === app.messages[i].id) {
                                            index = i;

                                            break;
                                        }
                                    }

                                    if (!message.user.accent) {
                                        message.user.accent = '#30c0f5';
                                    }

                                    if (channel.length > 0 && !message.user.id) {
                                        message.user.name = null;
                                        message.user.image = null;
                                    }

                                    if (index >= 0) {
                                        //let j = -1;
                                        const data = { id: key, text: message.text, thread: message.thread, timestamp: new Date(timestamp), user: message.user };
                                        /*
                                        for (let i = 0; i < app.messages.length; i++) {
                                            if (timestamp < Math.floor(app.messages[i].timestamp)) {
                                                j = i;
                                            }
                                        }
        
                                        if (j >= 0) {
                                            const temp = app.messages[j];
        
                                            app.messages[j] = data;
                                            app.messages[index] = temp;
                                        } else {
                                            app.messages[index] = data;
                                        }*/

                                        app.messages[index] = data;
                                    }
                                    else {
                                        for (let i = 0; i < app.messages.length; i++) {
                                            if (timestamp < Math.floor(app.messages[i].timestamp)) {
                                                index = i;
                                            }
                                        }

                                        app.messages.splice(index >= 0 ? index : app.messages.length, 0, { id: key, text: message.text, thread: message.thread, timestamp: new Date(timestamp), user: message.user });

                                        if (app.messages.length > app.maxMessages) {
                                            app.messages.shift();
                                        }

                                        if (app.user.uid !== message.user.id) {
                                            received = message.user;
                                        }
                                    }

                                    app.feedQueue.unshift(message);
                                }

                                for (let i = app.messages.length - 1; i >= 0; i--) {
                                    if (!(app.messages[i].id in messageDictionary)) {
                                        app.messages.splice(i, 1);
                                    }
                                }

                                if (received) {
                                    if (!received.id && vrmModel) {
                                        //app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.A, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.A, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.A, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }]);
                                    }

                                    //document.body.querySelector("#alert").play();
                                }

                                app.update(messageDictionary, app.maxTags);

                                for (const sequence of app.character.sequences) {
                                    if (sequence.name == "Alert") {
                                        sequences.push(sequence);
                                    }
                                }

                                for (const obj of app.prepare(sequences)) {
                                    if (obj.type == "Message") {
                                        sequence.push({ type: obj.type, speed: obj.speed, duration: obj.duration, text: format(obj.text, app.feedQueue[0].text) });
                                    } else {
                                        sequence.push(obj);
                                    }
                                }

                                if (sequence.length > 0) {
                                    app.sequenceQueue.push(sequence);
                                }

                                app.feedQueue.push(app.feedQueue.shift());
                            }
                        });
                    } else {
                        // User is signed out.
                        database.ref(databaseChannel + "/stars").off('value');
                        database.ref(databaseMessages).off('value');

                        self.user = null;
                    }
                });
            },
            unmounted: function () {
                if (vrmModel !== null) {
                    scene.remove(vrmModel.scene);
                    vrmModel = null;
                }
            }
        }).mount('#app');

        window.addEventListener('resize', (event) => {
            let container = app.$refs.container;
            let popup = document.body.querySelector(".navbar:nth-of-type(2) .navbar-item .control:last-child .level:nth-last-of-type(1)");

            container.style.paddingTop = app.$refs.indicator.getBoundingClientRect().height + 'px'
            container.style.paddingBottom = app.$refs.input.getBoundingClientRect().height + 'px'

            //app.$refs.ticker.style.width = document.body.querySelector("#input .columns>.column .control:nth-last-of-type(1) .level:nth-last-of-type(1) form").getBoundingClientRect().width + 'px';

            if (popup !== null) {
                popup.style.paddingBottom = container.style.paddingBottom;
            }

            const width = window.innerWidth;
            const height = window.outerHeight;

            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            app.$nextTick(() => {
                let width = 0;

                for (const element of document.body.querySelectorAll(".background .ticker-wrap .ticker .item")) {
                    width += element.getBoundingClientRect().width;
                }

                document.body.querySelector(".background .ticker-wrap .ticker").style.width = width + 'px';
                document.body.querySelector(".background .ticker-wrap .ticker").animate([
                    {
                        transform: "translate3d(0, 0, 0)"
                    },
                    {
                        transform: "translate3d(-" + width / 2 + "px, 0, 0)"
                    }
                ], {
                    duration: 5 * 60 * 1000,
                    iterations: Infinity
                });
            });
        });
        window.addEventListener('click', (event) => {
            raycaster.setFromCamera(mouse, camera);

            for (let intersect of raycaster.intersectObjects(scene.children, true)) {
                if (intersect.object.name === 'face') {
                    //app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }]);

                    break;
                } else if (intersect.object.name.indexOf('breast') >= 0) {
                    /*if (random(0, 1) === 0) {
                        app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.0, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 3.0, start: 0.5, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.5, end: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.0, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 3.0, start: 0.5, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.5, end: 0.0 }]);
                    } else {
                        app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.Angry, time: 0.0, duration: 0.5, start: 0.0, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.Angry, time: 0.0, duration: 3.0, start: 0.5, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.Angry, time: 0.0, duration: 0.5, start: 0.5, end: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.O, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.O, time: 0.0, duration: 3.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.O, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }]);
                    }*/

                    break;
                }
            }
        });
        window.addEventListener('dblclick', (event) => {
            raycaster.setFromCamera(mouse, camera);

            if (raycaster.intersectObjects(scene.children, true).length > 0 && channel.length == 0) {
                app.talk();
            }
        });
        window.addEventListener('mousemove', (event) => {
            /*if (vrmModel) {
        
                const range = CAMERA_Z * Math.tan(CAMERA_FOV / 360.0 * Math.PI);
                const px = (2.0 * event.clientX - window.innerWidth) / window.outerHeight * range;
                const py = -(2.0 * event.clientY - window.outerHeight) / window.outerHeight * range;
        
                vrmModel.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName.Hips).position.set(px, py, 0.0);
            }*/
            mouse.x = (event.clientX / window.innerWidth) * 2.0 - 1.0;
            mouse.y = -(event.clientY / window.outerHeight) * 2.0 + 1.0;

            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener('touchstart', (event) => {
            mouse.x = (event.changedTouches[0].clientX / window.innerWidth) * 2.0 - 1.0;
            mouse.y = -(event.changedTouches[0].clientY / window.outerHeight) * 2.0 + 1.0;

            raycaster.setFromCamera(mouse, camera);

            for (let intersect of raycaster.intersectObjects(scene.children, true)) {
                if (intersect.object.name === 'face') {
                    //app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }]);

                    break;
                }
            }

            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.changedTouches[0].clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.changedTouches[0].clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener('touchmove', (event) => {
            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.changedTouches[0].clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.changedTouches[0].clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener('touchend', (event) => {
            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.changedTouches[0].clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.changedTouches[0].clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener("dragover", (event) => {
            event.preventDefault();
            event.dataTransfer.dropEffect = "copy";
        }, false);
        window.addEventListener("drop", (event) => {
            event.stopPropagation();
            event.preventDefault();

            for (let file of event.dataTransfer.files) {
                let reader = new FileReader();

                reader.addEventListener("load", (e) => {
                    const loader = new GLTFLoader();

                    loader.crossOrigin = "anonymous";
                    loader.load(
                        e.target.result,
                        (gltf) => {
                            THREE.VRM.from(gltf).then((vrm) => {
                                let sequences = [];

                                if (vrmModel !== null) {
                                    scene.remove(vrmModel.scene);
                                }

                                vrmModel = vrm;

                                scene.add(vrm.scene);

                                vrm.scene.rotation.y = Math.PI;
                                vrm.lookAt.target = lookAtTarget;

                                app.progress = 0.0;

                                for (const sequence of app.character.sequences) {
                                    if (sequence.name == "Start") {
                                        sequences.push(sequence);
                                    }
                                }

                                app.sequenceQueue.push(this.prepare(sequences));
                            });
                        },
                        (progress) => app.progress = progress.loaded / progress.total,
                        (error) => console.error(error)
                    );
                });
                reader.readAsDataURL(file);

                break;
            }

        }, false);

        particlesJS.load('particles-js', '/js/particlesjs-config.json', function () {
            app.isReady = true;
        });
    </script>
</body>

</html>