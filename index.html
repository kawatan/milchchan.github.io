<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <meta name="theme-color" content="#f6f6f6">
    <title>チャット</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP" rel="stylesheet">
    <link href="https://fonts.googleapis.com/earlyaccess/nicomoji.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Josefin+Sans&display=swap" rel="stylesheet">
    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css" type="text/css"
        media="screen" />
    <style>
        [v-cloak] {
            display: none;
        }

        .wf-notosansjapanese {
            font-family: "Noto Sans JP";
        }

        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            height: -webkit-fill-available;
            overflow-x: hidden;
            overflow-y: scroll;
            scroll-behavior: smooth;
            background: #f5f5f5;
        }

        body::before {
            z-index: -1;
            display: block;
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100vh;
            background: url('/images/Background.png') 50% 50% repeat;
            content: "";
        }

        body {
            position: relative;
            margin: 0;
            padding: 0;
            width: 100%;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow: hidden;
        }

        p,
        span,
        input {
            font-family: "Noto Sans JP";
        }

        label {
            display: inline;
            cursor: pointer;
        }

        .progress {
            margin: 0;
            width: 0%;
            height: 2px;
            top: 0;
            left: 0;
            overflow: hidden;
            background: #ffc547 url('/images/Stripes.png') repeat;
            animation: progress 0.5s linear 0s infinite;
        }

        #three {
            position: fixed;
            z-index: -1;
            display: block;
            width: 100%;
            height: 100vh;
        }

        #particles-js {
            position: fixed;
            z-index: -1;
            width: 100%;
            height: 100vh;
            background-color: transparent;
        }

        .cover {
            position: fixed;
            z-index: 0;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            transform: translate3d(0, 0%, 0);
            overflow: hidden;
            background: #30c0f5 url('/images/Stripes.png') repeat;
            animation: progress 0.5s linear 0s infinite;
        }

        .cover .columns {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            top: 0;
            left: 0;
            margin: 0;
            padding: 16px 16px 16px 16px;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background-color: transparent;
            background-position: center center;
            background-size: cover;
        }

        .cover .column {
            margin: 0;
            padding: 0;
        }

        .cover img.background {
            position: fixed;
            top: 100vh;
            left: 0;
            margin: 0;
            padding: 0;
        }

        .cover span {
            color: rgba(255, 255, 255, 1);
            /*text-shadow: -1px -1px rgba(48, 192, 245, 1), 1px -1px rgba(48, 192, 245, 1), -1px 1px rgba(48, 192, 245, 1), 1px 1px rgba(48, 192, 245, 1);*/
        }

        .type {
            position: fixed;
            display: flex;
            justify-content: center;
            align-items: flex-end;
            z-index: 0;
            top: 0;
            left: 0;
            margin: 0;
            padding: 16px 16px 16px 16px;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: transparent;
        }

        .type .column {
            margin: 0;
            padding: 0;
        }

        .type span {
            color: black;
            /*text-shadow: -1px -1px rgba(255, 255, 255, 1), 1px -1px rgba(255, 255, 255, 1), -1px 1px rgba(255, 255, 255, 1), 1px 1px rgba(255, 255, 255, 1);*/
            /*color: rgba(255, 255, 255, 1);
            text-shadow: -1px -1px rgba(48, 192, 245, 1), 1px -1px rgba(48, 192, 245, 1), -1px 1px rgba(48, 192, 245, 1), 1px 1px rgba(48, 192, 245, 1);*/
        }

        #heading .level .level-item .field span.icon {
            margin: 0px 8px 0px 0px;
        }

        #app {
            position: relative;
            margin: 0;
            width: 100%;
            overflow: hidden;
        }

        #heading>.columns {
            margin: 0;
            padding: 0;
        }

        #heading>.columns>.column {
            padding: 0;
        }

        #heading>.columns>.column .control {
            margin: 0;
            padding: 16px 16px 16px 16px;
        }

        #heading>.columns>.column>.columns {
            margin: 0;
            padding: 0;
        }

        #heading>.columns>.column>.columns>.column:first-child {
            margin: 16px 0px 0px 0px;
            padding: 0px 0px 0px 16px;
        }

        #heading>.columns>.column>.columns>.column:first-child button {
            border-radius: 290486px;
        }

        #heading>.columns>.column>.columns>.column:last-child {
            margin: 16px 0px 0px 0px;
            padding: 0px 16px 0px 0px;
            text-align: right;
        }

        #heading>.columns>.column>.columns>.column:last-child button {
            border-radius: 290486px;
        }

        #heading>.columns>.column>.columns>.column {
            padding: 0;
        }

        #heading .title {
            font-family: 'Josefin Sans', sans-serif;
        }

        #heading .subtitle {
            font-family: 'Nico Moji', sans-serif;
        }

        #heading .navbar-item .control:first-child .level {
            margin: 16px 16px 16px 16px;
            padding: 0;
        }

        #heading .navbar-item .control:first-child .level:nth-last-child(2) {
            margin: 0px 8px 0px 8px;
            padding: 0;
        }

        #heading .navbar-item .control:first-child .level:nth-last-child(1) {
            margin: 4px 8px 0px 8px;
            padding: 0;
        }

        #heading .navbar-item .control:nth-child(2) .level {
            margin: 0;
            padding: 0;
        }

        #heading .navbar-item .control:nth-child(2) .level:nth-last-child(3) {
            margin: 4px 0px 0px 0px;
            padding: 0;
        }

        #heading .navbar-item .control:nth-child(2) .level:nth-last-child(2) {
            margin: 0;
            padding: 16px 0px 16px 0px;
        }

        #heading .navbar-item .level .level-item {
            margin: 0;
            padding: 0;
        }

        #heading .navbar-item .tags>.control {
            margin: 0px 0px 0px 0px;
            padding: 8px 8px 8px 8px;
        }

        #heading .tags {
            margin: 0;
            padding: 0;
            align-items: flex-start;
            justify-content: center;
        }

        #heading .level>.level-item>.tags {
            margin: -8px;
            padding: 0;
        }

        .tags>.tag {
            /*font-family: "Gotham";*/
            margin: 0;
            padding: 0px 8px 0px 8px;
            /*background-image: url('/images/Stripes.png');
            background-repeat: repeat;*/
        }

        .columns .is-vcentered {
            align-items: center;
        }

        #container {
            z-index: 0;
            position: relative;
            margin: 0;
            padding: 0px env(safe-area-inset-right, 0px) 0px env(safe-area-inset-left, 0px);
        }

        #container .columns {
            margin: 0;
        }

        #container .column hr {
            margin: 16px 0px 16px 0px;
            padding: 0;
            height: 0;
        }

        #container .column {
            padding: 0px 16px 0px 16px;
        }

        #input .columns {
            margin: 0;
            padding: 0;
        }

        #input .column {
            padding: 0px 16px 0px 16px;
        }

        #input .control .is-primary {
            background-color: #30c0f5;
        }

        .has-content-centered {
            margin-left: auto;
            margin-right: auto;
        }

        .media-content .level {
            margin: 0px 0px 4px 0px;
        }

        .media-content .content div:last-child {
            margin: 4px 0px 0px 0px;
        }

        .media-content p {
            word-wrap: break-word;
            white-space: normal;
        }

        .media-content .has-text-left .balloon {
            display: inline-block;
            padding: 8px 16px 8px 16px;
            border-radius: 0px 500px 500px 500px;
            background: url('/images/Stripes.png') repeat;
        }

        .media-content .has-text-right .balloon {
            display: inline-block;
            padding: 8px 16px 8px 16px;
            border-radius: 500px 0px 500px 500px;
            background: url('/images/Stripes.png') repeat;
        }

        .media-content .has-text-left div:nth-last-of-type(1)>p {
            font-family: 'Josefin Sans', sans-serif;
        }

        .media-content .has-text-right div:nth-last-of-type(1)>p {
            font-family: 'Josefin Sans', sans-serif;
        }

        .navbar {
            background-color: transparent;
        }

        .navbar:first-of-type {
            margin: 0;
            padding: env(safe-area-inset-top, 0px) env(safe-area-inset-right, 0px) 0px env(safe-area-inset-left, 0px);
        }

        .navbar:first-of-type .navbar-item .control nav.level:nth-last-child(1) {
            display: block;
        }

        .navbar:nth-of-type(2) {
            margin: 0;
            padding: 0;
        }

        .navbar:nth-of-type(2) .navbar-item .control:first-child .level {
            display: block;
            margin: 0;
            padding: 16px 0px 0px 0px;
        }

        .navbar:nth-of-type(2) .navbar-item .control:first-child .level .notification {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            margin: 0;
            padding: 0;
        }

        .navbar:nth-of-type(2) .navbar-item .control:first-child .level .is-info {
            color: #ffffff;
        }

        .navbar:nth-of-type(2) .navbar-item .control:first-child .level .notification .media {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 500px 500px 500px 500px;
            padding: 8px 16px 8px 16px;
            background: url('/images/Stripes.png') repeat;
        }

        .navbar:nth-of-type(2) .notification .media .media-left {
            margin: 0px 8px 0px 0px;
        }

        .navbar:nth-of-type(2) .navbar-item>div>.control:last-child {
            margin: 0;
            padding: 0px env(safe-area-inset-right, 0px) env(safe-area-inset-bottom, 0px) env(safe-area-inset-left, 0px);
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(3) {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            margin: 0;
            padding: 16px 0px 0px 0px;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(3) .notification {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: transparent;
            margin: 0;
            padding: 0;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(3) .notification .media {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 500px 500px 500px 500px;
            padding: 8px 16px 8px 16px;
            background: #30c0f5 url('/images/Stripes.png') repeat;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(3) .notification .media .media-left {
            margin: 0px 8px 0px 0px;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(3) .field {
            margin: 0;
            padding: 0px -8px 0px -8px;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(3) .field label.checkbox {
            margin: 0;
            margin: 16px 8px 0px 8px;
            padding: 8px 16px 8px 16px;
            border-radius: 500px 500px 500px 500px;
            background: rgba(0, 0, 0, 0.75);
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(2) {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0px 0px 4px 0px;
            padding: 16px 0px 0px 0px;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(2)>span {
            font-family: 'Josefin Sans', sans-serif;
        }

        #input .navbar-item .control:last-child .level:nth-last-of-type(1) {
            display: block;
            margin: 0;
            padding: 0px 0px 16px 0px;
        }

        .navbar-item img {
            max-height: none;
        }

        .updating {
            animation: updating 1s linear infinite;
        }

        .fade-enter-active,
        .fade-leave-active {
            transition: opacity 0.5s;
        }

        .fade-enter,
        .fade-leave-to {
            opacity: 0;
        }

        .reveal-enter-active,
        .reveal-leave-active {
            transition: all .5s ease;
        }

        .reveal-enter,
        .reveal-leave-to {
            opacity: 0;
            transform: translate3d(0, -50%, 0);
        }

        .reveal-enter-to,
        .reveal-leave {
            opacity: 1;
            transform: translate3d(0, 0%, 0);
        }

        .collapse-enter-active,
        .collapse-leave-active {
            transition: all .5s ease;
        }

        .collapse-enter,
        .collapse-leave-to {
            opacity: 0;
        }

        .collapse-enter-to,
        .collapse-leave {
            opacity: 1;
        }

        .blind-enter-active,
        .blind-leave-active {
            transition: all .5s ease;
        }

        .blind-enter {
            transform: translate3d(0, 100%, 0);
        }

        .blind-enter-to {
            transform: translate3d(0, 0%, 0);
        }

        .blind-leave {
            transform: translate3d(0, 0%, 0);
        }

        .blind-leave-to {
            transform: translate3d(0, -100%, 0);
        }

        .message-list-enter-active,
        .message-list-leave-active {
            transition: all 0.5s ease;
        }

        .message-list-move {
            transition: transform 0.5s ease;
        }

        .message-list-enter {
            opacity: 0;
            transform: translate3d(0%, 50%, 0);
        }

        .message-list-enter-to,
        .message-list-leave {
            opacity: 1;
            transform: translate3d(0%, 0%, 0);
        }

        .message-list-leave-to {
            opacity: 0;
            transform: translate3d(0%, -50%, 0);
        }

        .notification-list-enter-active,
        .notification-list-leave-active {
            transition: all 0.5s ease;
        }

        .notification-list-move {
            transition: transform 0.5s ease;
        }

        .notification-list-enter {
            opacity: 0;
            transform: translate3d(0%, 50%, 0);
        }

        .notification-list-enter-to,
        .notification-list-leave {
            opacity: 1;
            transform: translate3d(0%, 0%, 0);
        }

        .notification-list-leave-to {
            opacity: 0;
            transform: translate3d(0%, 0%, 0);
        }

        .type-list-enter-active,
        .type-list-leave-active {
            transition: all 0s ease;
        }

        .type-list-move {
            transition: transform 0s ease;
        }

        .type-list-enter,
        .type-list-leave-to {
            opacity: 0;
            transform: translate3d(0%, 25%, 0);
        }

        .type-list-enter-to,
        .type-list-leave {
            opacity: 1;
            transform: translate3d(0%, 0%, 0);
        }

        @keyframes progress {
            0% {
                background-position: 0px 0px;
            }

            100% {
                background-position: -20px 0px;
            }
        }

        @keyframes updating {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(-360deg);
            }
        }

        @media screen and (-webkit-min-device-pixel-ratio:2),
        (min-resolution: 2dppx) {
            body::before {
                background: url('/images/Background@2x.png') 50% 50% repeat 128px 128px;
            }

            .progress {
                background: #ffc547 url('/images/Stripes@2x.png') repeat 20px 20px;
            }

            .cover {
                background: #30c0f5 url('/images/Stripes@2x.png') repeat 20px 20px;
            }

            /*.tags>.tag {
                background-image: url('/images/Stripes@2x.png');
                background-size: 20px 20px;
            }*/

            .media-content .has-text-left .balloon {
                background: url('/images/Stripes@2x.png') repeat 20px 20px;
            }

            .media-content .has-text-right .balloon {
                background: url('/images/Stripes@2x.png') repeat 20px 20px;
            }
        }

        @media screen and (-webkit-min-device-pixel-ratio:3),
        (min-resolution: 3dppx) {
            body::before {
                background: url('/images/Background@3x.png') 50% 50% repeat 128px 128px;
            }

            .progress {
                background: #ffc547 url('/images/Stripes@3x.png') repeat 20px 20px;
            }

            .cover {
                background: #30c0f5 url('/images/Stripes@3x.png') repeat 20px 20px;
            }

            /*.tags>.tag {
                background-image: url('/images/Stripes@3x.png');
                background-size: 20px 20px;
            }*/

            .media-content .has-text-left .balloon {
                background: url('/images/Stripes@3x.png') repeat 20px 20px;
            }

            .media-content .has-text-right .balloon {
                background: url('/images/Stripes@3x.png') repeat 20px 20px;
            }
        }

        @font-face {
            font-family: "Gotham";
            src: url('/fonts/Gotham-Book.woff') format('woff');
            font-weight: normal;
        }

        @font-face {
            font-family: "Gotham";
            src: url('/fonts/Gotham-Bold.woff') format('woff');
            font-weight: bold;
        }
    </style>
</head>

<body>
    <canvas id="three"></canvas>
    <div id="particles-js"></div>
    <div id="app">
        <div class="type columns is-mobile is-centered is-vcentered">
            <transition-group name="type-list" tag="div" class="column is-full has-text-centered" v-cloak>
                <span class="title is-2 has-text-weight-bold" v-for="character in text"
                    v-bind:key="character.key">{{ character.value }}</span>
            </transition-group>
        </div>
        <transition name="blind">
            <div class="cover" v-if="isBlinded" v-cloak>
                <img class="background" v-bind:src="cover" @load="load" @error="error" alt="Background"><img>
                <transition name="fade">
                    <div class="columns is-mobile is-centered is-vcentered" v-if="isPreloading" key="loading">
                        <div class="column is-full has-text-centered" v-show="highlight">
                            <span class="title is-2 has-text-weight-bold has-text-white">{{ highlight }}</span>
                        </div>
                    </div>
                    <div class="columns is-mobile is-centered is-vcentered"
                        v-bind:style="{backgroundImage: cover === null ? 'none' : 'url(' + cover + ')'}" v-else
                        key="loaded">
                        <transition name="fade">
                            <div class="column is-full has-text-centered" v-show="highlight">
                                <span class="title is-2 has-text-weight-bold has-text-white">{{ highlight }}</span>
                            </div>
                        </transition>
                    </div>
                </transition>
            </div>
        </transition>
        <div class="progress" v-if="progress !== 0.0" v-bind:style="{width: String(100.0 * progress) + '%'}" v-cloak>
        </div>
        <nav id="heading" class="navbar is-fixed-top" role="navigation">
            <div class="navbar-item is-expanded columns is-desktop">
                <div class="column is-full has-content-centered" v-cloak>
                    <div class="columns is-mobile">
                        <div class="column is-3 is-mobile">
                            <button class="button is-white" type="button" @click="isRevealed = !isRevealed">
                                <span class="icon is-small">
                                    <i class="fas fa-bars"></i>
                                </span>
                            </button>
                        </div>
                        <div class="column is-6 is-mobile">
                            <div class="control has-text-centered">
                                <nav class="level is-hidden">
                                    <div class="level-item has-text-centered image">
                                        <a href="/"><img src="/images/Logo.png"
                                                srcset="/images/Logo.png 1x, /images/Logo@2x.png 2x, /images/Logo@3x.png 3x"
                                                alt="milchchan.com"></a>
                                    </div>
                                </nav>
                                <nav class="level">
                                    <div class="level-item has-text-centered">
                                        <div class="field is-grouped is-vcentered">
                                            <span class="icon is-small">
                                                <i class="fas fa-book"></i>
                                            </span>
                                            <span class="title is-size-3">{{ animatedWords }}</span>
                                        </div>
                                    </div>
                                </nav>
                                <nav class="level">
                                    <div class="level-item has-text-centered">
                                        <div class="field">
                                            <h6 class="subtitle is-size-6 is-uppercase has-text-weight-bold">おぼえたことば
                                            </h6>
                                        </div>
                                    </div>
                                </nav>
                            </div>
                            <transition name="reveal">
                                <div class="control has-text-centered" v-if="isRevealed" v-cloak>
                                    <!--<nav class="level">
                                        <div class="level-item has-text-centered">
                                            <div class="field is-grouped is-vcentered">
                                                <span class="icon is-small">
                                                    <i class="fas fa-star"></i>
                                                </span>
                                                <span class="title is-size-4"
                                                    v-bind:class="{'is-invisible': words === -1}">{{ likes }}</span>
                                            </div>
                                        </div>
                                    </nav>
                                    <nav class="level">
                                        <div class="level-item has-text-centered">
                                            <div class="field">
                                                <h6 class="subtitle is-size-6 is-uppercase has-text-weight-bold">いいね
                                                </h6>
                                            </div>
                                        </div>
                                    </nav>-->
                                    <nav class="level">
                                        <transition name="fade" mode="out-in">
                                            <div class="level-item" v-if="isUpdating" key="updating">
                                                <span class="has-text-black">
                                                    <i class="fas fa-spinner updating"></i>
                                                </span>
                                            </div>
                                            <div class="level-item" v-else key="updated">
                                                <!--<div class="tags are-normal field is-grouped is-grouped-multiline is-hidden">
                                                <div class="control">
                                                    <div class="tags has-addons">
                                                        <span class="tag is-white"><a class="has-text-black"
                                                                href="https://www.microsoft.com/store/apps/9WZDNCRDT09Q">Apricot</a></span>
                                                        <span class="tag is-black">Windows</span>
                                                    </div>
                                                </div>
                                                <div class="control">
                                                    <div class="tags has-addons">
                                                        <span class="tag is-white"><a class="has-text-black"
                                                                href="https://clock.milchchan.com/">Clock</a></span>
                                                        <span class="tag is-black">Web</span>
                                                    </div>
                                                </div>
                                                <div class="control">
                                                    <div class="tags has-addons">
                                                        <span class="tag is-white"><a class="has-text-black"
                                                                href="https://apps.apple.com/jp/app/id1130755997">Wonderland</a></span>
                                                        <span class="tag is-black">iOS</span>
                                                    </div>
                                                </div>
                                            </div>-->
                                                <div class="tags are-medium field is-grouped is-grouped-multiline">
                                                    <div class="control" v-for="tag in tags" v-bind:key="tag.index">
                                                        <div class="tags has-addons">
                                                            <button class="button tag is-black is-rounded" type="button"
                                                                v-bind:style="{ backgroundColor: 'rgba(0, 0, 0, ' + (0.5 + 0.5 * tag.score) + ')' }"
                                                                @click="hint(tag)">{{ tag.name }}</button>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </transition>
                                    </nav>
                                    <!--<nav class="level">
                                        <div class="level-item">
                                            <span class="has-text-black">
                                                <button class="button is-white is-rounded"
                                                    v-bind:class="{'is-selected': isOverlayed, 'is-info': isOverlayed}"
                                                    @click="isOverlayed = !isOverlayed"><span class="icon is-small">
                                                        <i class="fas fa-comments"></i>
                                                    </span></button>
                                            </span>
                                        </div>
                                    </nav>-->
                                </div>
                            </transition>
                        </div>
                        <div class="column is-3 is-mobile">
                            <transition name="fade" mode="out-in">
                                <button class="button is-white" type="button" v-bind:disabled="user === null"
                                    @click="like" v-if="isSuggested" key="cancel">
                                    <span class="icon is-small">
                                        <i class="fas fa-times"></i>
                                    </span>
                                </button>
                                <button class="button is-white" type="button" v-bind:disabled="user === null"
                                    @click="like" v-else key="suggest">
                                    <span class="icon is-small">
                                        <i class="fas fa-tv"></i>
                                    </span>
                                </button>
                            </transition>
                        </div>
                    </div>
                </div>
            </div>
        </nav>
        <transition name="collapse">
            <transition-group id="container" name="message-list" tag="div" v-show="isOverlayed && !isSuggested">
                <div class="columns is-desktop" v-for="message in messages" v-bind:key="message.id">
                    <div class="column is-half has-content-centered">
                        <hr class="is-invisible">
                        <article class="media" v-if="user.uid === message.user.id" v-cloak>
                            <div class="media-content">
                                <div class="level is-mobile" v-if="message.user.name">
                                    <div class="level-left">
                                        <span
                                            class="is-size-7 has-text-weight-bold has-text-grey">{{ message.user.name }}</span>
                                    </div>
                                </div>
                                <div class="content has-text-right">
                                    <div class="balloon" v-bind:style="{ backgroundColor: message.user.accent }">
                                        <p class="has-text-weight-bold has-text-white">
                                            {{ message.text }}
                                        </p>
                                    </div>
                                    <div>
                                        <p class="is-size-7 has-text-weight-normal has-text-grey">
                                            {{ formatDate(message.timestamp) }}
                                        </p>
                                    </div>
                                </div>
                            </div>
                            <figure class="media-right" v-if="message.user.image">
                                <p class="image is-64x64">
                                    <img class="is-rounded" v-bind:src="message.user.image" alt="Avatar">
                                </p>
                            </figure>
                        </article>
                        <article class="media" v-else v-cloak>
                            <figure class="media-left" v-if="message.user.image">
                                <p class="image is-64x64">
                                    <img class="is-rounded" v-bind:src="message.user.image" alt="Avatar">
                                </p>
                            </figure>
                            <div class="media-content">
                                <div class="level is-mobile" v-if="message.user.name">
                                    <div class="level-left">
                                        <span
                                            class="is-size-7 has-text-weight-bold has-text-grey">{{ message.user.name }}</span>
                                    </div>
                                </div>
                                <div class="content has-text-left">
                                    <div class="balloon" v-bind:style="{ backgroundColor: message.user.accent }">
                                        <p class="has-text-weight-bold has-text-white">
                                            <span v-bind:class="{'is-hidden': message.text}">
                                                <i class="fas fa-spinner updating"></i>
                                            </span>
                                            {{ message.text }}
                                        </p>
                                    </div>
                                    <div>
                                        <p class="is-size-7 has-text-weight-normal has-text-grey">
                                            {{ formatDate(message.timestamp) }}</p>
                                    </div>
                                </div>
                            </div>
                        </article>
                    </div>
                </div>
            </transition-group>
        </transition>
        <transition name="collapse">
            <nav id="input" class="navbar is-fixed-bottom" role="navigation" v-show="isOverlayed && !isSuggested">
                <div class=" navbar-item is-expanded columns is-desktop">
                    <div class="column is-half has-content-centered is-mobile">
                        <transition-group name="notification-list" class="control" tag="div">
                            <nav class="level" v-for="notification in notifications" v-bind:key="notification.id">
                                <div class="notification is-info is-light" v-cloak>
                                    <article class="media" v-bind:style="{ backgroundColor: notification.accent }">
                                        <figure class="media-left" v-if="notification.image" v-cloak>
                                            <span class="image is-32x32">
                                                <img class="is-rounded" v-bind:src="notification.image" alt="Avatar">
                                            </span>
                                        </figure>
                                        <div class="media-content">
                                            <div class="content has-text-left">
                                                <span class="has-text-weight-bold has-text-white" v-cloak>
                                                    {{ notification.text }}
                                                </span>
                                            </div>
                                        </div>
                                    </article>
                                </div>
                            </nav>
                        </transition-group>
                        <div class="control">
                            <transition name="fade">
                                <nav class="level" v-show="isLearning">
                                    <div class="notification is-info is-light" v-cloak>
                                        <article class="media">
                                            <figure class="media-left">
                                                <span class="image is-32x32">
                                                    <img class="is-rounded" src="/images/Merku.png" alt="Avatar">
                                                </span>
                                            </figure>
                                            <div class="media-content">
                                                <div class="content has-text-left">
                                                    <span class="has-text-weight-bold has-text-white" v-cloak>
                                                        「{{ input }}」の意味を教えてね
                                                    </span>
                                                </div>
                                            </div>
                                        </article>
                                    </div>
                                    <div class="field has-addons has-addons-centered is-grouped is-grouped-multiline">
                                        <label class="checkbox" v-for="attribute in attributes"
                                            v-bind:key="attribute.name" v-cloak>
                                            <input type="checkbox" @change="check" v-model="attribute.value">
                                            <span
                                                class="title is-size-6 has-text-weight-bold has-text-white">{{ attribute.name }}</span>
                                        </label>
                                    </div>
                                </nav>
                            </transition>
                            <nav class="level">
                                <span class="is-size-7 has-text-weight-bold has-text-grey" v-cloak>
                                    {{ maxInputLength - animatedCurrentInputLength }}
                                </span>
                            </nav>
                            <nav class="level">
                                <form onsubmit="return false;">
                                    <div class="field has-addons">
                                        <div class="control">
                                            <button class="button is-rounded" type="button"
                                                v-bind:class="{'is-black': isLearning, 'is-static': input.length === 0}"
                                                v-bind:disabled="user === null" @click="learn"><span
                                                    class="icon is-small">
                                                    <i class="fas fa-plus"></i>
                                                </span>
                                            </button>
                                        </div>
                                        <div class="control is-expanded">
                                            <input class="input is-rounded" type="text"
                                                v-bind:class="{'is-danger': inputHasError}" v-bind:disabled="isLearning"
                                                v-model="input" @input="change">
                                        </div>
                                        <div class="control">
                                            <button class="button is-rounded is-primary" type="submit"
                                                v-bind:class="{'is-loading': isLoading}" v-bind:disabled="user === null"
                                                @click="send"><span class="icon is-small">
                                                    <i class="fas fa-paper-plane"></i>
                                                </span>
                                            </button>
                                        </div>
                                    </div>
                                </form>
                            </nav>
                        </div>
                    </div>
                </div>
            </nav>
        </transition>
        <audio id="popup" preload="auto">
            <source src="/sounds/plastic_hi.mp3" type="audio/mpeg" />
            <source src="/sounds/plastic_hi.m4a" type="audio/mp4" />
            <source src="/sounds/plastic_hi.wav" type="audio/wav" />
        </audio>
        <audio id="twinkle" preload="auto">
            <source src="/sounds/plastic_up_hi.mp3" type="audio/mpeg" />
            <source src="/sounds/plastic_up_hi.m4a" type="audio/mp4" />
            <source src="/sounds/plastic_up_hi.wav" type="audio/wav" />
        </audio>
    </div>
    <!-- The core Firebase JS SDK is always required and must be listed first -->
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-database.js"></script>
    <!-- TODO: Add SDKs for Firebase products that you want to use
     https://firebase.google.com/docs/web/setup#available-libraries -->
    <script src="https://www.gstatic.com/firebasejs/7.14.4/firebase-analytics.js"></script>
    <script src="https://unpkg.com/three@0.106.2/build/three.js"></script>
    <script src="https://unpkg.com/three@0.106.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.106.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
    <script src="/js/moment-with-locales.js"></script>
    <script src="/js/three-vrm.js"></script>
    <script src="/js/particles.js"></script>
    <script src="/js/tiny-segmenter.js"></script>
    <script type="text/javascript">
        // Your web app's Firebase configuration
        var firebaseConfig = {
            apiKey: "AIzaSyDTVxDJj7rqG9L-Clvba2Tao9B0hkcxjcE",
            authDomain: "milchchan.firebaseapp.com",
            databaseURL: "https://milchchan.firebaseio.com",
            projectId: "milchchan",
            storageBucket: "milchchan.appspot.com",
            messagingSenderId: "355698971889",
            appId: "1:355698971889:web:e3653c5c31bd7289cd4550",
            measurementId: "G-3998FJYNWX"
        };
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        firebase.analytics();

        const debug = getParameterByName("debug") || false;
        const channel = decodeURIComponent(window.location.hash.substring(1));
        const databaseRoot = 'chat';
        const databaseChannel = channel.length > 0 ? databaseRoot + '/channels/' + channel : databaseRoot;
        const databaseMessages = databaseChannel + '/messages';
        let database = firebase.database();
        const milch = { name: 'ミルヒちゃん', accent: '#ffa6bb', image: '/images/Milch.png' };
        const merku = { name: 'メルクちゃん', accent: '#5bcbe1', image: '/images/Merku.png' };

        //databaseRoot.remove();

        /*databaseRoot.remove().orderByChild('timestamp')
            .startAt(1).limitToFirst(2)
            .once('value', function (snapshot) { console.log(snapshot.val()) })*/

        function random(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);

            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function getParameterByName(name) {
            name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");

            var regex = new RegExp("[\\?&]" + name + "=([^&#]*)");
            var results = regex.exec(window.location.href);

            if (results == null) {
                return null;
            }

            return decodeURIComponent(results[1].replace(/\+/g, " "));
        }

        document.title = channel.length === 0 ? 'ミルヒちゃんねる' : '#' + channel;

        //var channel = getParameterByName("channel") || getParameterByName("ch") || "";

        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById("three"),
            alpha: true
        });

        renderer.setSize(window.innerWidth, window.outerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0xffffff, 0);

        if (channel.length > 0) {
            renderer.domElement.classList.add("is-hidden");
        }

        const CAMERA_FOV = 60.0;
        const CAMERA_Z = -1.0;
        const camera = new THREE.PerspectiveCamera(CAMERA_FOV, window.innerWidth / window.outerHeight, 0.1, 1000);

        camera.position.set(0.0, 1.25, CAMERA_Z);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        controls.enableKeys = false;
        controls.screenSpacePanning = true;
        controls.target.set(0.0, 0.95, 0.025);
        controls.update();

        const scene = new THREE.Scene();
        const light = new THREE.DirectionalLight(0xffffff);

        light.intensity = 1;
        light.position.set(0.0, 10.0, -10.0).normalize();

        scene.add(light);
        //scene.add(new THREE.GridHelper(10, 10));
        //scene.add(new THREE.AxesHelper(5));

        const lookAtTarget = new THREE.Object3D();

        camera.add(lookAtTarget);

        const stats = new Stats();

        stats.domElement.style.position = "fixed";
        stats.domElement.style.top = "0px";

        if (!debug) {
            stats.domElement.classList.add("is-hidden");
        }

        document.body.appendChild(stats.domElement);

        var app = new Vue({
            el: '#app',
            data: {
                isReady: false,
                isLoading: false,
                isRevealed: false,
                isUpdating: false,
                isBlinded: false,
                isOverlayed: true,
                isSuggested: false,
                suggestionQueue: [],
                progress: 0,
                user: null,
                input: '',
                currentInputLength: 0,
                animatedCurrentInputLength: 0,
                maxInputLength: 100,
                inputHasError: false,
                messages: [],
                maxMessages: 10,
                tags: [],
                maxTags: 10,
                scrollRequired: false,
                words: 0,
                animatedWords: 0,
                likes: -1,
                notifications: [],
                vrm: null,
                animations: null,
                animationsQueue: [],
                currentAnimations: [],
                blendShapeAnimations: [],
                blendShapeAnimationQueue: [],
                highlight: null,
                cover: null,
                isPreloading: false,
                isComputing: false,
                text: [],
                script: { messages: null, words: null, wordDictionary: {}, reverseWordDictionary: {} },
                isLearning: false,
                attributes: [{ name: "有名人", value: false },
                { name: "人の名前", value: false },
                { name: "職業", value: false },
                { name: "人を表すことば", value: false },
                { name: "ロボット", value: false },
                { name: "すること", value: false },
                { name: "行くところ", value: false },
                { name: "食べ物", value: false },
                { name: "飲み物", value: false },
                { name: "生き物", value: false },
                { name: "音楽", value: false },
                { name: "見るもの", value: false },
                { name: "読むもの", value: false },
                { name: "使うもの", value: false },
                { name: "身につけるもの", value: false },
                { name: "乗り物", value: false },
                { name: "ことば", value: false },
                { name: "体の一部", value: false },
                { name: "病気", value: false }]
            },
            watch: {
                words: function (newValue) {
                    const obj = { count: this.animatedWords };

                    anime({
                        targets: obj,
                        count: newValue,
                        round: 1,
                        duration: 500,
                        easing: 'linear',
                        update: () => {
                            this.animatedWords = obj.count
                        }
                    });
                },
                currentInputLength: function (newValue) {
                    const obj = { count: this.animatedCurrentInputLength };

                    anime({
                        targets: obj,
                        count: newValue,
                        round: 1,
                        duration: 500,
                        easing: 'linear',
                        update: () => {
                            this.animatedCurrentInputLength = obj.count
                        }
                    });
                },
                cover: function (newValue) {
                    if (newValue) {
                        this.isPreloading = true;
                    } else {
                        this.isPreloading = false;
                    }
                }
            },
            methods: {
                send: async function (event) {
                    if (this.input.length > 0 && this.input.length <= this.maxInputLength) {
                        function format(format) {
                            var args = arguments;

                            return format.replace(/\{(\d)\}/g, function (m, c) { return args[parseInt(c) + 1] });
                        }

                        const text = this.input;
                        const url = 'https://api.milchchan.com/talk?text=' + text + '&threshold=1.0';
                        let segmenter = new TinySegmenter();
                        let regex = new RegExp('[.#$\\[\\]]');
                        let tokens = [];

                        for (let token of segmenter.segment(text)) {
                            if (!regex.test(token)) {
                                tokens.push(token);
                            }
                        }

                        this.input = '';
                        this.currentInputLength = 0;
                        this.$el.querySelector("#popup").play();

                        let ref = database.ref(databaseMessages).push();
                        let completed = 0;
                        let learnedWords = [];

                        ref.set({ text: text, timestamp: Math.floor(new Date() / 1000), user: { id: app.user.uid, name: null, accent: null, image: null } });

                        for (let token of tokens) {
                            database.ref(databaseRoot + "/dictionary/words/" + token).transaction(function (word) {
                                if (word === null) {
                                    return ref.key;
                                }

                                return;
                            }, function (error, committed, snapshot) {
                                if (committed) {
                                    learnedWords.push(token);

                                    database.ref(databaseRoot + "/dictionary/count").transaction(function (count) {
                                        return (count || 0) + 1;
                                    });
                                } else if (error) {
                                    console.error(error);
                                }

                                completed++;

                                if (completed == tokens.length && learnedWords.length > 0) {
                                    for (let i = 0; i < learnedWords.length; i++) {
                                        window.setTimeout(function () {
                                            app.notify({ text: format(channel.length == 0 ? '「{0}」をおぼえたよぉ' : '「{0}」をおぼえたよ', learnedWords[i]), accent: merku.accent, image: channel.length == 0 ? merku.image : null });
                                        }, (i + 1) * 500);
                                    }

                                    window.pJSDom[0].pJS.fn.modes.pushParticles(learnedWords.length);
                                }
                            });
                        }

                        try {
                            this.isLoading = true;

                            const response = await fetch(encodeURI(url), {
                                mode: "cors",
                                method: "GET",
                                headers: {
                                    "Content-Type": "application/x-www-form-urlencoded"
                                }
                            });

                            if (response.ok) {
                                const json = await response.json();

                                if (json.text.length > 0) {
                                    database.ref(databaseMessages).push({ text: json.text, timestamp: Math.floor(new Date() / 1000), thread: ref.key, user: { id: null, name: milch.name, accent: milch.accent, image: milch.image } });
                                }
                            }
                            else {
                                throw new Error(response.statusText);
                            }

                            this.isLoading = false;
                        }
                        catch (e) {
                            this.isLoading = false;
                            this.notify({ text: channel.length == 0 ? 'もう一度試してほしいよぉ' : 'もう一度試してみてね', accent: merku.accent, image: channel.length == 0 ? merku.image : null });

                            console.error(e.message);
                        }
                    }
                },
                change: function (event) {
                    this.currentInputLength = this.input.length;

                    if (this.currentInputLength <= this.maxInputLength) {
                        this.inputHasError = false;
                    } else {
                        this.inputHasError = true;
                    }
                },
                like: function () {
                    if (this.isSuggested) {
                        if (this.suggestionQueue.length > 0) {
                            this.suggestionQueue[0].messages[0].type.reverse = true;
                            this.isBlinded = true;
                        } else {
                            this.isBlinded = false;
                        }

                        this.isSuggested = false;
                    } else {
                        this.suggestionQueue.splice(0);
                        this.isBlinded = true;
                        this.isSuggested = true;
                        this.$el.querySelector("#twinkle").play();
                    }



                    return;
                    /*if (this.isLearning) {
                        this.messages.push({ id: this.messages.length, text: 'また今度教えてね', tint: merku.tint, avatar: merku.avatar, author: merku.name, timestamp: new Date() });
                        this.isLearning = false;
                    } else {
                        this.messages.push({ id: this.messages.length, text: '最初にミルヒちゃんに送るメッセージを教えて欲しいよぉ', tint: merku.tint, avatar: merku.avatar, author: merku.name, timestamp: new Date() });
                        this.isLearning = true;
                    }

                    this.scrollRequired = true;
                    */

                    database.ref(databaseChannel + "/likes").transaction(function (count) {
                        return (count || 0) + 1;
                    });

                    if (this.vrm && 'jump' in this.animations) {
                        this.animationsQueue.push(this.animations['jump']);
                    }

                    window.pJSDom[0].pJS.fn.modes.pushParticles(1);

                    //this.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }]);

                    /*database.ref(databaseChannel + "likes").once('value', snapshot => {
                        const count = snapshot.val();
            
                        if (count === null) {
                            database.ref(databaseChannel + "likes").update({ 'likes': 1 })
                        }
                        else {
                            database.ref(databaseChannel).update({ 'likes': count + 1 })
                        }
                    });*/

                    this.$el.querySelector("#twinkle").play();
                },
                check: function (event) {
                    let attributes = {};
                    const timestamp = Math.floor(new Date() / 1000);
                    let isEmpty = true;
                    let ref = database.ref(databaseRoot + "/words/" + this.input);

                    for (const attribute of this.attributes) {
                        attributes[attribute.name] = attribute.value;

                        if (attribute.value) {
                            isEmpty = false;
                        }
                    }

                    ref.transaction(function (current) {
                        if (isEmpty) {
                            return null;
                        }

                        return attributes;
                    }, function (error, committed, snapshot) {
                        if (committed) {
                            /*database.ref(databaseRoot + "/vocabularies").transaction(function (count) {
                                return (count || 0) + 1;
                            });*/
                        } else if (error) {
                            console.error(error);
                        }
                    });

                    return;

                    if (index > 0) {

                    } else {
                        database.ref(databaseRoot + "/words/" + this.input).transaction(function (current) {
                            return null;
                        }, function (error, committed, snapshot) {
                            if (committed) {
                                /*database.ref(databaseRoot + "/vocabularies").transaction(function (count) {
                                    if (count) {
                                        count -= 1;

                                        if (count > 0) {
                                            return count;
                                        } else {
                                            return null;
                                        }
                                    }

                                    return;
                                });*/
                            } else if (error) {
                                console.error(error);
                            }
                        });
                    }
                },
                learn: function () {
                    if (this.isLearning) {
                        this.isLearning = false;
                    } else {
                        for (const attribute of this.attributes) {
                            attribute.value = false;
                        }

                        database.ref(databaseRoot + "/words/" + this.input).once('value', snapshot => {
                            const word = snapshot.val();

                            if (word !== null) {
                                for (const attribute of this.attributes) {
                                    if (attribute.name in word) {
                                        attribute.value = word[attribute.name];
                                    }
                                }
                            }

                            this.isLearning = true;
                        });
                    }
                },
                talk: async function () {
                    function generateUuid() {
                        // https://github.com/GoogleChrome/chrome-platform-analytics/blob/master/src/internal/identifier.js
                        // const FORMAT: string = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
                        let chars = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".split("");

                        for (let i = 0, len = chars.length; i < len; i++) {
                            switch (chars[i]) {
                                case "x":
                                    chars[i] = Math.floor(Math.random() * 16).toString(16);
                                    break;
                                case "y":
                                    chars[i] = (Math.floor(Math.random() * 4) + 8).toString(16);
                                    break;
                            }
                        }
                        return chars.join("");
                    }

                    function choice(x, probabilities) {
                        const r = Math.random();
                        let sum = 0.0;
                        let index = 0;

                        console.log(probabilities);

                        for (let probability of probabilities) {
                            if (sum <= r && r < sum + probability) {
                                break;
                            }

                            sum += probability;
                            index++;
                        }

                        return x[index];
                    }

                    function softmax(x) {
                        let y = [];
                        let max = Number.MIN_VALUE;
                        let sum = 0.0;

                        for (let i = 0; i < x.length; i++) {
                            if (x[i] > max) {
                                max = x[i];
                            }
                        }

                        for (let i = 0; i < x.length; i++) {
                            sum += Math.exp(x[i] - max);
                        }

                        for (let i = 0; i < x.length; i++) {
                            y.push(Math.exp(x[i] - max) / sum);
                        }

                        return y;
                    }

                    let segmenter = new TinySegmenter();
                    let cachDictionary = {};
                    let text = '';
                    let epsilon = Math.pow(10, -6);

                    for (const token of segmenter.segment(this.script.messages[random(0, this.script.messages.length - 1)])) {
                        if (token in cachDictionary) {
                            text += cachDictionary[token]
                        } else {
                            let terms = [];
                            let scores = [];
                            const snapshot1 = await database.ref(databaseRoot + "/words/" + token).once('value');

                            if (snapshot1.exists()) {
                                const word = snapshot1.val();

                                for (let attribute in word) {
                                    if (word[attribute]) {
                                        const snapshot2 = await database.ref(databaseRoot + "/words/").orderByChild(attribute).equalTo(true).once('value');

                                        if (snapshot2.exists()) {
                                            const words = snapshot2.val();

                                            for (let key in words) {
                                                if (!terms.includes(key)) {
                                                    let isNew = true;

                                                    terms.push(key);

                                                    for (const tag of this.tags) {
                                                        if (key == tag.name) {
                                                            scores.push(tag.score);
                                                            isNew = false;

                                                            break;
                                                        }
                                                    }

                                                    if (isNew) {
                                                        scores.push(epsilon);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            if (terms.length > 0) {
                                const term = choice(terms, softmax(scores));

                                text += term;
                                cachDictionary[token] = term;
                            } else {
                                text += token;
                            }
                        }
                    }

                    this.messages.push({ id: generateUuid(), text: text, timestamp: Math.floor(new Date() / 1000), user: { id: null, name: milch.name, accent: milch.accent, image: milch.image } });

                    if (this.messages.length > this.maxMessages) {
                        this.messages.shift();
                    }

                    this.scrollRequired = true;
                },
                hint: function (event) {
                    this.input += event.name;
                },
                notify: function (data) {
                    let id = -1;

                    for (const notification of this.notifications) {
                        if (notification.id > id) {
                            id = notification.id;
                        }
                    }

                    id++;
                    data['id'] = id;

                    this.notifications.push(data);

                    window.setTimeout(async function () {
                        for (let i = 0; i < app.notifications.length; i++) {
                            if (app.notifications[i].id == id) {
                                app.notifications.splice(i, 1);

                                break;
                            }
                        }
                    }, 3000);
                },
                load: function () {
                    this.isPreloading = false;
                },
                error: function () {
                    this.cover = null;
                },
                update: async function (data, max) {
                    this.isUpdating = true;

                    try {
                        const results = await new Promise(resolve => {
                            let segmenter = new TinySegmenter();
                            let documents = [];
                            let filteredDocuments = [];
                            let termFrequencies = [];
                            let inverseDocumentFrequency = {};
                            const baseTime = new Date().getTime() - 12 * 60 * 60 * 1000;
                            const limit = 10;
                            let scoreDictionary = {};
                            let scores = [];
                            let maxScore = 0.0;

                            for (const key in data) {
                                const tokens = segmenter.segment(data[key].text);

                                if (tokens.length > 0) {
                                    let termSet = [];

                                    documents.push({ tokens: tokens, timestamp: data[key].timestamp });

                                    for (const token of tokens) {
                                        if (!termSet.includes(token)) {
                                            if (token in inverseDocumentFrequency) {
                                                inverseDocumentFrequency[token] += 1.0;
                                            } else {
                                                inverseDocumentFrequency[token] = 1.0;
                                            }

                                            termSet.push(token);
                                        }
                                    }
                                }
                            }

                            for (const key in inverseDocumentFrequency) {
                                inverseDocumentFrequency[key] = Math.log(documents.length / inverseDocumentFrequency[key]);
                            }

                            for (const document of documents) {
                                if (document.timestamp * 1000 > baseTime) {
                                    filteredDocuments.push(document);
                                }
                            }

                            if (filteredDocuments.length < limit) {
                                const min = Math.max(documents.length - limit, 0);

                                filteredDocuments.splice(0);

                                for (let i = documents.length - 1; i >= min; i--) {
                                    filteredDocuments.unshift(documents[i]);
                                }
                            }

                            for (const document of filteredDocuments) {
                                let tf = {};

                                for (const token of document.tokens) {
                                    if (token in tf) {
                                        tf[token] += 1.0;
                                    } else {
                                        tf[token] = 1.0;
                                    }
                                }

                                for (const key in tf) {
                                    tf[key] /= document.tokens.length;

                                    if (!(key in scoreDictionary)) {
                                        scoreDictionary[key] = 0.0;
                                    }
                                }

                                termFrequencies.push(tf);
                            }

                            for (const key in scoreDictionary) {
                                for (const termFrequency of termFrequencies) {
                                    if (key in termFrequency) {
                                        const tfidf = termFrequency[key] * inverseDocumentFrequency[key];

                                        if (tfidf > scoreDictionary[key]) {
                                            scoreDictionary[key] = tfidf;
                                        }
                                    }
                                }
                            }

                            for (const key in scoreDictionary) {
                                if (key.length > 1 && key != '...') {
                                    scores.push({ term: key, value: scoreDictionary[key] });
                                }
                            }

                            scores.sort((x, y) => y.value - x.value);

                            if (scores.length > max) {
                                scores.splice(max);
                            }

                            for (const score of scores) {
                                if (score.value > maxScore) {
                                    maxScore = score.value;
                                }
                            }

                            for (const score of scores) {
                                score.value /= maxScore;
                            }

                            scores.sort((x, y) => {
                                if (x.term > y.term) {
                                    return 1;
                                } else if (x.term < y.term) {
                                    return -1;
                                }

                                return 0;
                            });

                            resolve(scores);
                        });

                        this.tags.splice(0);

                        for (let i = 0; i < results.length; i++) {
                            this.tags.push({ index: i, name: results[i].term, score: results[i].value })
                        }
                    } catch (e) {
                        console.error(e);
                    }

                    this.isUpdating = false;
                },
                scrollToEnd: function () {
                    document.documentElement.scrollTop = document.documentElement.scrollHeight;
                },
                formatDate: function (event) {
                    moment.locale(window.navigator.language);

                    return moment(event).format('LT');
                }
            },
            updated: function () {
                let container = this.$el.querySelector("#container");

                container.style.paddingTop = this.$el.querySelector("#heading .navbar-item .control:first-child").getBoundingClientRect().height + 'px';
                container.style.paddingBottom = this.$el.querySelector("#input .navbar-item>div>.control:last-child").getBoundingClientRect().height + 'px';

                if (this.scrollRequired) {
                    this.scrollToEnd();
                    this.scrollRequired = false;
                }
            },
            created: async function () {
                const loader = new THREE.GLTFLoader();

                loader.crossOrigin = "anonymous";
                loader.load(
                    "/models/Milch.vrm",
                    (gltf) => {
                        THREE.VRM.from(gltf).then(async (vrm) => {
                            const urls = {
                                idle1: '/models/animations/animation-idle1.json',
                                idle2: '/models/animations/animation-idle2.json',
                                //idle3: '/models/animations/animation-idle3.json',
                                //idle4: '/models/animations/animation-idle4.json',
                                jump: '/models/animations/animation-jump.json',
                                lose: '/models/animations/animation-lose.json',
                                //run: '/models/animations/animation-run.json',
                                //walk: '/models/animations/animation-walk.json',
                                win: '/models/animations/animation-win.json'
                            };
                            let animationDictionary = {};

                            try {
                                if (channel.length == 0) {
                                    for (let key in urls) {
                                        const response = await fetch(encodeURI(urls[key]), {
                                            mode: "cors",
                                            method: "GET",
                                            headers: {
                                                "Content-Type": "application/x-www-form-urlencoded"
                                            }
                                        });

                                        if (response.ok) {
                                            const json = await response.json();

                                            animationDictionary[key] = json.data;
                                        }
                                        else {
                                            throw new Error(response.statusText);
                                        }
                                    }

                                    app.animationsQueue.push(animationDictionary['jump']);
                                }

                                const response1 = await fetch('/js/words.json', {
                                    mode: "cors",
                                    method: "GET",
                                    headers: {
                                        "Content-Type": "application/x-www-form-urlencoded"
                                    }
                                });

                                if (response1.ok) {
                                    const json = await response1.json();

                                    app.script.words = json;
                                }
                                else {
                                    throw new Error(response1.statusText);
                                }

                                for (const word of app.script.words) {
                                    if (word.name in app.script.wordDictionary) {
                                        for (const attribute of word.attributes) {
                                            app.script.wordDictionary[word.name].attributes.push(attribute);

                                            if (attribute in app.script.reverseWordDictionary) {
                                                app.script.reverseWordDictionary[attribute].push(word.name);
                                            } else {
                                                app.script.reverseWordDictionary[attribute] = [word.name];
                                            }
                                        }
                                    } else {
                                        app.script.wordDictionary[word.name] = word.attributes;

                                        for (const attribute of word.attributes) {
                                            if (attribute in app.script.reverseWordDictionary) {
                                                app.script.reverseWordDictionary[attribute].push(word.name);
                                            } else {
                                                app.script.reverseWordDictionary[attribute] = [word.name];
                                            }
                                        }
                                    }
                                }

                                const response2 = await fetch('/js/milch.json', {
                                    mode: "cors",
                                    method: "GET",
                                    headers: {
                                        "Content-Type": "application/x-www-form-urlencoded"
                                    }
                                });

                                if (response2.ok) {
                                    const json = await response2.json();

                                    app.script.messages = json;
                                }
                                else {
                                    throw new Error(response2.statusText);
                                }

                                app.animations = animationDictionary;
                                app.vrm = vrm;

                                scene.add(vrm.scene);

                                //vrm.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName.Hips).rotation.y = Math.PI;

                                //currentMixer = prepareAnimation(vrm);

                                vrm.lookAt.target = lookAtTarget;

                                app.progress = 0.0;
                            } catch (e) {
                                console.error(e);
                            }
                        });
                    },
                    (progress) => app.progress = progress.loaded / progress.total,
                    (error) => console.error(error)
                );
            },
            destroyed: function () {
                if (this.vrm !== null) {
                    scene.remove(this.vrm.scene);
                    this.vrm = null;
                }
            },
            mounted: function () {
                let container = this.$el.querySelector("#container");

                container.style.paddingTop = this.$el.querySelector("#heading .navbar-item .control:first-child").getBoundingClientRect().height + 'px';
                container.style.paddingBottom = this.$el.querySelector("#input .navbar-item>div>.control:last-child").getBoundingClientRect().height + 'px';

                firebase.auth().signInAnonymously().catch(function (error) {
                    console.error(error.code, error.message);
                });
                firebase.auth().onAuthStateChanged(function (user) {
                    if (user) {
                        // User is signed in.
                        app.user = user;

                        database.ref(databaseRoot + "/dictionary/count").on('value', snapshot => {
                            const count = snapshot.val();

                            if (count === null) {
                                app.words = 0;
                            } else {
                                app.words = count;
                            }
                        });
                        database.ref(databaseChannel + "/likes").on('value', snapshot => {
                            const count = snapshot.val();

                            if (count === null) {
                                app.likes = 0;
                            } else {
                                if (app.likes >= 0) {
                                    window.pJSDom[0].pJS.fn.modes.pushParticles(1);
                                }

                                app.likes = count;
                            }
                        });
                        database.ref(databaseMessages).limitToLast(100).on('value', snapshot => {
                            const messageDictionary = snapshot.val();

                            if (messageDictionary) {
                                let keys = Object.keys(messageDictionary);
                                let received = null;

                                if (keys.length > app.maxMessages) {
                                    keys.splice(0, keys.length - app.maxMessages);
                                }

                                for (let key of keys) {
                                    const message = messageDictionary[key];
                                    let index = -1;

                                    //console.log(date.toISOString());
                                    //console.log(date.toLocaleTimeString());

                                    for (let i = 0; i < app.messages.length; i++) {
                                        if (key === app.messages[i].id) {
                                            index = i;

                                            break;
                                        }
                                    }

                                    if (!message.user.accent) {
                                        message.user.accent = '#30c0f5';
                                    }

                                    if (index >= 0) {
                                        app.$set(app.messages, key, { id: key, text: message.text, thread: message.thread, timestamp: new Date(message.timestamp * 1000), user: message.user });
                                    }
                                    else {
                                        app.messages.push({ id: key, text: message.text, thread: message.thread, timestamp: new Date(message.timestamp * 1000), user: message.user });

                                        if (app.messages.length > app.maxMessages) {
                                            app.messages.shift();
                                        }

                                        if (app.user.uid !== message.user.id) {
                                            received = message.user;
                                        }
                                    }
                                }

                                for (let i = app.messages.length - 1; i >= 0; i--) {
                                    if (!(app.messages[i].id in messageDictionary)) {
                                        app.messages.splice(i, 1);
                                    }
                                }

                                app.scrollRequired = true;

                                if (received) {
                                    if (!received.id && app.vrm) {
                                        app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Joy, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.A, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.A, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.A, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }]);
                                    }

                                    app.$el.querySelector("#popup").play();
                                }

                                app.update(messageDictionary, app.maxTags);
                            }
                        });
                    } else {
                        // User is signed out.
                        database.ref(databaseRoot + "/dictionary/count").off('value')
                        database.ref(databaseChannel + "/likes").off('value');
                        database.ref(databaseMessages).off('value');

                        app.user = null;
                    }
                });
            }
        });

        const clock = new THREE.Clock();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let animationIndex = 0;
        const animationSkipFrames = 2;
        let idleTime = 0.0;
        const blinkThreshold = 5.0;
        let waitTime = 0.0;
        const waitThreshold = 1.0;
        let activateTime = 0.0;
        const activateThreshold = 10.0;
        let lookAnimation = null;

        function render() {
            requestAnimationFrame(render);

            const deltaTime = clock.getDelta();

            if (app.vrm) {
                let isActive = false;
                let messageData = null;
                let updatedBlendShapeNames = [];

                if (app.currentAnimations.length > 0 && animationIndex < app.currentAnimations.length) {
                    messageData = app.currentAnimations[animationIndex];
                    animationIndex += animationSkipFrames;
                    isActive = true;
                }

                if (app.blendShapeAnimations.length == 0 && app.blendShapeAnimationQueue.length > 0) {
                    for (let blendShapeAnimation of app.blendShapeAnimationQueue.shift()) {
                        app.blendShapeAnimations.unshift(blendShapeAnimation);
                    }

                    isActive = true;
                }

                for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                    let blendShapeAnimation = app.blendShapeAnimations[i];

                    if (!updatedBlendShapeNames.includes(blendShapeAnimation.name)) {
                        if (blendShapeAnimation.time < blendShapeAnimation.duration) {
                            blendShapeAnimation.time += deltaTime;

                            if (blendShapeAnimation.time >= blendShapeAnimation.duration) {
                                app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.end / 2 * Math.PI)));
                                app.blendShapeAnimations.splice(i, 1);
                            } else {
                                app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin((blendShapeAnimation.time / blendShapeAnimation.duration * (blendShapeAnimation.end - blendShapeAnimation.start) + blendShapeAnimation.start) / 2 * Math.PI)));
                            }

                            isActive = true;
                        }

                        updatedBlendShapeNames.push(blendShapeAnimation.name);
                    }
                }

                if (app.suggestionQueue.length > 0) {
                    const suggestion = app.suggestionQueue[0];
                    const message = suggestion.messages[0];
                    let loopRequired = true;

                    if (message.type.reverse) {
                        if (message.type.count > 0) {
                            message.type.elapsed += deltaTime;

                            if (message.type.elapsed >= message.type.speed / 1000.0) {
                                let index = message.type.count - 1;

                                if (index < message.text.length) {
                                    let width = Math.floor(message.text.length / 2);

                                    if (message.type.buffer.length <= width) {
                                        message.type.count -= 1;
                                    }

                                    if (message.type.buffer.length > 0) {
                                        message.type.buffer = message.type.buffer.substring(message.type.buffer.length - 2, message.type.buffer.length - 1);
                                    }
                                }

                                message.type.elapsed = 0;
                            }
                        } else if (app.isSuggested) {
                            /*suggestion.time = 0;
                            suggestion.type.elapsed = -1;
                            suggestion.type.reverse = false;
                            suggestion.type.buffer = '';
                            suggestion.type.count = 0;

                            if ('morphs' in suggestion) {
                                for (let blendShapeAnimation of suggestion.morphs.animations) {
                                    blendShapeAnimation.time = 0;
                                }
                            }*/

                            if (suggestion.messages.length > 1) {
                                suggestion.messages.shift();
                            } else {
                                app.suggestionQueue.shift();

                                if (app.suggestionQueue.length > 0 && 'highlight' in app.suggestionQueue[0]) {
                                    if ('text' in app.suggestionQueue[0].highlight) {
                                        app.highlight = app.suggestionQueue[0].highlight.text;
                                    } else {
                                        app.highlight = null;
                                    }

                                    if ('image' in app.suggestionQueue[0].highlight) {
                                        app.cover = app.suggestionQueue[0].highlight.image;
                                    } else {
                                        app.cover = app;
                                    }
                                }

                                app.isBlinded = true;
                            }
                        } else if (app.isBlinded && !isActive) {
                            if ('morphs' in suggestion) {
                                for (let blendShape of suggestion.morphs.defaults) {
                                    app.vrm.blendShapeProxy.setValue(blendShape.name, Math.abs(Math.sin(blendShape.weight / 2 * Math.PI)));
                                }
                            }

                            app.suggestionQueue.splice(0);
                            app.isBlinded = false;
                            app.scrollRequired = true;
                            loopRequired = false;
                        }
                    } else if (message.type.buffer.length < message.text.length) {
                        if (message.type.elapsed >= 0) {
                            message.type.elapsed += deltaTime;
                        } else if (!isActive) {
                            if (!app.isPreloading) {
                                waitTime += deltaTime;
                            }

                            if (app.highlight === null && app.cover === null || waitTime >= waitThreshold) {
                                message.type.elapsed = deltaTime;
                                app.isBlinded = false;
                                app.currentAnimations.splice(0);

                                if ('animation' in suggestion && suggestion.animation in app.animations) {
                                    const skipFrames = 60 / 12;
                                    let animations = app.animations[suggestion.animation];
                                    let maxFrames = Math.min(animations.length, 60);
                                    let offset = Math.floor(Math.max(0, random(0, animations.length - maxFrames - 1)) / 2);
                                    let length = Math.round(90 / 24);

                                    for (let i = 0; i < maxFrames; i += skipFrames) {
                                        for (let j = 0; j < length; j++) {
                                            app.currentAnimations.push(animations[offset + i]);
                                        }
                                    }

                                    for (let i = app.currentAnimations.length - 1; i >= 0; i--) {
                                        app.currentAnimations.push(animations[offset + i]);
                                    }
                                }

                                if ('morphs' in suggestion) {
                                    let nameSet = [];

                                    for (let blendShape of suggestion.morphs.defaults) {
                                        app.vrm.blendShapeProxy.setValue(blendShape.name, Math.abs(Math.sin(blendShape.weight / 2 * Math.PI)));
                                    }

                                    for (let blendShapeAnimation of suggestion.morphs.animations) {
                                        app.blendShapeAnimations.unshift(blendShapeAnimation);
                                    }

                                    for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                                        let blendShapeAnimation = app.blendShapeAnimations[i];

                                        if (!nameSet.includes(blendShapeAnimation.name)) {
                                            app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.start / 2 * Math.PI)));
                                            nameSet.push(blendShapeAnimation.name);
                                        }
                                    }
                                }

                                waitTime = 0.0;
                            } else {
                                loopRequired = false;
                            }
                        }

                        if (message.type.elapsed >= message.type.speed / 1000.0) {
                            let index = message.type.buffer.length;
                            let width = Math.floor(message.text.length / 2);
                            let length = message.text.length;

                            if (message.type.count >= width) {
                                message.type.buffer += message.text.charAt(index);
                            }

                            if (message.type.count < length) {
                                message.type.count += 1;
                            }

                            message.type.elapsed = 0;
                        }
                    } else {
                        message.time += deltaTime;

                        if (message.time >= message.duration) {
                            message.type.reverse = true;
                        }
                    }

                    if (message.text.length === message.type.buffer.length) {
                        const characters = message.text.split('');

                        app.text.splice(0);

                        for (let i = 0; i < characters.length; i++) {
                            app.text.push({ key: i, value: characters[i] });
                        }
                    } else {
                        let charArray = new Array();
                        let randomBuffer = '';

                        for (let i = 0; i < message.text.length; i++) {
                            if (charArray.indexOf(message.text.charAt(i)) == -1 && message.text.charAt(i).match(/\s/) == null) {
                                charArray.push(message.text.charAt(i));
                            }
                        }

                        for (let i = 0; i < message.type.count; i++) {
                            if (charArray.length > 0) {
                                randomBuffer += charArray[~~random(0, charArray.length - 1)];
                            }
                        }

                        if (randomBuffer.length > message.type.buffer.length) {
                            const characters = (message.type.buffer + randomBuffer.substring(message.type.buffer.length, randomBuffer.length)).split('');

                            app.text.splice(0);

                            for (let i = 0; i < characters.length; i++) {
                                app.text.push({ key: i, value: characters[i] });
                            }
                        } else if (app.text.length !== message.type.buffer.length) {
                            const characters = message.type.buffer.split('');

                            app.text.splice(0);

                            for (let i = 0; i < characters.length; i++) {
                                app.text.push({ key: i, value: characters[i] });
                            }
                        }
                    }

                    if (loopRequired && messageData === null) {
                        animationIndex = 0;
                        messageData = app.currentAnimations[animationIndex];
                        animationIndex += animationSkipFrames;
                    }
                } else {
                    if (app.isSuggested && app.suggestionQueue.length == 0 && !app.isComputing) {
                        const tempMessages1 = [].concat(app.messages);
                        const tempTags = [].concat(app.tags);

                        app.isComputing = true;

                        new Promise(resolve => {
                            let segmenter = new TinySegmenter();
                            const presets = [{ animation: 'idle2', name: THREE.VRMSchema.BlendShapePresetName.Fun },
                            { animation: 'jump', name: THREE.VRMSchema.BlendShapePresetName.Joy },
                            { animation: 'win', name: THREE.VRMSchema.BlendShapePresetName.Joy },
                            { animation: 'lose', name: THREE.VRMSchema.BlendShapePresetName.Sorrow }];
                            let suggestions = [];
                            let tempMessages2 = [];
                            let ids1 = [];
                            let ids2 = [];

                            for (let tag of tempTags.sort((x, y) => y.score - x.score)) {
                                for (let message of tempMessages1.reverse()) {
                                    if (!ids1.includes(message.id) && segmenter.segment(message.text).includes(tag.name)) {
                                        let thread = null;

                                        if ('thread' in message) {
                                            for (let m of tempMessages1) {
                                                if (message.thread == m.id) {
                                                    thread = m;

                                                    break;
                                                }
                                            }
                                        }

                                        if (thread === null) {
                                            tempMessages2.push(message);
                                        } else {
                                            const item = presets[random(0, 3)];

                                            suggestions.push({ highlight: { text: '今日の' + document.title, image: '/images/Cover.png' }, messages: [{ time: 0, duration: 5, type: { elapsed: -1, speed: 50, reverse: false, buffer: '', count: 0 }, text: thread.text }, { time: 0, duration: 5, type: { elapsed: 0, speed: 50, reverse: false, buffer: '', count: 0 }, text: message.text }], animation: item.animation, morphs: { animations: [{ name: item.name, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }], defaults: [{ name: THREE.VRMSchema.BlendShapePresetName.Joy, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Sorrow, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Fun, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Blink, weight: 0.0 }] } });

                                            if (!ids2.includes(thread.id)) {
                                                ids2.push(thread.id);
                                            }
                                        }

                                        ids1.push(message.id);
                                    }
                                }
                            }

                            for (const message of tempMessages2) {
                                if (!ids2.includes(message.id)) {
                                    const item = presets[random(0, 3)];

                                    suggestions.push({ highlight: { text: '今日の' + document.title, image: '/images/Cover.png' }, messages: [{ time: 0, duration: 5, type: { elapsed: -1, speed: 50, reverse: false, buffer: '', count: 0 }, text: message.text }], animation: item.animation, morphs: { animations: [{ name: item.name, time: 0.0, duration: 1.0, start: 1.0, end: 1.0 }], defaults: [{ name: THREE.VRMSchema.BlendShapePresetName.Joy, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Sorrow, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Fun, weight: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.Blink, weight: 0.0 }] } });
                                }
                            }

                            resolve(suggestions);
                        }).then((result) => {
                            if (app.isSuggested && result.length > 0) {
                                for (const suggestion of result) {
                                    app.suggestionQueue.push(suggestion);
                                }

                                if ('highlight' in app.suggestionQueue[0]) {
                                    if ('text' in app.suggestionQueue[0].highlight) {
                                        app.highlight = app.suggestionQueue[0].highlight.text;
                                    } else {
                                        app.highlight = null;
                                    }

                                    if ('image' in app.suggestionQueue[0].highlight) {
                                        app.cover = app.suggestionQueue[0].highlight.image;
                                    } else {
                                        app.cover = null;
                                    }
                                }
                            }

                            app.isComputing = false;
                        });
                    }

                    if (messageData === null) {
                        app.currentAnimations.splice(0);

                        if (app.animationsQueue.length > 0) {
                            for (let animation of app.animationsQueue.shift()) {
                                app.currentAnimations.push(animation);
                            }

                            idleTime = 0.0;
                            activateTime = 0.0;
                        } else {
                            const idles = ['idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle1', 'idle2'];
                            const idle = idles[random(0, 14)];

                            if (idle in app.animations) {
                                for (let animation of app.animations[idle]) {
                                    app.currentAnimations.push(animation);
                                }
                            }

                            if (app.blendShapeAnimationQueue.length > 0) {
                                idleTime = 0.0;
                                activateTime = 0.0;
                            } else {
                                idleTime += deltaTime;
                                activateTime += deltaTime;

                                if (activateTime >= activateThreshold) {
                                    //app.talk();

                                    idleTime = 0.0;
                                    activateTime = 0.0;
                                } else if (idleTime >= blinkThreshold) {
                                    const durations = [0.5, 1.0];
                                    const ends = [2.0, 4.0];
                                    const index = random(0, 1);
                                    const duration = durations[index];
                                    const end = ends[index];
                                    let nameSet = [];

                                    for (let blendShapeAnimation of [{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: duration, start: 0.0, end: end }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: duration, start: 0.0, end: end }]) {
                                        app.blendShapeAnimations.unshift(blendShapeAnimation);
                                    }

                                    for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                                        let blendShapeAnimation = app.blendShapeAnimations[i];

                                        if (!nameSet.includes(blendShapeAnimation.name)) {
                                            app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.start / 2 * Math.PI)));
                                            nameSet.push(blendShapeAnimation.name);
                                        }
                                    }

                                    idleTime = 0.0;
                                }
                            }
                        }

                        animationIndex = 0;
                        messageData = app.currentAnimations[animationIndex];
                        animationIndex += animationSkipFrames;
                    } else if (app.blendShapeAnimationQueue.length > 0) {
                        idleTime = 0.0;
                        activateTime = 0.0;
                    } else {
                        idleTime += deltaTime;
                        activateTime += deltaTime;

                        if (activateTime >= activateThreshold) {
                            //app.talk();

                            idleTime = 0.0;
                            activateTime = 0.0;
                        } else if (idleTime >= blinkThreshold) {
                            const durations = [0.5, 1.0];
                            const ends = [2.0, 4.0];
                            const index = random(0, 1);
                            const duration = durations[index];
                            const end = ends[index];
                            let nameSet = [];

                            for (let blendShapeAnimation of [{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: duration, start: 0.0, end: end }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: duration, start: 0.0, end: end }]) {
                                app.blendShapeAnimations.unshift(blendShapeAnimation);
                            }

                            for (let i = app.blendShapeAnimations.length - 1; i >= 0; i--) {
                                let blendShapeAnimation = app.blendShapeAnimations[i];

                                if (!nameSet.includes(blendShapeAnimation.name)) {
                                    app.vrm.blendShapeProxy.setValue(blendShapeAnimation.name, Math.abs(Math.sin(blendShapeAnimation.start / 2 * Math.PI)));
                                    nameSet.push(blendShapeAnimation.name);
                                }
                            }

                            idleTime = 0.0;
                        }
                    }
                }

                if (lookAnimation !== null) {
                    lookAnimation.time += deltaTime;

                    if (lookAnimation.time >= lookAnimation.duration) {
                        lookAtTarget.position.x = lookAnimation.target.x;
                        lookAtTarget.position.y = lookAnimation.target.y;
                        lookAnimation = null;
                    } else {
                        const rate = lookAnimation.time / lookAnimation.duration;

                        lookAtTarget.position.x = lookAnimation.source.x + (lookAnimation.target.x - lookAnimation.source.x) * rate;
                        lookAtTarget.position.y = lookAnimation.source.y + (lookAnimation.target.y - lookAnimation.source.y) * rate;
                    }
                }

                if (messageData) {
                    for (let animation of messageData.animations) {
                        switch (animation.bone) {
                            case 'chest':
                            case 'head':
                            case 'hips':
                            case 'jaw':
                            case 'leftEye':
                            case 'leftFoot':
                            case 'leftHand':
                            case 'leftIndexDistal':
                            case 'leftIndexIntermediate':
                            case 'leftIndexProximal':
                            case 'leftLittleDistal':
                            case 'leftLittleIntermediate':
                            case 'leftLittleProximal':
                            case 'leftLowerArm':
                            case 'leftLowerLeg':
                            case 'leftMiddleDistal':
                            case 'leftMiddleIntermediate':
                            case 'leftMiddleProximal':
                            case 'leftRingDistal':
                            case 'leftRingIntermediate':
                            case 'leftRingProximal':
                            case 'leftShoulder':
                            case 'leftThumbDistal':
                            case 'leftThumbIntermediate':
                            case 'leftThumbProximal':
                            case 'leftToes':
                            case 'leftUpperArm':
                            case 'leftUpperLeg':
                            case 'neck':
                            case 'rightEye':
                            case 'rightFoot':
                            case 'rightHand':
                            case 'rightIndexDistal':
                            case 'rightIndexIntermediate':
                            case 'rightIndexProximal':
                            case 'rightLittleDistal':
                            case 'rightLittleIntermediate':
                            case 'rightLittleProximal':
                            case 'rightLowerArm':
                            case 'rightLowerLeg':
                            case 'rightMiddleDistal':
                            case 'rightMiddleIntermediate':
                            case 'rightMiddleProximal':
                            case 'rightRingDistal':
                            case 'rightRingIntermediate':
                            case 'rightRingProximal':
                            case 'rightShoulder':
                            case 'rightThumbDistal':
                            case 'rightThumbIntermediate':
                            case 'rightThumbProximal':
                            case 'rightToes':
                            case 'rightUpperArm':
                            case 'rightUpperLeg':
                            case 'spine':
                            case 'upperChest':
                                break;
                            case 'eye.L':
                                animation.bone = 'leftEye';
                                break;
                            case 'foot.L':
                                animation.bone = 'leftFoot';
                                break;
                            case 'hand.L':
                                animation.bone = 'leftHand';
                                break;
                            case 'f_index.03.L':
                                animation.bone = 'leftIndexDistal';
                                break;
                            case 'f_index.02.L':
                                animation.bone = 'leftIndexIntermediate';
                                break;
                            case 'f_index.01.L':
                                animation.bone = 'leftIndexProximal';
                                break;
                            case 'f_pinky.03.L':
                                animation.bone = 'leftLittleDistal';
                                break;
                            case 'f_pinky.02.L':
                                animation.bone = 'leftLittleIntermediate';
                                break;
                            case 'f_pinky.01.L':
                                animation.bone = 'leftLittleProximal';
                                break;
                            case 'lower_arm.L':
                                animation.bone = 'leftLowerArm';
                                break;
                            case 'shin.L':
                                animation.bone = 'leftLowerLeg';
                                break;
                            case 'f_middle.03.L':
                                animation.bone = 'leftMiddleDistal';
                                break;
                            case 'f_middle.02.L':
                                animation.bone = 'leftMiddleIntermediate';
                                break;
                            case 'f_middle.01.L':
                                animation.bone = 'leftMiddleProximal';
                                break;
                            case 'f_ring.03.L':
                                animation.bone = 'leftRingDistal';
                                break;
                            case 'f_ring.02.L':
                                animation.bone = 'leftRingIntermediate';
                                break;
                            case 'f_ring.01.L':
                                animation.bone = 'leftRingProximal';
                                break;
                            case 'shoulder.L':
                                animation.bone = 'leftShoulder';
                                break;
                            case 'thumb_distal.L':
                                animation.bone = 'leftThumbDistal';
                                break;
                            case 'thumb_intermediate.L':
                                animation.bone = 'leftThumbIntermediate';
                                break;
                            case 'thumb_proximal.L':
                                animation.bone = 'leftThumbProximal';
                                break;
                            case 'toe.L':
                                animation.bone = 'leftToes';
                                break;
                            case 'upper_arm.L':
                                animation.bone = 'leftUpperArm';
                                break;
                            case 'thigh.L':
                                animation.bone = 'leftUpperLeg';
                                break;
                            case 'eye.R':
                                animation.bone = 'rightEye';
                                break;
                            case 'foot.R':
                                animation.bone = 'rightFoot';
                                break;
                            case 'hand.R':
                                animation.bone = 'rightHand';
                                break;
                            case 'f_index.03.R':
                                animation.bone = 'rightIndexDistal';
                                break;
                            case 'f_index.02.R':
                                animation.bone = 'rightIndexIntermediate';
                                break;
                            case 'f_index.01.R':
                                animation.bone = 'rightIndexProximal';
                                break;
                            case 'f_pinky.03.R':
                                animation.bone = 'rightLittleDistal';
                                break;
                            case 'f_pinky.02.R':
                                animation.bone = 'rightLittleIntermediate';
                                break;
                            case 'f_pinky.01.R':
                                animation.bone = 'rightLittleProximal';
                                break;
                            case 'lower_arm.R':
                                animation.bone = 'rightLowerArm';
                                break;
                            case 'shin.R':
                                animation.bone = 'rightLowerLeg';
                                break;
                            case 'f_middle.03.R':
                                animation.bone = 'rightMiddleDistal';
                                break;
                            case 'f_middle.02.R':
                                animation.bone = 'rightMiddleIntermediate';
                                break;
                            case 'f_middle.01.R':
                                animation.bone = 'rightMiddleProximal';
                                break;
                            case 'f_ring.03.R':
                                animation.bone = 'rightRingDistal';
                                break;
                            case 'f_ring.02.R':
                                animation.bone = 'rightRingIntermediate';
                                break;
                            case 'f_ring.01.R':
                                animation.bone = 'rightRingProximal';
                                break;
                            case 'shoulder.R':
                                animation.bone = 'rightShoulder';
                                break;
                            case 'thumb_distal.R':
                                animation.bone = 'rightThumbDistal';
                                break;
                            case 'thumb_intermediate.R':
                                animation.bone = 'rightThumbIntermediate';
                                break;
                            case 'thumb_proximal.R':
                                animation.bone = 'rightThumbProximal';
                                break;
                            case 'toe.R':
                                animation.bone = 'rightToes';
                                break;
                            case 'upper_arm.R':
                                animation.bone = 'rightUpperArm';
                                break;
                            case 'thigh.R':
                                animation.bone = 'rightUpperLeg';
                                break;
                            case 'upper_chest':
                                animation.bone = 'upperChest';
                                break;
                            default:
                                animation.bone = null;
                        }

                        if (animation.bone && animation.rotation.length == 4) {
                            try {
                                app.vrm.humanoid.getBoneNode(animation.bone).position.set(animation.position[0], animation.position[1], -animation.position[2]);
                                app.vrm.humanoid.getBoneNode(animation.bone).quaternion.set(-animation.rotation[0], -animation.rotation[1], animation.rotation[2], animation.rotation[3]);
                            } catch (e) {
                                console.log(animation.bone);
                            }
                        }
                    }
                }

                app.vrm.update(deltaTime);

                /*if (currentMixer) {
                    currentMixer.update(deltaTime);
                }*/

                renderer.render(scene, camera);
            }

            stats.update();
        }

        render();

        window.addEventListener('resize', (event) => {
            let container = app.$el.querySelector("#container");

            container.style.paddingTop = app.$el.querySelector("#heading .navbar-item .control:first-child").getBoundingClientRect().height + 'px';
            container.style.paddingBottom = app.$el.querySelector("#input .navbar-item>div>.control:last-child").getBoundingClientRect().height + 'px';

            const width = window.innerWidth;
            const height = window.outerHeight;

            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
        window.addEventListener('click', (event) => {
            raycaster.setFromCamera(mouse, camera);

            for (let intersect of raycaster.intersectObjects(scene.children, true)) {
                if (intersect.object.name === 'face') {
                    app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }]);

                    break;
                } else if (intersect.object.name.indexOf('breast') >= 0) {
                    if (random(0, 1) === 0) {
                        app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.0, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 3.0, start: 0.5, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.5, end: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.0, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 3.0, start: 0.5, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.5, end: 0.0 }]);
                    } else {
                        app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.Angry, time: 0.0, duration: 0.5, start: 0.0, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.Angry, time: 0.0, duration: 3.0, start: 0.5, end: 0.5 }, { name: THREE.VRMSchema.BlendShapePresetName.Angry, time: 0.0, duration: 0.5, start: 0.5, end: 0.0 }, { name: THREE.VRMSchema.BlendShapePresetName.O, time: 0.0, duration: 0.5, start: 0.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.O, time: 0.0, duration: 3.0, start: 1.0, end: 1.0 }, { name: THREE.VRMSchema.BlendShapePresetName.O, time: 0.0, duration: 0.5, start: 1.0, end: 0.0 }]);
                    }

                    break;
                }
            }
        });
        window.addEventListener('dblclick', (event) => {
            raycaster.setFromCamera(mouse, camera);

            if (raycaster.intersectObjects(scene.children, true).length > 0 && channel.length == 0) {
                app.talk();
            }
        });
        window.addEventListener('mousemove', (event) => {
            /*if (currentVrm) {
        
                const range = CAMERA_Z * Math.tan(CAMERA_FOV / 360.0 * Math.PI);
                const px = (2.0 * event.clientX - window.innerWidth) / window.outerHeight * range;
                const py = -(2.0 * event.clientY - window.outerHeight) / window.outerHeight * range;
        
                currentVrm.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName.Hips).position.set(px, py, 0.0);
            }*/
            mouse.x = (event.clientX / window.innerWidth) * 2.0 - 1.0;
            mouse.y = -(event.clientY / window.outerHeight) * 2.0 + 1.0;

            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener('touchstart', (event) => {
            mouse.x = (event.changedTouches[0].clientX / window.innerWidth) * 2.0 - 1.0;
            mouse.y = -(event.changedTouches[0].clientY / window.outerHeight) * 2.0 + 1.0;

            raycaster.setFromCamera(mouse, camera);

            for (let intersect of raycaster.intersectObjects(scene.children, true)) {
                if (intersect.object.name === 'face') {
                    app.blendShapeAnimationQueue.push([{ name: THREE.VRMSchema.BlendShapePresetName.BlinkL, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }, { name: THREE.VRMSchema.BlendShapePresetName.BlinkR, time: 0.0, duration: 0.5, start: 0.0, end: 2.0 }]);

                    break;
                }
            }

            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.changedTouches[0].clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.changedTouches[0].clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener('touchmove', (event) => {
            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.changedTouches[0].clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.changedTouches[0].clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener('touchend', (event) => {
            lookAnimation = { time: 0.0, duration: 0.5, source: { x: lookAtTarget.position.x, y: lookAtTarget.position.y }, target: { x: (event.changedTouches[0].clientX - 0.5 * window.innerWidth) / window.outerHeight * 10.0, y: (event.changedTouches[0].clientY - 0.5 * window.outerHeight) / window.outerHeight * -10.0 } };
        });
        window.addEventListener("dragover", (event) => {
            event.preventDefault();
            event.dataTransfer.dropEffect = "copy";
        }, false);
        window.addEventListener("drop", (event) => {
            event.stopPropagation();
            event.preventDefault();

            for (let file of event.dataTransfer.files) {
                let reader = new FileReader();

                reader.addEventListener("load", (e) => {
                    const loader = new THREE.GLTFLoader();

                    loader.crossOrigin = "anonymous";
                    loader.load(
                        e.target.result,
                        (gltf) => {
                            THREE.VRM.from(gltf).then((vrm) => {
                                if (app.vrm !== null) {
                                    scene.remove(app.vrm.scene);
                                }

                                app.vrm = vrm;

                                scene.add(vrm.scene);

                                //vrm.humanoid.getBoneNode(THREE.VRMSchema.HumanoidBoneName.Hips).rotation.y = Math.PI;

                                //currentMixer = prepareAnimation(vrm);

                                vrm.lookAt.target = lookAtTarget;

                                app.progress = 0.0;
                            });
                        },
                        (progress) => app.progress = progress.loaded / progress.total,
                        (error) => console.error(error)
                    );
                });
                reader.readAsDataURL(file);

                break;
            }

        }, false);

        particlesJS.load('particles-js', '/js/particlesjs-config.json', function () {
            app.isReady = true;
        });
    </script>
</body>

</html>